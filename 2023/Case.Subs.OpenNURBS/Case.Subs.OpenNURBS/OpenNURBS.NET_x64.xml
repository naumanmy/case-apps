<?xml version="1.0"?>
<doc>
    <assembly>
        "OpenNURBS.NET_x64"
    </assembly>
    <members>
        <member name="M:RMA.OpenNURBS.OnBox.IsDegenerate(System.Double)">
            <summary>
Test the box to see if it is degenerate (flat) in one or more directions
</summary>
            <param name="tolerance">
[in] Distances &lt;= tolerance will be considered to be zero.
If tolerance is negative (default shoudl be ON_UNSET_VALUE), then a scale invarient tolerance is used.
</param>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBox.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate sphere about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBox.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate sphere about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBox.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate sphere about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBox.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate sphere about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBox.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>returns point on box that is closest to given point</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBox.dz">
            <summary>intervals are finite and increasing when the box is valid</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBox.dy">
            <summary>intervals are finite and increasing when the box is valid</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBox.dx">
            <summary>intervals are finite and increasing when the box is valid</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBox.IsDegenerate(System.Double)">
            <summary>
Test the box to see if it is degenerate (flat) in one or more directions
</summary>
            <param name="tolerance">
[in] Distances &lt;= tolerance will be considered to be zero.
If tolerance is negative (default shoudl be ON_UNSET_VALUE), then a scale invarient tolerance is used.
</param>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBox.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>returns point on box that is closest to given point</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBox.dz">
            <summary>intervals are finite and increasing when the box is valid</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBox.dy">
            <summary>intervals are finite and increasing when the box is valid</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBox.dx">
            <summary>intervals are finite and increasing when the box is valid</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_MergeBreps(RMA.OpenNURBS.IOnBrep,RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>
Merges two breps into a single brep. The result may be non-manifold or have multiple connected components.
</summary>
            <returns>Merged brep or NULL if calculation failed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Get3dConvexHull(RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.ArrayOnPlaneEquation@)">
            <summary>Get a convex hull of a set of 3d points.</summary>
            <param name="points">
[in] List of points.  This function can handle tens of points but is too slow for hundreds of points.
</param>
            <param name="hull">
[out] Equations of the sides of the convex hull are appended to this list.  
A point P is inside the hull if hull[i].ValueAt(P) &lt;= 0 for every plane equation.
</param>
            <returns>
Number of equations appended to hull[] array.
If 0, then the points are coincident or colinear.
If 2, then the points are coplanar and the returned planes are parallel.
If &gt;= 4, then the points are in a 3d convex hull.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_NurbsSurfaceQuadrilateral(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Get an ON_NurbsSurface definition of a quadrilateral.</summary>
            <param name="P">[in]</param>
            <param name="Q">[in]</param>
            <param name="R">[in]</param>
            <param name="S">[in] corners in counter clockwise layer</param>
            <param name="nurbs_surface">
[in] if this pointer is not NULL, then this ON_NurbsSurface is used to return the quadrilateral.
</param>
            <returns>An ON_NurbsSurface representation of the quadrilateral.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_TriangleNormal(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Finds the unit normal to the triangle</summary>
            <param name="A">[in] triangle corner</param>
            <param name="B">[in] triangle corner</param>
            <param name="B">[in] triangle corner</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_LineTriangleIntersect(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,System.Double[]@,System.Double@,System.Double[]@)">
            <summary>Finds the intersection between a line segment an a triangle.</summary>
            <param name="A">[in] triangle corner</param>
            <param name="B">[in] triangle corner</param>
            <param name="C">[in] triangle corner</param>
            <param name="P">[in] start of line segment</param>
            <param name="Q">[in] end of line segment</param>
            <param name="tolerance" />
            <param name="t0">[out] line coordinate of first intersection point</param>
            <param name="abc0">[out] array of 3 doubles defining barycentric coordinates of first intersection point</param>
            <param name="t1">[out] line coordinate of second intersection point</param>
            <param name="abc1">[out] array of 3 doubles defining barycentric coordinates of second intersection point</param>
            <returns>
0 - no intersection
1 - one intersection point
2 - intersection segment
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ClosestPointToTriangleFast(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double@)">
            <summary>
Finds the barycentric coordinates of the point on a 
triangle that is closest to P.
Parameters:
 A - [in] triangle corner
 B - [in] triangle corner
 C - [in] triangle corner
 P - [in] point to test
 a - [out] barycentric coordinate
 b - [out] barycentric coordinate
 c - [out] barycentric coordinate
 If ON_ClosestPointToTriangle() returns true, then
 (*a)*A + (*b)*B + (*c)*C is the point on the 
 triangle's plane that is closest to P.  It is 
 always the case that *a + *b + *c = 1, but this
 function will return negative barycentric 
 coordinate if the point on the plane is not
 inside the triangle.
</summary>
            <returns>
True if the triangle is not degenerate.  False if the
triangle is degenerate; in this case the returned
closest point is the input point that is closest to P.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ClosestPointToTriangle(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double@)">
            <summary>Finds the barycentric coordinates of the point on a triangle that is closest to P.</summary>
            <param name="A">[in] triangle corner</param>
            <param name="B">[in] triangle corner</param>
            <param name="C">[in] triangle corner</param>
            <param name="P">[in] point to test</param>
            <param name="a">[out] barycentric coordinate</param>
            <param name="b">[out] barycentric coordinate</param>
            <param name="c">[out] barycentric coordinate</param>
            <remarks>
If ON_ClosestPointToTriangle() returns true, then (*a)*A + (*b)*B + (*c)*C is the point on the 
triangle's plane that is closest to P. It is always the case that *a + *b + *c = 1, but this
function will return negative barycentric coordinate if the point on the plane is not inside the triangle.
</remarks>
            <returns>
True if the triangle is not degenerate.  False if the
triangle is degenerate; in this case the returned
closest point is the input point that is closest to P.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ArePointsOnPlane(RMA.OpenNURBS.IArrayOn4dPoint,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnPlane,System.Double)">
            <param name="bbox">if needed, use ON_GetBoundingBox</param>
            <returns>0 = no, 1 = yes, 2 = points are coincident and on line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ArePointsOnPlane(RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnPlane,System.Double)">
            <param name="bbox">if needed, use ON_GetBoundingBox</param>
            <returns>0 = no, 1 = yes, 2 = points are coincident and on line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ArePointsOnPlane(RMA.OpenNURBS.IArrayOn2dPoint,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnPlane,System.Double)">
            <param name="bbox">if needed, use ON_GetBoundingBox</param>
            <returns>0 = no, 1 = yes, 2 = points are coincident and on line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ArePointsOnLine(RMA.OpenNURBS.IArrayOn4dPoint,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnLine,System.Double)">
            <param name="bbox">if needed, use ON_GetBoundingBox</param>
            <returns>0 = no, 1 = yes, 2 = points are coincident and on line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ArePointsOnLine(RMA.OpenNURBS.IArrayOn3dPoint,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnLine,System.Double)">
            <param name="bbox">if needed, use ON_GetBoundingBox</param>
            <returns>0 = no, 1 = yes, 2 = points are coincident and on line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ArePointsOnLine(RMA.OpenNURBS.IArrayOn2dPoint,RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnLine,System.Double)">
            <param name="bbox">if needed, use ON_GetBoundingBox</param>
            <returns>0 = no, 1 = yes, 2 = points are coincident and on line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnArc,System.Double@,RMA.OpenNURBS.On3dPoint@,System.Double@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Intersect a infinte line and arc.</summary>
            <param name="line">[in]</param>
            <param name="arc">[in]</param>
            <param name="line_t0">[out] line parameter of first intersection point</param>
            <param name="arc_point0">[out] first intersection point on arc</param>
            <param name="line_t1">[out] line parameter of second intersection point</param>
            <param name="arc_point1">[out] second intersection point on arc</param>
            <returns>
0 No intersection
1 One intersection at line.PointAt(*line_t0)
2 Two intersections at line.PointAt(*line_t0) and line.PointAt(*line_t1).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnCircle,System.Double@,RMA.OpenNURBS.On3dPoint@,System.Double@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Intersect an infinte line and circle.</summary>
            <param name="line">[in]</param>
            <param name="circle">[in]</param>
            <param name="line_t0">[out] line parameter of first intersection point</param>
            <param name="circle_point0">[out] first intersection point on circle</param>
            <param name="line_t1">[out] line parameter of second intersection point</param>
            <param name="circle_point1">[out] second intersection point on circle</param>
            <returns>
0 No intersection
1 One intersection at line.PointAt(*line_t0)
2 Two intersections at line.PointAt(*line_t0) and line.PointAt(*line_t1).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsContinuous(RMA.OpenNURBS.IOn.continuity,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Test curve continuity from derivative values.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="Pa">[in] point on curve A.</param>
            <param name="D1a">[in] first derviative of curve A.</param>
            <param name="D2a">[in] second derviative of curve A.</param>
            <param name="Pb">[in] point on curve B.</param>
            <param name="D1b">[in] first derviative of curve B.</param>
            <param name="D1b">[in] second derviative of curve B.</param>
            <returns>
TRUE if the curve has at least the c type continuity at the parameter t.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsContinuous(RMA.OpenNURBS.IOn.continuity,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double)">
            <summary>Test curve continuity from derivative values.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="Pa">[in] point on curve A.</param>
            <param name="D1a">[in] first derviative of curve A.</param>
            <param name="D2a">[in] second derviative of curve A.</param>
            <param name="Pb">[in] point on curve B.</param>
            <param name="D1b">[in] first derviative of curve B.</param>
            <param name="D1b">[in] second derviative of curve B.</param>
            <param name="point_tolerance">[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.</param>
            <returns>
TRUE if the curve has at least the c type continuity at the parameter t.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsContinuous(RMA.OpenNURBS.IOn.continuity,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double)">
            <summary>Test curve continuity from derivative values.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="Pa">[in] point on curve A.</param>
            <param name="D1a">[in] first derviative of curve A.</param>
            <param name="D2a">[in] second derviative of curve A.</param>
            <param name="Pb">[in] point on curve B.</param>
            <param name="D1b">[in] first derviative of curve B.</param>
            <param name="D1b">[in] second derviative of curve B.</param>
            <param name="point_tolerance">[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.</param>
            <param name="d1_tolerance">[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.</param>
            <returns>
TRUE if the curve has at least the c type continuity at the parameter t.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsContinuous(RMA.OpenNURBS.IOn.continuity,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double,System.Double)">
            <summary>Test curve continuity from derivative values.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="Pa">[in] point on curve A.</param>
            <param name="D1a">[in] first derviative of curve A.</param>
            <param name="D2a">[in] second derviative of curve A.</param>
            <param name="Pb">[in] point on curve B.</param>
            <param name="D1b">[in] first derviative of curve B.</param>
            <param name="D1b">[in] second derviative of curve B.</param>
            <param name="point_tolerance">[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.</param>
            <param name="d1_tolerance">[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.</param>
            <param name="d2_tolerance">[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.</param>
            <returns>
TRUE if the curve has at least the c type continuity at the parameter t.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsContinuous(RMA.OpenNURBS.IOn.continuity,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test curve continuity from derivative values.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="Pa">[in] point on curve A.</param>
            <param name="D1a">[in] first derviative of curve A.</param>
            <param name="D2a">[in] second derviative of curve A.</param>
            <param name="Pb">[in] point on curve B.</param>
            <param name="D1b">[in] first derviative of curve B.</param>
            <param name="D1b">[in] second derviative of curve B.</param>
            <param name="point_tolerance">[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.</param>
            <param name="d1_tolerance">[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.</param>
            <param name="d2_tolerance">[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <returns>
TRUE if the curve has at least the c type continuity at the parameter t.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsContinuous(RMA.OpenNURBS.IOn.continuity,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test curve continuity from derivative values.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="Pa">[in] point on curve A.</param>
            <param name="D1a">[in] first derviative of curve A.</param>
            <param name="D2a">[in] second derviative of curve A.</param>
            <param name="Pb">[in] point on curve B.</param>
            <param name="D1b">[in] first derviative of curve B.</param>
            <param name="D1b">[in] second derviative of curve B.</param>
            <param name="point_tolerance">[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.</param>
            <param name="d1_tolerance">[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.</param>
            <param name="d2_tolerance">[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous.  If K0 and K1 are curvatures evaluated
from above and below and |K0 - K1| &gt; curvature_tolerance, then a curvature discontinuity is reported.
</param>
            <returns>
TRUE if the curve has at least the c type continuity at the parameter t.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvPrincipalCurvatures(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double@,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <param name="N">unit normal to surface (use ON_EvNormal())</param>
            <param name="gauss">[out] Gaussian curvature = kappa1*kappa2</param>
            <param name="mean">[out] mean curvature = (kappa1+kappa2)/2</param>
            <param name="kappa1">[out] largest principal curvature value (may be negative)</param>
            <param name="kappa2">[out] smallest principal curvature value (may be negative)</param>
            <param name="K1">[out] kappa1 unit principal curvature direction</param>
            <param name="K2">[out] kappa2 unit principal curvature direction</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvCurvature(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <returns>FALSE if first derivtive is zero</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvNormal(System.Int32,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dVector@)">
            <param name="limit_dir">0=default,1=from quadrant I, 2 = from quadrant II, ...</param>
            <param name="Du">first partial</param>
            <param name="Dv">first partial</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Pullback3dVector(RMA.OpenNURBS.IOn3dVector,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On2dVector@)">
            <summary>use to pull 3d vector back to surface parameter space</summary>
            <param name="dist" />
            <param name="ds">first surface partial</param>
            <param name="dt">first surface partial</param>
            <param name="dss">surface 2nd partials (used only when dist != 0)</param>
            <param name="dst">surface 2nd partials (used only when dist != 0)</param>
            <param name="dtt">surface 2nd partials (used only when dist != 0)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvNormalPartials(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate partial derivatives of surface unit normal</summary>
            <param name="ds">[in] surface first partial derivative</param>
            <param name="dt">[in] surface first partial derivative</param>
            <param name="dss">[in] surface second partial derivative</param>
            <param name="dst">[in] surface second partial derivative</param>
            <param name="dtt">[in] surface second partial derivative</param>
            <param name="ns">
[out] First partial derivatives of surface unit normal
(If the Jacobian is degenerate, ns and nt are set to zero.)
</param>
            <param name="nt">
[out] First partial derivatives of surface unit normal
(If the Jacobian is degenerate, ns and nt are set to zero.)
</param>
            <returns>
TRUE if Jacobian is nondegenerate
FALSE if Jacobian is degenerate
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_DecomposeVector(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double@,System.Double@)">
            <summary>Finds scalars x and y so that the component of V in the plane of A and B is x*A + y*B.</summary>
            <param name="V">[in]</param>
            <param name="A">[in] nonzero and not parallel to B</param>
            <param name="B">[in] nonzero and not parallel to A</param>
            <param name="x">[out]</param>
            <param name="y">[out]</param>
            <returns>
The rank of the problem.  
2 = A and B are nonzero and not parallel
1 = A and B are (nearly) parallel
0 = A and B are (nearly) zero
</returns>
            <seealso>ON_Solve2x2</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_SolveNxN(System.Boolean,System.Boolean,RMA.OpenNURBS.OnMatrix@,System.Double[]@,System.Double[]@)">
            <summary>
Use Gauss-Jordan elimination to find a numerical solution to M*X = B
where M is a n x n matrix, B is a known n-dimensional vector and X is
an unknown.
</summary>
            <param name="bFullPivot">
[in] if true, full pivoting is used, otherwise partial pivoting is used.
In rare cases full pivoting can produce a more accurate answer and never
produces a less accurate answer. However full pivoting is slower. If
speed is an issue, then experiement with bFullPivot=false
and see if it makes a difference.  Otherwise, set it to true.
</param>
            <param name="bNormalize">
[in] If bNormalize is true, then the rows of the matrix are scaled so
the sum of their squares is one.  This doesn't make the solution more
accurate but in some cases it makes the pivot ratio more meaningful.
Set bNormalize to false unless you have a reason for setting it to true.
</param>
            <param name="M">
[in] n x n matrix. The values in M are changed as the solution is calculated.
If you need to preserve M for future use, pass in a copy.
</param>
            <param name="B">
[in] n-dimensional vector. The values in B are changed as the solution
is calculated. If you need to preserve B for future use, pass in a copy.
</param>
            <param name="X">[out] solution to M*X = B.</param>
            <returns>
If the returned value is &lt;= 0.0, the input matrix has rank &lt; n
and no solution is returned in X. If the returned value is &gt; 0.0,
then a solution is returned in X and the returned value is the ratio
(minimum pivot)/(maximum pivot).  This value is called the pivot ratio
and will be denoted "pr" the discussion below.
If pr &lt;= 1e-15, then M was nearly degenerate and the solution should
be used with caution. If an accurate solution is critcial, then check
the solution anytime pr &lt;= 1e-10
In general, the difference between M*X and B will be reasonably small.
However, when the pr is small there tend to be vector E, substantually
different from zero, such that M*(X+E) - B is also reasonably small.
</returns>
            <seealso>
ON_Solve2x2
ON_Solve3x3
ON_Solve4x4
ON_Solve3x2
</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Solve4x4(System.Double[],System.Double[],System.Double[],System.Double[],System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
Use Gauss-Jordan elimination with full pivoting to solve 
a system of 4 linear equations and 4 unknowns(x,y,z,w)
 x*row0[0] + y*row0[1] + z*row0[2] + w*row0[3] = d0
 x*row1[0] + y*row1[1] + z*row1[2] + w*row1[3] = d1
 x*row2[0] + y*row2[1] + z*row2[2] + w*row2[3] = d2
 x*row3[0] + y*row3[1] + z*row3[2] + w*row3[2] = d3
</summary>
            <param name="row0">[in] first row of 4x4 matrix</param>
            <param name="row1">[in] second row of 4x4 matrix</param>
            <param name="row2">[in] third row of 4x4 matrix</param>
            <param name="row3">[in] forth row of 4x4 matrix</param>
            <param name="d0">[in] (d0,d1,d2,d3) right hand column of system</param>
            <param name="d1">[in] (d0,d1,d2,d3) right hand column of system</param>
            <param name="d2">[in] (d0,d1,d2,d3) right hand column of system</param>
            <param name="d3">[in] (d0,d1,d2,d3) right hand column of system</param>
            <param name="x">[out] first unknown</param>
            <param name="y">[out] second unknown</param>
            <param name="z">[out] third unknown</param>
            <param name="w">[out] forth unknown</param>
            <param name="pivot_ratio">
[out]If the pivot ratio is "small", then the matrix may be singular or ill 
conditioned. You should test the results before you use them. Small depends on the
precision of the input coefficients and the use of the solution. If you can't figure out
what small means in your case, then you must check the solution before you use it.
</param>
            <returns>
The rank of the 4x4 matrix (0,1,2,3, or 4)
If ON_Solve4x4() is successful (returns 4), then the solution is returned in (x, y, z, w)
and pivot_ratio = min(|pivots|)/max(|pivots|).
If the return code is &lt; 4, then, it a solution exists, on is returned.
However YOU MUST CHECK THE SOLUTION IF THE RETURN CODE IS &lt; 4.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Solve3x3(System.Double[],System.Double[],System.Double[],System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
Use Gauss-Jordan elimination with full pivoting to solve 
a system of 3 linear equations and 3 unknowns(x,y,z)
 x*row0[0] + y*row0[1] + z*row0[2] = d0
 x*row1[0] + y*row1[1] + z*row1[2] = d1
 x*row2[0] + y*row2[1] + z*row2[2] = d2
</summary>
            <param name="row0">[in] first row of 3x3 matrix</param>
            <param name="row1">[in] second row of 3x3 matrix</param>
            <param name="row2">[in] third row of 3x3 matrix</param>
            <param name="d0">[in] (d0,d1,d2) right hand column of system</param>
            <param name="d1">[in] (d0,d1,d2) right hand column of system</param>
            <param name="d2">[in] (d0,d1,d2) right hand column of system</param>
            <param name="x">[out] first unknown</param>
            <param name="y">[out] second unknown</param>
            <param name="z">[out] third unknown</param>
            <param name="pivot_ratio">
[out]If the pivot ratio is "small", then the matrix may be singular or ill 
conditioned. You should test the results before you use them. Small depends on the
precision of the input coefficients and the use of the solution. If you can't figure out
what small means in your case, then you must check the solution before you use it.
</param>
            <returns>
The rank of the 3x3 matrix (0,1,2, or 3)
If ON_Solve3x3() is successful (returns 3), then the solution is returned in (x, y, z)
and pivot_ratio = min(|pivots|)/max(|pivots|).
If the return code is &lt; 3, then (0,0,0) is returned as the "solution".
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Solve3x2(System.Double[],System.Double[],System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Solve a 3x2 system of linear equations</summary>
            <param name="column0">array of 3 doubles</param>
            <param name="column1">array of 3 doubles</param>
            <param name="d0">right hand column of system</param>
            <param name="d1">right hand column of system</param>
            <param name="d2">right hand column of system</param>
            <param name="x" />
            <param name="y" />
            <param name="error" />
            <param name="pivot_ratio" />
            <returns>
2: successful
0: failure - 3x2 matrix has rank 0
1: failure - 3x2 matrix has rank 1
If the return code is zero, then
(x)*{column0} + (y)*{column1} + (error)*({column0 X column1}/|column0 X column1|) = {d0,d1,d2}.
pivot_ratio = min(|pivots|)/max(|pivots|)  If this number
is small, then the 3x2 matrix may be singular or ill conditioned.
</returns>
            <remarks>
The system of 3 equations and 2 unknowns (x,y),
 x*column0[0] + y*column1[1] = d0
 x*column0[0] + y*column1[1] = d1
 x*column0[0] + y*column1[1] = d2,
is solved using Gauss-Jordan elimination with full pivoting.
</remarks>
            <example>
If A, B and T are 3D vectors, find a and b so that
T - a*A + b*B is perpindicular to both A and B.
rc = TL_Solve3x3(A,B,T[0],T[1],T[2], a, b, len);
switch(rc) {
case  0: ( {x,y,z} = intersection point, len = T o (A X B / |A X B|) )
 break;
case -1: (both A and B are zero!)
 break;
case -2: (A and B are parallel, or one of A and B is zero.)
 break;
}
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Solve2x2(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>Solve a 2x2 system of linear equations</summary>
            <param name="m00">first row, first column item in 2x2 matrix</param>
            <param name="m01">first row, second column item in 2x2 matrix</param>
            <param name="m10">second row, first column item in 2x2 matrix</param>
            <param name="m11">second row, second column item in 2x2 matrix</param>
            <param name="d0">coefficients for the 2x2 the linear system</param>
            <param name="d1">coefficients for the 2x2 the linear system</param>
            <param name="x">solution to linear system</param>
            <param name="y">solution to linear system</param>
            <returns>
ON_Solve2x2() returns rank (0,1,2)
If ON_Solve2x2() is successful (return code 2), then
the solution is returned in {x, y} and
pivot_ratio = min(|pivots|)/max(|pivots|).

WARNING: If the pivot ratio is small, then the matrix may be singular or
ill conditioned. You should test the results before you use them.
</returns>
            <remarks>
The system of 2 equations and 2 unknowns (x,y),
 m00*x + m01*y = d0
 m10*x + m11*y = d1,
is solved using Gauss-Jordan elimination with full pivoting.
</remarks>
            <example>
Find the intersection of 2 2D lines where
P0, P1  are points on the lines and D0, D1, are nonzero directions
rc = ON_Solve2x2(D0[0],-D1[0],D0[1],-D1[1],P1[0]-P0[0],P1[1]-P0[1], x, y, pivot_ratio);
switch(rc) {
case  0: (P0 + x*D0 = P1 + y*D1 = intersection point)
  if (pivot_ratio &lt; 0.001) {
    (small pivot ratio - test answer before using ...)
  }
  break;
case -1: (both directions are zero!)
  break;
case -2: (parallel directions)
  break;
}
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_SolveTriDiagonal(System.Int32,System.Int32,System.Double[],System.Double[],System.Double[]@,System.Double[],System.Double[]@)">
            <summary>Solve a tridiagonal linear system of equations using backsubstution</summary>
            <param name="dim">(&gt;=1) dimension of X and d</param>
            <param name="n">(&gt;=2) number of equations</param>
            <param name="a">coefficient of the linear system. a and c are arrays of n-1 doubles</param>
            <param name="b">coefficient of the linear system. b and d are arrays of n doubles.</param>
            <param name="c">coefficient of the linear system. a and c are arrays of n-1 doubles. Note: c is modified</param>
            <param name="d">coefficient of the linear system. b and d are arrays of n doubles.</param>
            <param name="X">array of n doubles</param>
            <returns>
0: success
-1: failure - illegal input
-2: failure - zero pivot encountered (can happen even when matrix is non-singular)

if ON_SolveTriDiagonal() returns 0, then X is the solution to
 b[0]   c[0]                                X[0]        d[0]
 a[0]   b[1]  c[1]                          X[1]        d[1]
        a[1]  b[2]  c[2]                  * X[2]     =  d[2]
              ....  ....  ....              ...         ...
                    a[n-3] b[n-2] c[n-2]    X[n-2]      d[n-2]
                           a[n-2] b[n-1]    X[n-1]      d[n-1]
</returns>
            <remarks>
If n &lt;= 3, this function uses ON_Solve2x2() or ON_Solve3x3().  
If n &gt; 3, the system is solved in the fastest possible manner; in particular,  no pivoting is performed, b[0] must be nonzero.
If |b[i]| &gt; |a[i-1]| + |c[i]|, then this function will succeed.
The computation is performed in such a way that the output X pointer can be equal to the input d pointer; i.e., if the
d array will not be used after the call to ON_SolveTriDiagonal(), then it is not necessary to allocate seperate space for X and d.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_SolveQuadraticEquation(System.Double,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>solve a*X^2 + b*X + c = 0</summary>
            <remarks>
The quadratic equation is solved using the formula
roots = q/a, c/q, q = 0.5*(b + sgn(b)*sqrt(b^2 - 4ac)).

When |b^2 - 4*a*c| &lt;= b*b*ON_EPSILON, the discriminant is numerical noise and is assumed to be zero.

If it is really important to have the best possible answer, you sould probably tune up
the returned roots using Brent's algorithm.
REFERENCE: Numerical Recipes in C, section 5.5
</remarks>
            <returns>
0: two distinct real roots (r0 &lt; r1)
1: one real root (r0 = r1)
2: two complex conjugate roots (r0 +/- (r1)*sqrt(-1))
-1: failure - a = 0, b != 0        (r0 = r1 = -c/b)
-2: failure - a = 0, b  = 0 c != 0 (r0 = r1 = 0.0)
-3: failure - a = 0, b  = 0 c  = 0 (r0 = r1 = 0.0)
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IsValid(System.Double)">
            <summary>Test a double to make sure it is a valid number.</summary>
            <returns>True if x != ON_UNSET_VALUE and _finite(x) is true.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_KnotCount(System.Int32,System.Int32)">
            <summary>Computes number of knots in knot vector</summary>
            <param name="order">(&gt;=2)</param>
            <param name="cv_count">(&gt;=order)</param>
            <returns>(order + cv_count - 2)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_DomainTolerance(System.Double,System.Double)">
            <summary>Computes tolerance associated with a generic evaluation domain</summary>
            <param name="start">start of domain</param>
            <param name="end">end of domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnSphere,RMA.OpenNURBS.IOnSphere,RMA.OpenNURBS.OnCircle@)">
            <summary>Intersect two spheres using exact calculations.</summary>
            <param name="sphere0">[in]</param>
            <param name="sphere1">[in]</param>
            <param name="circle">[out] If intersection is a point, then that point will be the center, radius 0.</param>
            <returns>
0 if no intersection,
1 if a single point,
2 if a circle,
3 if the spheres are the same.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnLine,System.Double,RMA.OpenNURBS.OnInterval@)">
            <summary>Intersect an infinite line and an axis aligned bounding box.</summary>
            <param name="bbox">[in]</param>
            <param name="line">[in]</param>
            <param name="tolerance">
[in] If tolerance &gt; 0.0, then the intersection is
performed against a box that has each side moved out by tolerance.
</param>
            <param name="line_parameters">
[out] The chord from line.PointAt(line_parameters[0]) to
line.PointAt(line_parameters[1]) is the intersection.
</param>
            <returns>True if the line intersects the box and false otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnCylinder,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
returns 0 = no intersections,
1 = one intersection, 
2 = 2 intersections
3 = line lies on cylinder
If 0 is returned, first point is point on line closest to cylinder and
     2nd point is the point on the sphere closest to the line.
If 1 is returned, first point is obtained by evaluating the line and the
     second point is obtained by evaluating the sphere.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnSphere,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
returns 0 = no intersections,
1 = one intersection, 
2 = 2 intersections
If 0 is returned, first point is point on line closest to sphere and
    2nd point is the point on the sphere closest to the line.
If 1 is returned, first point is obtained by evaluating the line and
    the second point is obtained by evaluating the sphere.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnSphere,RMA.OpenNURBS.OnCircle@)">
            <summary>
returns 0 = no intersections,
1 = intersection = single point, 
2 = intersection = circle
If 0 is returned, returned circle has radius=0 and center = point on sphere closest to plane.
If 1 is returned, intersection is a single point and returned circle has radius=0
                 and center = intersection point on sphere.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnPlane,System.Double@)">
            <summary>
Returns FALSE unless intersection is a single point
If returned parameter is &lt; 0 or &gt; 1, then the line
segment between line.m_point[0] and line.m_point[1]
does not intersect the plane
</summary>
            <param name="t">[out]parameter on line</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_Intersect(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnLine,System.Double@,System.Double@)">
            <summary>Find the closest point between two infinte lines.</summary>
            <param name="lineA">[in]</param>
            <param name="lineB">[in]</param>
            <param name="a">[out]</param>
            <param name="b">
[out] The shortest distance between the lines is the
chord from lineA.PointAt(*a) to lineB.PointAt(*b).
</param>
            <returns>
True if points are found and false if the lines are numerically parallel.
Numerically parallel means the 2x2 matrix
  AoA  -AoB
  -AoB   BoB
is numerically singluar, where A = lineA.to-lineA.from
and B = lineB.to-lineB.from.
See Also: ON_IntersectLineLine
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_IntersectLineLine(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.IOnLine,System.Double@,System.Double@,System.Double,System.Boolean)">
            <summary>Intersect two lines.</summary>
            <param name="lineA">[in]</param>
            <param name="lineB">[in]</param>
            <param name="a">[out]</param>
            <param name="b">
[out] The shortest distance between the lines is the
chord from lineA.PointAt(*a) to lineB.PointAt(*b).
</param>
            <param name="tolerance">
[in] If &gt; 0.0, then an intersection is reported only
if the distance between the points is &lt;= tolerance.
If &lt;= 0.0, then the closest point between the lines is reported.
</param>
            <param name="bIntersectSegments">
[in] if true, the input lines are treated as finite segments.
If false, the input lines are treated as infinite lines.
</param>
            <returns>
True if a closest point can be calculated and the result passes
the tolerance parameter test.
</returns>
            <remarks>
If the lines are exactly parallel, meaning the system of equations
used to find a and b has no numerical solution, then false is returned.
If the lines are nearly parallel, which is often numerically true
even if you think the lines look exactly parallel, then the
closest points are found and true is returned.  So, if you
care about weeding out "parallel" lines, then you need to
do something like the following.
bool rc = ON_IntersectLineLine(lineA,lineB,a,b,tolerance,bIntersectSegments);
if (rc)
{
 double angle_tolerance_radians = 0.5*ON_PI/180.0; // or whatever
 double parallel_tol = cos(angle_tolerance_radians);
 if ( fabs(lineA.Tangent()*lineB.Tangent()) &gt;= parallel_tol )
 {
 ... do whatever you think is appropriate
 }
}
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_DotProduct(RMA.OpenNURBS.IOn3fVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
true if X, Y are nonzero and mutually perpindicular
</summary>
            <summary>
true if X, Y are orthogonal and unit length
</summary>
            <summary>
true if X, Y are orthonormal and right handed
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ConvertNurbSpanToBezier(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Double[],System.Double,System.Double)">
            <param name="cvdim">(dim+1 for rational curves)</param>
            <param name="cvstride">(&gt;=cvdim)</param>
            <param name="cv">[in/out]input has NURBS cvs, output has Bezier cvs</param>
            <param name="knots">(2*order-2) knots for the NURBS span</param>
            <param name="t0">NURBS span parameter of start point</param>
            <param name="t1">NURBS span parameter of end point</param>
            <remarks>
If you want to convert the entire span to a Bezier, set t0 = knots[order-2] and t1 = knots[order-1].  
If you want to extend the left end of the span a bit, set t0 = knots[order-2] - a_bit and t1 = knots[order-1].
If you want to extend the right end of the span a bit, set t0 = knots[order-2] and t1 = knots[order-1] + a_bit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsBlossom(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Double[],System.Double[],System.Double[]@)">
            <summary>DeBoor algorithm with different input at each step.</summary>
            <param name="cvdim" />
            <param name="order" />
            <param name="cv_stride" />
            <param name="cv">size = cv_stride*order</param>
            <param name="knot">
nondecreasing, size 2*(order-1)
knot[order-2] != knot[order-1]
</param>
            <param name="t">input parameters size order-1</param>
            <param name="P" />
            <returns>false for bad input.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsDeBoor(System.Int32,System.Int32,System.Int32,System.Double[]@,System.Double[],System.Int32,System.Double,System.Double)">
            <summary>Evaluate a B-spline span using the de Boor algorithm</summary>
            <param name="cv_dim">&gt;=1 (dim+1 for rational cvs)</param>
            <param name="order">
(&gt;=2)  There is no restriction on order.  For order &gt;= 18,
the necessary workspace is dynamically allocated and deallocated.
(The function requires a workspace of 2*order-2 doubles.)
</param>
            <param name="cv_stride">(&gt;=cv_dim)</param>
            <param name="cv">
array of order*cv_dim doubles that specify the B-spline span's control vertices
values changed to result of applying De Boor's algorithm
</param>
            <param name="knots">array of 2*(order-1) doubles that specify the B-spline span's knot vector.</param>
            <param name="side">
-1  return left side of B-spline span in cv array
+1  return right side of B-spline span in cv array
-2  return left side of B-spline span in cv array
   Ignore values of knots[0,...,order-3] and assume left end of span has a fully multiple knot with value "mult_k".
+2  return right side of B-spline span in cv array
   Ignore values of knots[order,...,2*order-2] and assume right end of span has a fully multiple knot with value "mult_k".
WARNING: If side is != {-2,-1,+1,+2}, this function may crash or return garbage.
</param>
            <param name="mult_k">Used when side = -2 or +2.</param>
            <param name="t">
If side &lt; 0, then the cv's for the portion of the NURB span to the LEFT of t are computed.
If side &gt; 0, then the cv's for the portion the span to the RIGHT of t are computed.
The following table summarizes the restrictions on t:
value of side         condition t must satisfy
  -2                    mult_k &lt; t and mult_k &lt; knots[order-1]
  -1                    knots[order-2] &lt; t
  +1                    t &lt; knots[order-1]
  +2                    t &lt; mult_k and knots[order-2] &lt; mult_k
</param>
            <param name="cv">
If side &lt;= 0, the input cv's are replaced with the cv's for
the B-spline span trimmed/extended to [knots[order-2],t]  with
new knot vector {knots[0], ..., knots[order-2], t, ..., t}.
                                               \________/
                                                order-1 t's
In particular, {cv[(order-1)*cv_dim], ..., cv[order*cv_dim - 1]}
is the value of the B-spline at t.
If side &gt; 0, the input cv's are replaced with the cv's for
the B-spline span trimmed/extended to [t,knots[order-1]]  with
new knot vector {t, ..., t, knots[order-1], ..., knots[2*order-3]}.
                \________/
                order-1 t's
In particular, {cv[0], ..., cv[cv_dim-1]} is the value of the B-spline at t.

NOTE WELL: The input knot vector is NOT modified.  If you want to
use the returned control points with the input knot vector,
then it is your responsibility to set
knots[0] = ... = knots[order-2] = t (side &gt; 0)
or
knots[order-1] = ... = knots[2*order-2] = t (side &lt; 0).
See the comments concering +/- 2 values of the "side" argument.
In most cases, you can avoid resetting knots  by carefully choosing the
value of "side" and "mult_k".
</param>
            <remarks>
This function is the single most important NURB curve function in the
TL library.  It is used to evaluate, trim, split and extend NURB curves.
It is used to convert portions of NURB curves to Beziers and to create
fully multiple end knots.  The functions that perform the above tasks
simply call this function with appropriate values and take linear
combinations of the returned cv's to compute the desired result.

Rational cases are handled adding one to the dimension and applying the
quotient rule as needed.

Set a[i,j] = (t-knots[i+j-1])/(knots[i+j+order-2] - knots[i+j-1])
Set D[i,j] = {cv[j*cv_dim], ..., cv[(j+1)*cv_dim-1]}, if i = 0
     (1-a[i,j])*D[i-1,j-1] + a[i,j]*D[i-1,j], if 0 &lt; i &lt;= d = degree

The collection of D[i,j]'s is typically drawn in a triangular array:
D[0,0]
        D[1,1]
D[0,1]              D[2,2]
        D[1,2]             ...
D[0,2]
...                                  D[d,d]
D[0,d-1]            D[2,d]
        D[1,d]
D[0,d]

When side &lt;= 0, the input cv's are replaced with D[0,0], D[1,2], ..., D[d,d].

When side &gt; 0, the input cv's are replace with D[d,d], D[d-1,d], ..., D[0,d].
REFERENCE:
BOHM-01, Page 16.
LEE-01, Section 6.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsCageSpan(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Double[],System.Double[],System.Double[],System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double,System.Double,System.Double,System.Int32,System.Double[]@)">
            <summary>Evaluate a NURBS cage trispan.</summary>
            <param name="dim">[in] &gt;0</param>
            <param name="is_rat">[in] true of false</param>
            <param name="order0">[in] &gt;= 2</param>
            <param name="order1">[in] &gt;= 2</param>
            <param name="order2">[in] &gt;= 2</param>
            <param name="knot0">[in] NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]</param>
            <param name="knot1">[in] NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]</param>
            <param name="knot2">[in] NURBS knot vector with 2*(order2-1) knots, knot2[order2-2] != knot2[order2-1]</param>
            <param name="cv_stride0">[in]</param>
            <param name="cv_stride1">[in]</param>
            <param name="cv_stride2">[in]</param>
            <param name="cv">
[in] For 0 &lt;= i &lt; order0, 0 &lt;= j &lt; order1, and 0 &lt;= k &lt; order2,
the (i,j,k)-th control vertex is cv[n],...,cv[n+(is_rat?dim:dim+1)], 
where n = i*cv_stride0 + j*cv_stride1 *k*cv_stride2.  
If is_rat is true the cv is in homogeneous form.
</param>
            <param name="der_count">[in] (&gt;=0)</param>
            <param name="t0">[in] (r,s,t) is the evaluation parameter</param>
            <param name="t1">[in] (r,s,t) is the evaluation parameter</param>
            <param name="t2">[in] (r,s,t) is the evaluation parameter</param>
            <param name="v_stride">[in] (&gt;=dim)</param>
            <param name="v">
[out] An array of length v_stride*(der_count+1)*(der_count+2)*(der_count+3)/6.
The evaluation results are stored in this array.
  P = v[0],...,v[m_dim-1]
  Dr = v[v_stride],...
  Ds = v[2*v_stride],...
  Dt = v[3*v_stride],...
  Drr = v[4*v_stride],...
  Drs = v[5*v_stride],...
  Drt = v[6*v_stride],...
  Dss = v[7*v_stride],...
  Dst = v[8*v_stride],...
  Dtt = v[9*v_stride],...
In general, Dr^i Ds^j Dt^k is returned in v[n],...,v[n+dim-1], where
  d = (i+j+k)
  n = v_stride*( d*(d+1)*(d+2)/6 + (j+k)*(j+k+1)/2 + k) 
</param>
            <returns>True if succcessful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsSurfaceSpan(System.Int32,System.Boolean,System.Int32,System.Int32,System.Double[],System.Double[],System.Int32,System.Int32,System.Double[],System.Int32,System.Double,System.Double,System.Int32,System.Double[]@)">
            <summary>Evaluate a NURBS surface bispan.</summary>
            <param name="dim">[in] &gt;0</param>
            <param name="is_rat">[in] true of false</param>
            <param name="order0">[in] &gt;= 2</param>
            <param name="order1">[in] &gt;= 2</param>
            <param name="knot0">
[in] NURBS knot vector with 2*(order0-1) knots, knot0[order0-2] != knot0[order0-1]
</param>
            <param name="knot1">
[in] NURBS knot vector with 2*(order1-1) knots, knot1[order1-2] != knot1[order1-1]
</param>
            <param name="cv_stride0">[in]</param>
            <param name="cv_stride1">[in]</param>
            <param name="cv">
[in] For 0 &lt;= i &lt; order0 and  0 &lt;= j &lt; order1, the (i,j) control vertex is
cv[n],...,cv[n+(is_rat?dim:dim+1)], where n = i*cv_stride0 + j*cv_stride1.
If is_rat is true the cv is in homogeneous form.
</param>
            <param name="der_count">[in] (&gt;=0)</param>
            <param name="s">[in]</param>
            <param name="t">[in] (s,t) is the evaluation parameter</param>
            <param name="v_stride">[in] (&gt;=dim)</param>
            <param name="v">
[out] An array of length v_stride*(der_count+1)*(der_count+2)/2.
The evaluation results are stored in this array.
    P = v[0],...,v[m_dim-1]
    Ds = v[v_stride],...
    Dt = v[2*v_stride],...
    Dss = v[3*v_stride],...
    Dst = v[4*v_stride],...
    Dtt = v[5*v_stride],...
In general, Ds^i Dt^j is returned in v[n],...,v[n+m_dim-1], where
n = v_stride*( (i+j)*(i+j+1)/2 + j).
</param>
            <returns>True if succcessful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsSpan(System.Int32,System.Boolean,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Double,System.Int32,System.Double[]@)">
            <summary>Evaluate a NURBS curve span.</summary>
            <param name="dim">[in] dimension (&gt; 0).</param>
            <param name="is_rat">[in] true or false.</param>
            <param name="order">[in] order=degree+1 (order&gt;=2)</param>
            <param name="knot">
[in] NURBS knot vector.
NURBS knot vector with 2*(order-1) knots, knot[order-2] != knot[order-1]
</param>
            <param name="cv_stride">[in]</param>
            <param name="cv">
[in] For 0 &lt;= i &lt; order the i-th control vertex is cv[n],...,cv[n+(is_rat?dim:dim+1)], 
where n = i*cv_stride.  If is_rat is true the cv is in homogeneous form.
</param>
            <param name="der_count">[in] number of derivatives to evaluate (&gt;=0)</param>
            <param name="t">[in] evaluation parameter</param>
            <param name="v_stride">[in]</param>
            <param name="v">
[out] An array of length v_stride*(der_count+1). The evaluation 
results are returned in this array.
   P = v[0],...,v[m_dim-1]
   Dt = v[v_stride],...
   Dtt = v[2*v_stride],...
   ...

In general, Dt^i returned in v[n],...,v[n+m_dim-1], where n = v_stride*i.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsBasisDerivatives(System.Int32,System.Double[],System.Int32,System.Double[]@)">
            <summary>
If "N" were declared as double N[order][order], then
                                d
N[d-k][i] = k-th derivative of N (t)
                                i

where 0 &lt;= k &lt;= d and 0 &lt;= i &lt;= d.

In particular, 
N[0], ..., N[d] - values of degree d basis functions.
N[order], ..., N[order_d] - values of first derivative.

Actually, the above is true when knot[d-1] &lt;= t &lt; knot[d].  Otherwise, the
values returned are the values of the polynomials that agree with N_i^k on the
half open domain [ knot[d-1], knot[d] )

Ref: The NURBS Book
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateNurbsBasis(System.Int32,System.Double[],System.Double,System.Double[]@)">
            <summary>Evaluate B-spline basis functions</summary>
            <param name="order">&gt;= 1
d = degree = order - 1
</param>
            <param name="knot">
array of length 2*d.  
Generally, knot[0] &lt;= ... &lt;= knot[d-1] &lt; knot[d] &lt;= ... &lt;= knot[2*d-1].
</param>
            <param name="N">[out]array of length order*order</param>
            <returns>
If "N" were declared as double N[order][order], then
            k
N[d-k][i] = N (t) = value of i-th degree k basis function.
            i
where 0 &lt;= k &lt;= d and k &lt;= i &lt;= d.

In particular, N[0], ..., N[d] - values of degree d basis functions.
The "lower left" triangle is not initialized.

Actually, the above is true when knot[d-1] &lt;= t &lt; knot[d].  Otherwise, the
value returned is the value of the polynomial that agrees with N_i^k on the
half open domain [ knot[d-1], knot[d] )
</returns>
            <remarks>
If a degree d NURBS has n control points, then the TL knot vector has
length d+n-1. ( Most literature, including DeBoor and The NURBS Book,
duplicate the TL start and end knot and have knot vectors of length d+n+1. )

Assume C is a B-spline of degree d (order=d+1) with n control vertices
(n&gt;=d+1) and knot[] is its knot vector.  Then C(t) = Sum( 0 &lt;= i &lt; n, N_{i}(t) * C_{i} )
where N_{i} are the degree d b-spline basis functions and C_{i} are the control
vertices.  The knot[] array length d+n-1 and satisfies

knot[0] &lt;= ... &lt;= knot[d-1] &lt; knot[d]
knot[n-2] &lt; knot[n-1] &lt;= ... &lt;= knot[n+d-2]
knot[i] &lt; knot[d+i] for 0 &lt;= i &lt; n-1
knot[i] &lt;= knot[i+1] for 0 &lt;= i &lt; n+d-2

The domain of C is [ knot[d-1], knot[n-1] ].
The support of N_{i} is [ knot[i-1], knot[i+d] ).
If d-1 &lt;= k &lt; n-1 and knot[k] &lt;= t &lt; knot[k+1], then 
N_{i}(t) = 0 if i &lt;= k-d
    = 0 if i &gt;= k+2
    = B[i-k+d-1] if k-d+1 &lt;= i &lt;= k+1, where B[] is computed by the call
TL_EvNurbBasis( d+1, knot+k-d+1, t, B );

If 0 &lt;= j &lt; n-d, 0 &lt;= m &lt;= d, knot[j+d-1] &lt;= t &lt; knot[j+d], and B[] is 
computed by the call
TL_EvNurbBasis( d+1, knot+j, t, B ),
then 
N_{j+m}(t) = B[m].
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateBezier(System.Int32,System.Boolean,System.Int32,System.Int32,System.Double[],System.Double,System.Double,System.Int32,System.Double,System.Int32,System.Double[]@)">
            <summary>Evaluate a Bezier</summary>
            <param name="dim">(&gt;= 1) dimension of Bezier's range</param>
            <param name="is_rat">
false: bezier is not rational
true: bezier is rational
</param>
            <param name="order">(&gt;= 2) (order = degree+1)</param>
            <param name="cv">
array of (dim+is_rat)*order doubles that define the Bezier's control vertices.
</param>
            <param name="t0">
(t0 != t1)
Bezier's domain. Mathematically, Beziers have domain [0,1]. In practice Beziers are
frequently evaluated at (t-t0)/(t1-t0) and the chain rule is used to evaluate the derivatives.
This function is the most efficient place to apply the chain rule.
</param>
            <param name="t1">
(t0 != t1)
Bezier's domain. Mathematically, Beziers have domain [0,1]. In practice Beziers are
frequently evaluated at (t-t0)/(t1-t0) and the chain rule is used to evaluate the derivatives.
This function is the most efficient place to apply the chain rule.
</param>
            <param name="t">Evaluation parameter</param>
            <param name="der_count">(&gt;= 0)  number of derivatives to evaluate</param>
            <param name="v_stride">(&gt;=dimension)</param>
            <param name="v">[out] v[(der_count+1)*v_stride] array</param>
            <returns>
0: successful
-1: failure - rational function had nonzero numerator and zero denominator
</returns>
            <remarks>
Use de Casteljau's algorithm.  Rational fuctions with removable singularities
(like x^2/x) are efficiently and correctly handled.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluatedeCasteljau(System.Int32,System.Int32,System.Int32,System.Int32,System.Double[]@,System.Double)">
            <summary>Evaluate a Bezier using the de Casteljau algorithm</summary>
            <param name="dim">( &gt;= 1)</param>
            <param name="order">( &gt;= 2)</param>
            <param name="side">
&lt;= 0  return left side of bezier in cv array
&gt;  0  return right side of bezier in cv array
</param>
            <param name="cv">
[in/out] array of order*cv_stride doubles that specify the Bezier's control vertices.
If side &lt;= 0, the input cv's are replaced with the cv's for the bezier trimmed/extended
to [0,t]. In particular, {cv[(order-1)*cv_stride], ..., cv[order*cv_stride - 1]} is the value of the
Bezier at t.
If side &gt; 0, the input cv's are replaced with the cv's for the Bezier trimmed/extended
to [t,1]. In particular, {cv[0], ..., cv[dim-1]} is the value of the Bezier at t.
</param>
            <param name="cv_stride">( &gt;= dim) number of doubles between cv's (typically a multiple of dim).</param>
            <param name="t">
If side &lt;= 0, then t must be &gt; 0.0.
If side &gt;  0, then t must be &lt; 1.0.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_EvaluateBernsteinBasis(System.Int32,System.Int32,System.Double)">
            <summary>Evaluate Bernstein basis polynomial</summary>
            <param name="degree">If degree &lt; 0, then 0.0 is returned.</param>
            <param name="i">If i &lt; 0 or i &gt; degree, then 0.0 is returned.</param>
            <param name="t">The formula for the Bernstein polynomial is valid for all values of t.</param>
            <returns>(i choose d)*(1-t)^(d-i)*t^i</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_SortCurves(RMA.OpenNURBS.IOnCurve[],System.Int32[]@,System.Boolean[]@)">
            <summary>Sort a list of open curves so end of a curve matches the start of the next curve.</summary>
            <param name="curve_list">[in] array of curve pointers</param>
            <param name="index">
[out] The returned index[] is a permutation of {0,1,...,curve_count-1}
so that the list of curves is in end-to-end order.
</param>
            <param name="bReverse">
[out] If the returned value of bReverse[j] is true, then
curve_list[index[j]] needs to be reversed.
</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_SortLines(RMA.OpenNURBS.IArrayOnLine,System.Int32[]@,System.Boolean[]@)">
            <summary>Sort a list of lines so they are geometrically continuous.</summary>
            <param name="line_list">[in] array of lines</param>
            <param name="index">
[out] The returned index[] is a permutation of {0,1,...,line_count-1}
so that the list of lines is in end-to-end order.
</param>
            <param name="bReverse">
[out] If the returned value of bReverse[j] is true,
then line_list[index[j]] needs to be reversed.
</param>
            <returns>True if successful, false if not.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_JoinCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@,System.Double)">
            <summary>Join all contiguous curves of an array of ON_Curves.</summary>
            <param name="InCurves">[in] Array of curves to be joined (not modified)</param>
            <param name="OutCurves">
[out] Resulting joined curves and copies of curves that were not joined to anything are appended.
</param>
            <param name="join_tol">[in] Distance tolerance used to decide if endpoints are close enough</param>
            <returns>Number of curves added to Outcurves</returns>
            <remarks>
Closed curves are copied to OutCurves. 
Curves that cannot be joined to others are copied to OutCurves.  When curves are joined, the results
are ON_PolyCurves. All members of InCurves must have same dimension, at most 3.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_JoinCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@,System.Double,System.Boolean)">
            <summary>Join all contiguous curves of an array of ON_Curves.</summary>
            <param name="InCurves">[in] Array of curves to be joined (not modified)</param>
            <param name="OutCurves">
[out] Resulting joined curves and copies of curves that were not joined to anything are appended.
</param>
            <param name="join_tol">[in] Distance tolerance used to decide if endpoints are close enough</param>
            <param name="bPreserveDirection">
[in] If true, curve endpoints will be compared to curve startpoints.
If false, all start and endpoints will be compared, and copies of input 
curves may be reversed in output.
</param>
            <returns>Number of curves added to Outcurves</returns>
            <remarks>
Closed curves are copied to OutCurves. 
Curves that cannot be joined to others are copied to OutCurves.  When curves are joined, the results
are ON_PolyCurves. All members of InCurves must have same dimension, at most 3.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_JoinCurves(RMA.OpenNURBS.IOnCurve[],RMA.OpenNURBS.OnCurve[]@,System.Double,System.Boolean,System.Int32[]@)">
            <summary>Join all contiguous curves of an array of ON_Curves.</summary>
            <param name="InCurves">[in] Array of curves to be joined (not modified)</param>
            <param name="OutCurves">
[out] Resulting joined curves and copies of curves that were not joined to anything are appended.
</param>
            <param name="join_tol">[in] Distance tolerance used to decide if endpoints are close enough</param>
            <param name="bPreserveDirection">
[in] If true, curve endpoints will be compared to curve startpoints.
If false, all start and endpoints will be compared, and copies of input 
curves may be reversed in output.
</param>
            <param name="key">[out]InCurves[i] was joined into OutCurves[key[i]].</param>
            <returns>Number of curves added to Outcurves</returns>
            <remarks>
Closed curves are copied to OutCurves. 
Curves that cannot be joined to others are copied to OutCurves.  When curves are joined, the results
are ON_PolyCurves. All members of InCurves must have same dimension, at most 3.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_ForceMatchCurveEnds(RMA.OpenNURBS.OnCurve@,System.Int32,RMA.OpenNURBS.OnCurve@,System.Int32)">
            <summary>
Move ends of curves to a common point. Neither curve can be closed or an ON_CurveProxy.
If one is an arc or polycurve with arc at end to change, and the other is not, 
then the arc is left unchanged and the other curve is moved to the arc endpoint. 
Otherwise, both are moved to the midpoint of the segment between the ends.
</summary>
            <param name="Crv0">
[in] first curve to modify.
[out] with one endpoint possibly changed.
</param>
            <param name="end0">[in] if 0, change start of Crv0.  Otherwise change end.</param>
            <param name="Crv1">
[in] second curve to modify.
[out] with one endpoint possibly changed.
</param>
            <param name="end1">[in] if 0, change start of Crv1.  Otherwise change end.</param>
            <returns>true if the endpoints match. False otherwise</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_TrimCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Trim a curve.</summary>
            <param name="curve">[in] curve to trim (not modified)</param>
            <param name="trim_parameters">
[in] trimming parameters If curve is open, then trim_parameters must be an increasing interval.
If curve is closed, and trim_parameters ins a decreasing interval, then the portion of the
curve across the start/end is returned.
</param>
            <returns>trimmed curve or NULL if input is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepConeEdge(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Cone an edge in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="edge_index">[in] index of face to extrude.</param>
            <param name="apex_point">[in] apex of cone.</param>
            <returns>
0 failure
1 successful
</returns>
            <remarks>The new face is appended to brep.m_F[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepConeLoop(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Cone a loop in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="loop_index">[in] index of face to extrude.</param>
            <param name="apex_point">[in] apex of cone.</param>
            <returns>
0 failure
1 successful
</returns>
            <remarks>The new faces are appended to brep.m_F[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepConeFace(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Cone a face in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="face_index">[in] index of face to extrude.</param>
            <param name="apex_point">[in] apex of cone.</param>
            <returns>
0 failure
1 successful
</returns>
            <remarks>The new faces are appended to brep.m_F[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrudeVertex(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude a vertex in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="vertex_index">[in] index of vertex to extrude.</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <returns>
0 failure
1 successful
</returns>
            <remarks>The new vertex is appended to brep.m_V[] and the new edge is appended to brep.m_E[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrudeEdge(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude an edge in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="edge_index">[in] index of face to extrude.</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <returns>
0 failure
1 successful
</returns>
            <remarks>The new face is appended to brep.m_F[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrudeLoop(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude a loop in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="loop_index">[in] index of face to extrude.</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <returns>
0 failure
1 successful - no cap added
2 successful - cap added as last face
</returns>
            <remarks>
The new faces are appended to brep.m_F[].  If a cap is requested
it is the last face in the returned brep.m_F[]
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrudeLoop(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOnCurve,System.Boolean)">
            <summary>Extrude a loop in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="loop_index">[in] index of face to extrude.</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <param name="bCap">[in] if true and the loop is closed, the extusion is capped.</param>
            <returns>
0 failure
1 successful - no cap added
2 successful - cap added as last face
</returns>
            <remarks>
The new faces are appended to brep.m_F[].  If a cap is requested
it is the last face in the returned brep.m_F[]
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrudeFace(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude a face in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="face_index">[in] index of face to extrude.</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <example>
Extrude a face along a vector.
ON_Brep brep = ...;
int face_index = ...;
ON_3dVector v = ...;
ON_LineCurve line_curve( ON_Line( ON_origin, vector ) );
ON_BrepExtrudeFace( brep, face_index, line_curve, true );
</example>
            <returns>
0 failure
1 successful - no cap added
2 successful - cap added as last face
</returns>
            <remarks>
The new faces are appended to brep.m_F[].
If a cap is requested it is the last face in the returned brep.m_F[]
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrudeFace(RMA.OpenNURBS.OnBrep@,System.Int32,RMA.OpenNURBS.IOnCurve,System.Boolean)">
            <summary>Extrude a face in a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="face_index">[in] index of face to extrude.</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <param name="bCap">[in] if true, the extusion is capped with a translation of the face being extruded.</param>
            <example>
Extrude a face along a vector.
ON_Brep brep = ...;
int face_index = ...;
ON_3dVector v = ...;
ON_LineCurve line_curve( ON_Line( ON_origin, vector ) );
ON_BrepExtrudeFace( brep, face_index, line_curve, true );
</example>
            <returns>
0 failure
1 successful - no cap added
2 successful - cap added as last face
</returns>
            <remarks>
The new faces are appended to brep.m_F[].
If a cap is requested it is the last face in the returned brep.m_F[]
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrude(RMA.OpenNURBS.OnBrep@,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <returns>
True if successful.
</returns>
            <remarks>
The new faces are appended to brep.m_F[]. It is the caller's
responsibility to insure the result does not self intersect.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepExtrude(RMA.OpenNURBS.OnBrep@,RMA.OpenNURBS.IOnCurve,System.Boolean)">
            <summary>Extrude a brep.</summary>
            <param name="brep">[in/out]</param>
            <param name="path_curve">[in] path to extrude along.</param>
            <param name="bCap">[in]if true, the extusion is capped with a translation of the input brep.</param>
            <returns>
True if successful.
</returns>
            <remarks>
The new faces are appended to brep.m_F[]. It is the caller's
responsibility to insure the result does not self intersect.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTrimmedPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnCurve[])">
            <summary>Get an ON_Brep definition of a trimmed plane.</summary>
            <param name="plane">[in] plane that will be trimmed.</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections)
closed curve that defines the outer boundary of the trimmed plane.
</param>
            <returns>
An ON_Brep representation of the trimmed plane with a singe face.
See Also: ON_Brep::NewPlanarFaceLoop()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTrimmedPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnCurve[],System.Boolean)">
            <summary>Get an ON_Brep definition of a trimmed plane.</summary>
            <param name="plane">[in] plane that will be trimmed.</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections)
closed curve that defines the outer boundary of the trimmed plane.
</param>
            <param name="bDuplicateCurves">
[in] if true, duplicates of the curves in the boundary array are used in the brep.
If false the curves in the boundary array are used in the brep and the brep's
destructor will delete the curves.
</param>
            <returns>
An ON_Brep representation of the trimmed plane with a singe face.
See Also: ON_Brep::NewPlanarFaceLoop()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTrimmedPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnCurve[],System.Boolean,RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a trimmed plane.</summary>
            <param name="plane">[in] plane that will be trimmed.</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections)
closed curve that defines the outer boundary of the trimmed plane.
</param>
            <param name="bDuplicateCurves">
[in] if true, duplicates of the curves in the boundary array are used in the brep.
If false the curves in the boundary array are used in the brep and the brep's
destructor will delete the curves.
</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>
An ON_Brep representation of the trimmed plane with a singe face.
See Also: ON_Brep::NewPlanarFaceLoop()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTrimmedPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnCurve)">
            <summary>Create an ON_Brep trimmed plane.</summary>
            <param name="plane">[in] plane that will be trimmed.</param>
            <param name="boundary">
[in] a simple (no self intersections) closed curve that defines the outer
boundary of the trimmed plane. This curve is copied for use in the brep.
</param>
            <returns>
An ON_Brep representation of the trimmed plane with a single face.
See Also: ON_Brep::NewPlanarFaceLoop()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTrimmedPlane(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.OnBrep)">
            <summary>Create an ON_Brep trimmed plane.</summary>
            <param name="plane">[in] plane that will be trimmed.</param>
            <param name="boundary">
[in] a simple (no self intersections) closed curve that defines the outer
boundary of the trimmed plane. This curve is copied for use in the brep.
</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>
An ON_Brep representation of the trimmed plane with a single face.
See Also: ON_Brep::NewPlanarFaceLoop()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepRevSurface(RMA.OpenNURBS.OnRevSurface@,System.Boolean,System.Boolean)">
            <summary>Get an ON_Brep form of a surface of revolution.</summary>
            <param name="pRevSurface">
[in] pointer to a surface of revolution. The brep will manage this pointer and delete it in ~ON_Brep.
</param>
            <param name="bCapStart">
[in] if true, the start of the revolute is not on the axis of revolution,
and the surface of revolution is closed, then a circular cap will be added
to close of the hole at the start of the revolute.
</param>
            <param name="bCapEnd">
[in] if true, the end of the revolute is not on the axis of revolution, and
the surface of revolution is closed, then a circular cap will be added to
close of the hole at the end of the revolute.
</param>
            <returns>
true successful
false brep cannot be created from this surface.
</returns>
            <remarks>
The surface class must be created with new because it will be destroyed with the delete operator in ~ON_Brep.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepRevSurface(RMA.OpenNURBS.OnRevSurface@,System.Boolean,System.Boolean,RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep form of a surface of revolution.</summary>
            <param name="pRevSurface">
[in] pointer to a surface of revolution. The brep will manage this pointer and delete it in ~ON_Brep.
</param>
            <param name="bCapStart">
[in] if true, the start of the revolute is not on the axis of revolution,
and the surface of revolution is closed, then a circular cap will be added
to close of the hole at the start of the revolute.
</param>
            <param name="bCapEnd">
[in] if true, the end of the revolute is not on the axis of revolution, and
the surface of revolution is closed, then a circular cap will be added to
close of the hole at the end of the revolute.
</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>
true successful
false brep cannot be created from this surface.
</returns>
            <remarks>
The surface class must be created with new because it will be destroyed with the delete operator in ~ON_Brep.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepCone(RMA.OpenNURBS.IOnCone,System.Boolean)">
            <summary>Get an ON_Brep definition of a cone.</summary>
            <param name="cone">[in]</param>
            <param name="bCapBottom">[in] if true the base of the cone should be capped.</param>
            <returns>
An ON_Brep representation of the cone with a single face for the cone, an edge along
the cone seam, and vertices at the base and apex ends of this seam edge. The optional
cap is asingle face with one circular edge starting and ending at the base vertex.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepCone(RMA.OpenNURBS.IOnCone,System.Boolean,RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a cone.</summary>
            <param name="cone">[in]</param>
            <param name="bCapBottom">[in] if true the base of the cone should be capped.</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>
An ON_Brep representation of the cone with a single face for the cone, an edge along
the cone seam, and vertices at the base and apex ends of this seam edge. The optional
cap is asingle face with one circular edge starting and ending at the base vertex.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepCylinder(RMA.OpenNURBS.IOnCylinder,System.Boolean,System.Boolean)">
            <summary>Get an ON_Brep definition of a cylinder.</summary>
            <param name="cylinder">[in] cylinder.IsFinite() must be true</param>
            <param name="bCapBottom">[in] if true end at cylinder.m_height[0] should be capped</param>
            <param name="bCapTop">[in] if true end at cylinder.m_height[1] should be capped</param>
            <returns>
An ON_Brep representation of the cylinder with a single face for the cylinder,
an edge along the cylinder seam, and vertices at the bottom and top ends of this
seam edge. The optional bottom/top caps are single faces with one circular edge
starting and ending at the bottom/top vertex.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepCylinder(RMA.OpenNURBS.IOnCylinder,System.Boolean,System.Boolean,RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a cylinder.</summary>
            <param name="cylinder">[in] cylinder.IsFinite() must be true</param>
            <param name="bCapBottom">[in] if true end at cylinder.m_height[0] should be capped</param>
            <param name="bCapTop">[in] if true end at cylinder.m_height[1] should be capped</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>
An ON_Brep representation of the cylinder with a single face for the cylinder,
an edge along the cylinder seam, and vertices at the bottom and top ends of this
seam edge. The optional bottom/top caps are single faces with one circular edge
starting and ending at the bottom/top vertex.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTorus(RMA.OpenNURBS.IOnTorus)">
            <summary>Get an ON_Brep definition of a torus.</summary>
            <param name="torus">[in]</param>
            <returns>An ON_Brep representation of the torus with a single face a two edges along the seams.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepTorus(RMA.OpenNURBS.IOnTorus,RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a torus.</summary>
            <param name="torus">[in]</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>An ON_Brep representation of the torus with a single face a two edges along the seams.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepSphere(RMA.OpenNURBS.IOnSphere)">
            <summary>Get an ON_Brep definition of a sphere.</summary>
            <param name="sphere">[in]</param>
            <returns>
An ON_Brep representation of the sphere with a single face, a single edge along
the seam, and vertices at the north and south poles.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepSphere(RMA.OpenNURBS.IOnSphere,RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a sphere.</summary>
            <param name="sphere">[in]</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
            <returns>
An ON_Brep representation of the sphere with a single face, a single edge along
the seam, and vertices at the north and south poles.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepWedge(RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Get an ON_Brep definition of a wedge.</summary>
            <param name="corners">
[in] 6 points defining the box corners arranged as the vN lables indicate.

                    /v5    
                   /|\       
                  / | \     
                 e5 |  e4   
                /   e8  \     
               /__e3_____\  
             v3|    |    |v4     
               |    |    |       
               |    /v2  |   
               e6  / \   e7   
               |  /   \  |   
               | e2    e1|   
               |/       \|     
               /____e0___\  
             v0           v1
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepWedge(RMA.OpenNURBS.IOn3dPoint[],RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a wedge.</summary>
            <param name="corners">
[in] 6 points defining the box corners arranged as the vN lables indicate.

                    /v5    
                   /|\       
                  / | \     
                 e5 |  e4   
                /   e8  \     
               /__e3_____\  
             v3|    |    |v4     
               |    |    |       
               |    /v2  |   
               e6  / \   e7   
               |  /   \  |   
               | e2    e1|   
               |/       \|     
               /____e0___\  
             v0           v1
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepBox(RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Get an ON_Brep definition of a box.</summary>
            <param name="box_corners">
[in] 8 points defining the box corners arranged as the vN lables indicate.

         v7_______e6_____v6
          |\             |
          | e7           | e5
          |  \ ______e4_____\ 
         e11  v4         |   v5
          |   |        e10   |
          |   |          |   |
         v3---|---e2----v2   e9
          \   e8         \   |
           e3 |           e1 |
            \ |            \ |
             \v0_____e0_____\v1
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepBox(RMA.OpenNURBS.IOn3dPoint[],RMA.OpenNURBS.OnBrep)">
            <summary>Get an ON_Brep definition of a box.</summary>
            <param name="box_corners">
[in] 8 points defining the box corners arranged as the vN lables indicate.

         v7_______e6_____v6
          |\             |
          | e7           | e5
          |  \ ______e4_____\ 
         e11  v4         |   v5
          |   |        e10   |
          |   |          |   |
         v3---|---e2----v2   e9
          \   e8         \   |
           e3 |           e1 |
            \ |            \ |
             \v0_____e0_____\v1
</param>
            <param name="pBrep">[in] if not NULL, this brep will be used and returned.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepFromMesh(RMA.OpenNURBS.IOnMeshTopology)">
            <summary>Create a brep representation of a mesh.</summary>
            <param name="mesh_topology">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepFromMesh(RMA.OpenNURBS.IOnMeshTopology,System.Boolean)">
            <summary>Create a brep representation of a mesh.</summary>
            <param name="mesh_topology">[in]</param>
            <param name="bTrimmedTriangles">
[in] if true, triangles in the mesh  will be represented by trimmed planes in the brep.
If false, triangles in the mesh will be represented by untrimmed singular bilinear NURBS surfaces in the brep.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_BrepFromMesh(RMA.OpenNURBS.IOnMeshTopology,System.Boolean,RMA.OpenNURBS.OnBrep)">
            <summary>Create a brep representation of a mesh.</summary>
            <param name="mesh_topology">[in]</param>
            <param name="bTrimmedTriangles">
[in] if true, triangles in the mesh  will be represented by trimmed planes in the brep.
If false, triangles in the mesh will be represented by untrimmed singular bilinear NURBS surfaces in the brep.
</param>
            <param name="pBrep">[in] If not NULL, this the mesh representation will be put into this brep.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_WriteOneObjectArchive(RMA.OpenNURBS.OnBinaryArchive@,System.Int32,RMA.OpenNURBS.IOnObject)">
            <summary>
Used int ON_3dmProperties::Read() to set ON_BinaryArchive.m_3dm_opennurbs_version
Do not call directly.
</summary>
            <summary>Create a simple archive that contains a single geometric object.</summary>
            <param name="archive">[in] destination archive.</param>
            <param name="version">
[in] (2 to 5) format version.archive version number.
Version 2 format can be read by Rhino 2 and Rhino 3.
Version 3 format can be read by Rhino 3.
</param>
            <param name="object">
[in] object to be saved in the archive's object table.
This is typically some type of ON_Curve, ON_Surface, ON_Mesh, or ON_Brep.
</param>
            <returns>
true archive successfully written.
false archive not successfully written.
</returns>
            <example>
const char* filename = "myfile.3dm"
FILE* fp = ON::OpenFile( filename, "wb" );
ON_BinaryFile file( fp, ON::write3dm ); 
BOOL ok = ON_WriteArchive( archive, geometry );
ON::CloseFile( fp );
</example>
            <remarks>The object table in the archive will contain a single object.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_DebugWritePoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
ON_DebugWrite3dPoint is a debugging utility that can be called
from a debugger's evaluate expression window to dump points 
for future inspection.
</summary>
            <param name="p3dPoint">[in]</param>
            <returns>
If successful, and integer &gt;= N which indicates the object
was saved in a file named /debug_file_0000N.3dm.
See Also: ON_DebugWriteObject
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ON_DebugWriteObject(RMA.OpenNURBS.IOnObject)">
            <summary>
ON_DebugWriteObject is a debugging utility that can be called
from a debugger's evaluate expression window to dump objects 
for future inspection.
</summary>
            <param name="pObject">[in]</param>
            <returns>
If successful, and integer &gt;= N which indicates the object
was saved in a file named /debug_file_0000N.3dm.
See Also: ON_DebugWritePoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.OSnapMode(System.Int32)">
            <summary>
convert integer to osnap_mode enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.MeshType(System.Int32)">
            <summary>
convert integer to mesh_type enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ObjectDecoration(System.Int32)">
            <summary>
convert integer to line_pattern enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.BitmapType(System.Int32)">
            <summary>
convert integer to bitmap_type enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ObjectType(System.Int32)">
            <summary>
convert integer to object_type enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ViewType(System.Int32)">
            <summary>
convert integer to display_mode enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.DisplayMode(System.Int32)">
            <summary>
convert integer to display_mode enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.CurvatureStyle(System.Int32)">
            <summary>
convert integer to curvature_style enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.LightStyle(System.Int32)">
            <summary>
convert integer to light_style enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ObjectMaterialSource(System.Int32)">
            <summary>
convert integer to object_color_source enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ObjectLinetypeSource(System.Int32)">
            <summary>
convert integer to object_linetype_source enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.PlotWeightSource(System.Int32)">
            <summary>
convert integer to plot_color_source enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.PlotColorSource(System.Int32)">
            <summary>
convert integer to plot_color_source enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ObjectColorSource(System.Int32)">
            <summary>
convert integer to object_color_source enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ObjectMode(System.Int32)">
            <summary>
convert integer to object_mode enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ExceptionType(System.Int32)">
            <summary>
convert integer to exception_type enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.CoordinateSystem(System.Int32)">
            <summary>
convert integer to coordinate_system enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ViewProjection(System.Int32)">
            <summary>
convert integer to view_projection enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ArchiveMode(System.Int32)">
            <summary>
convert integer to endian enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.Endian">
            <summary>
returns endian-ness of current CPU
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.Endian(System.Int32)">
            <summary>
convert integer to endian enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.SortAlgorithm(System.Int32)">
            <summary>
convert integer to sort_method enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.SurfaceStyle(System.Int32)">
            <summary>
convert integer to surface_style enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.CurveStyle(System.Int32)">
            <summary>
convert integer to curve_style enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ParametricContinuity(System.Int32)">
            <summary>
Convert int to ON::continuity enum value and convert the locus flavored values to the parametric flavored values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.Continuity(System.Int32)">
            <summary>
Convert int to ON::continuity enum value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.KnotStyle(System.Int32)">
            <summary>
convert integer to knot_style enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.PointStyle(System.Int32)">
            <summary>
convert integer to point_style enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.DistanceDisplayMode(System.Int32)">
            <summary>
convert integer to distance_display_mode enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.UnitScale(RMA.OpenNURBS.IOn3dmUnitsAndTolerances,RMA.OpenNURBS.IOn3dmUnitsAndTolerances)">
            <summary>Scale factor for changing unit "standard" systems.</summary>
            <param name="us_from">[in]</param>
            <param name="us_to">[in]</param>
            <remarks>
For example:
100.0 = ON::UnitScale( ON::meters, ON::centimeters ) 
2.54 = ON::UnitScale( ON::inches, ON::centimeters ) 
12.0 = ON::UnitScale( ON::feet, ON::inches ) 
If you are using custom unit systems, use the version that takes On_UnitSystem
or On_3dmUnitsAndTolerances parameters.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.UnitScale(RMA.OpenNURBS.IOnUnitSystem,RMA.OpenNURBS.IOn.unit_system)">
            <summary>Scale factor for changing unit "standard" systems.</summary>
            <param name="us_from">[in]</param>
            <param name="us_to">[in]</param>
            <remarks>
For example:
100.0 = ON::UnitScale( ON::meters, ON::centimeters ) 
2.54 = ON::UnitScale( ON::inches, ON::centimeters ) 
12.0 = ON::UnitScale( ON::feet, ON::inches ) 
If you are using custom unit systems, use the version that takes On_UnitSystem
or On_3dmUnitsAndTolerances parameters.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.UnitScale(RMA.OpenNURBS.IOn.unit_system,RMA.OpenNURBS.IOnUnitSystem)">
            <summary>Scale factor for changing unit "standard" systems.</summary>
            <param name="us_from">[in]</param>
            <param name="us_to">[in]</param>
            <remarks>
For example:
100.0 = ON::UnitScale( ON::meters, ON::centimeters ) 
2.54 = ON::UnitScale( ON::inches, ON::centimeters ) 
12.0 = ON::UnitScale( ON::feet, ON::inches ) 
If you are using custom unit systems, use the version that takes On_UnitSystem
or On_3dmUnitsAndTolerances parameters.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.UnitScale(RMA.OpenNURBS.IOnUnitSystem,RMA.OpenNURBS.IOnUnitSystem)">
            <summary>Scale factor for changing unit "standard" systems.</summary>
            <param name="us_from">[in]</param>
            <param name="us_to">[in]</param>
            <remarks>
For example:
100.0 = ON::UnitScale( ON::meters, ON::centimeters ) 
2.54 = ON::UnitScale( ON::inches, ON::centimeters ) 
12.0 = ON::UnitScale( ON::feet, ON::inches ) 
If you are using custom unit systems, use the version that takes On_UnitSystem
or On_3dmUnitsAndTolerances parameters.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.UnitScale(RMA.OpenNURBS.IOn.unit_system,RMA.OpenNURBS.IOn.unit_system)">
            <summary>Scale factor for changing unit "standard" systems.</summary>
            <param name="us_from">[in]</param>
            <param name="us_to">[in]</param>
            <remarks>
For example:
100.0 = ON::UnitScale( ON::meters, ON::centimeters ) 
2.54 = ON::UnitScale( ON::inches, ON::centimeters ) 
12.0 = ON::UnitScale( ON::feet, ON::inches ) 
If you are using custom unit systems, use the version that takes On_UnitSystem
or On_3dmUnitsAndTolerances parameters.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.UnitSystem(System.Int32)">
            <summary>
convert integer to unit_system enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.ActiveSpace(System.Int32)">
            <summary>
convert integer to active_space enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.AnnotationType(System.Int32)">
            <summary>
convert integer to eAnnotationType enum
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.CloseAllFiles">
            <summary>
like _fcloseall() - needed when OpenNURBS is used as a DLL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.CloseFile(RMA.OpenNURBS.OnFileHandle)">
            <summary>like fclose() - needed when OpenNURBS is used as a DLL</summary>
            <param name="file">pointer returned by OpenFile()</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.OpenFile(System.String,System.String)">
            <summary>
like fopen() - needed when OpenNURBS is used as a DLL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.Version">
            <summary>Version of opennurbs (YYYYMMDDn)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.End">
            <summary>Call when finished with openNURBS.</summary>
            <remarks>Currently does nothing.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnUtil.Begin">
            <summary>
Call before using openNURBS to ensure all class definitions are linked.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_zaxis">
            <summary>(0.0, 0.0, 1.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_yaxis">
            <summary>(0.0, 1.0, 0.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_xaxis">
            <summary>(1.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_origin">
            <summary>(0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_UNSET_VECTOR">
            <summary>(On_UNSET_VALUE,On_UNSET_VALUE,On_UNSET_VALUE)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_UNSET_POINT">
            <summary>(On_UNSET_VALUE,On_UNSET_VALUE,On_UNSET_VALUE)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_fzaxis">
            <summary>
(0.0, 0.0, 1.0)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_fyaxis">
            <summary>(0.0, 1.0, 0.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_fxaxis">
            <summary>(1.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_forigin">
            <summary>(0.0, 0.0, 0.0)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_DEFAULT_ANGLE_TOLERANCE">
            <summary>default value for angle tolerances = 1 degree</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_ZERO_TOLERANCE">
            <summary>
In rare cases when an absolute "zero" tolerance is
required, ON_ZERO_TOLERANCE is used to compare
numbers.  This number should be no smaller than
ON_EPSILON and should be several orders of 
magnitude smaller than ON_SQRT_EPSILON
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_UNSET_COLOR">
            <summary>
In cases where lazy evaluation of a color value is
performed, this value is used to indicate the value 
has not been computed.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_UNSET_FLOAT">
            <summary>
This value is primarily used to indicate a texture coordinate
cannot be calculated or is not well defined.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_UNSET_VALUE">
            <summary>
In cases where lazy evaluation of a double value is
performed, b-rep tolerances being a notable example,
this value is used to indicate the value has not been
computed.  This value must be &lt; -1.0e308. and &gt; -ON_DBL_MAX
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_opennurbs_id">
            <summary>
Application id for the versions of openNURBS that write userdata in 3dm files. User data whose class
definition is in opennurbs should use these ids as the user data application id. In situations where
you want to use the id for the current version of opennurbs, use ON_opennurbs_id and you won't have
to update your code when opennurbs versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_opennurbs5_id">
            <summary>
Application id for the versions of openNURBS that write userdata in 3dm files. User data whose class
definition is in opennurbs should use these ids as the user data application id. In situations where
you want to use the id for the current version of opennurbs, use ON_opennurbs_id and you won't have
to update your code when opennurbs versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_opennurbs4_id">
            <summary>
Application id for the versions of openNURBS that write userdata in 3dm files. User data whose class
definition is in opennurbs should use these ids as the user data application id. In situations where
you want to use the id for the current version of opennurbs, use ON_opennurbs_id and you won't have
to update your code when opennurbs versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_rhino_id">
            <summary>
Application ids for the versions of Rhino that write 3dm files. All userdata classes defined
in the core Rhino.exe should use these ids as the application id. In situations where you want
to use the id for the current version of Rhino, use On_rhino_id and you won't have to update
your code when Rhino versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_rhino5_id">
            <summary>
Application ids for the versions of Rhino that write 3dm files. All userdata classes defined
in the core Rhino.exe should use these ids as the application id. In situations where you want
to use the id for the current version of Rhino, use On_rhino_id and you won't have to update
your code when Rhino versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_rhino4_id">
            <summary>
Application ids for the versions of Rhino that write 3dm files. All userdata classes defined
in the core Rhino.exe should use these ids as the application id. In situations where you want
to use the id for the current version of Rhino, use On_rhino_id and you won't have to update
your code when Rhino versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_rhino3_id">
            <summary>
Application ids for the versions of Rhino that write 3dm files. All userdata classes defined
in the core Rhino.exe should use these ids as the application id. In situations where you want
to use the id for the current version of Rhino, use On_rhino_id and you won't have to update
your code when Rhino versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUtil.On_rhino2_id">
            <summary>
Application ids for the versions of Rhino that write 3dm files. All userdata classes defined
in the core Rhino.exe should use these ids as the application id. In situations where you want
to use the id for the current version of Rhino, use On_rhino_id and you won't have to update
your code when Rhino versions roll.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBinaryArchiveDictionary.Name">
            <summary>Dictionary Name</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBinaryArchiveDictionary.Version">
            <summary>Custom dictionary version number</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchiveDictionary.EntryExists(System.String)">
            <summary>
Returns true if a certain key exists in this dictionary. Keys are case sensitive
Does not check to see if key exists in "child" dictionaries 
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBinaryArchiveDictionary.Keys">
            <summary>Entry names</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchiveDictionary.Write(RMA.OpenNURBS.OnBinaryArchive)">
            <summary>Write this dictionary to an archive</summary>
            <param name="archive">archive to write to</param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchiveDictionary.Read(RMA.OpenNURBS.OnBinaryArchive)">
            <summary>Read a dictionary from an archive.</summary>
            <param name="archive">
The archive to read from. The archive position should be at the beginning of
the dictionary
</param>
            <returns>new filled dictionary on success. null on failure</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchiveDictionary.#ctor(System.UInt32,System.String)">
            <summary>Create an instance of a dictionary for writing to a 3dm archive</summary>
            <param name="version">
custom version used to help the plug-in developer determine which version of
a dictionary is being written. One good way to write version information is to
use a date style integer (YYYYMMDD)
</param>
            <param name="name">
Optional name to associate with this dictionary.
NOTE: if this dictionary is set as a subdictionary, the name will be changed to
the subdictionary key entry
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchiveDictionary.#ctor(System.UInt32)">
            <summary>Create an instance of a dictionary for writing to a 3dm archive</summary>
            <param name="version">
custom version used to help the plug-in developer determine which version of
a dictionary is being written. One good way to write version information is to
use a date style integer (YYYYMMDD)
</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnBinaryArchiveDictionary">
            <summary>
Dictionary Structure
BEGINCHUNK (TCODE_ANONYMOUS_CHUNK)
|- version (int)
|- entry count (int)
   for entry count entries
   |- BEGINCHUNK (TCODE_ANONYMOUS_CHUNK)
   |- type (OnBinaryArchiveDictionary::ItemType)
   |- key (string)
   |- entry contents
   |- ENDCHUNK (TCODE_ANONYMOUS_CHUNK)
ENDCHUNK (TCODE_ANONYMOUS_CHUNK)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DestroyCache">
            <summary>
Destroys cached searching and bounding box information.
Call if you modify the m_object_table or m_idef_table.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpUserDataTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of user data table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpHistoryRecordTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpObjectTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpIDefTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of instance definition table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpHatchPatternTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of hatch pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpDimStyleTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of dimstyle table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpFontTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of font table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpGroupTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of group table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpLightTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of light table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpLayerTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of layer table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpLinetypeTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of line type table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpMaterialTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of render material table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpTextureMappingTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of texture mapping table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpBitmapTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of bitmap table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.DumpSummary(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of model properties and settings
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Dump(RMA.OpenNURBS.OnTextLog)">
            <summary>text dump of entire model</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetUnusedLayerName(System.String)">
            <summary>
Get layer name that is not currently in use.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.LayerIndex(System.String)">
            <summary>Get layer definition from layer table.</summary>
            <param name="layer_name">[in] name to search for</param>
            <returns>Index of the layer or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.UsesIDef(RMA.OpenNURBS.IOnInstanceRef,System.Guid)">
            <summary>See if the instance reference iref refers to an instance definition.</summary>
            <param name="iref">[in]</param>
            <param name="idef_uuid">[in] id of idef we are looking for</param>
            <returns>
0 iref does not use idef
1 iref directly references idef
&gt;1 iref has a nested reference to idef (nesting depth returned)
-1 iref.m_instance_definition_uuid is not valid
-2 invalid idef found
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IDefIndex(System.String)">
            <summary>Get instance definition index from instance definition name.</summary>
            <param name="idef_name">[in] name to search for</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IDefIndex(System.Guid)">
            <summary>Get instance definition from instance definition table.</summary>
            <param name="idef_uuid">[in] instance definition uuid.</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.ObjectIndex(System.Guid)">
            <summary>Get index of object in m_object_table from object_uuid.</summary>
            <param name="object_uuid">[in] object uuid.</param>
            <returns>Index of the object or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.WireframeColor(System.Int32)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.WireframeColor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetLinetype(System.Int32,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetLinetype(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetRenderMaterial(System.Int32,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.GetRenderMaterial(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.BoundingBox">
            <summary>
Returns: Bounding box of every object in m_object_table[].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Audit(System.Boolean,System.Int32@,RMA.OpenNURBS.OnTextLog,RMA.OpenNURBS.Arrayint)">
            <summary>
Check a model to make sure it is valid and, if possible and requrested, attempt to repair.
</summary>
            <param name="bAttemptRepair">[in] if true and a problem is found, the problem is repaired.</param>
            <param name="repair_count">[out] number of successful repairs.</param>
            <param name="text_log">
[in] if not NULL and errors are found, a description of the problem is put in this text_log.
</param>
            <param name="warnings">
[out] If problems were found, warning ids are appended to this list.
1 m_material_table[] flaws
2 layer table is not perfect.
3 some m_object_table[].m_attributes.m_uuid was nil or not unique.
4 some m_object_table[].IsValid() is false
5 some m_idef_table[] has an invalid or duplicate name
6 warning some m_idef_table[].m_object_uuid[] is not valid
7 warning some m_object_table[].m_object is null
8 warning some m_object_table[].m_object-&gt;IsValid() is false
9 warning some m_object_table[].m_attributes is not valid
10 linetype table is not perfect.
11 lineset table is not perfect.
12 some m_idef_table[].m_uuid was nil or not unique.
13 some m_texture_mapping_table[i].m_mapping_id was nil or not unique.
14 some m_material_table[i].m_material_id was nil or not unique.
15 some m_light_table[i].m_light_id was nil or not unique.
</param>
            <returns>
True if model is valid and false if the model has serious
&lt;0 model has serious errors
=0 model is ok
&gt;0 number of problems that were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Polish">
            <summary>
Quickly fills in the little details, like making sure there is at least
one layer and table indices make sense. For a full blown check and repair,
call Audit(true).
See Also: ONX_Model::Audit
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IsValid">
            <summary>Check a model to make sure it is valid.</summary>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Check a model to make sure it is valid.</summary>
            <param name="text_log">
[in] if not NULL and errors are found, a description of the problem is put in this text_log.
</param>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String,System.Int32)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String,System.Int32,System.String)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(System.String,System.Int32,System.String,RMA.OpenNURBS.OnTextLog)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <param name="error_log">[out] any archive writing errors are logged here.</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive,System.Int32)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive,System.Int32,System.String)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Write(RMA.OpenNURBS.OnBinaryArchive,System.Int32,System.String,RMA.OpenNURBS.OnTextLog)">
            <summary>
Writes contents of this model to an openNURBS archive. I STRONGLY suggested
that you call Polish() before calling Write so that your file has all the
"fluff" that makes it complete. If the model is not valid, then Write
will refuse to write it.
</summary>
            <param name="archive">[in] archive to write to</param>
            <param name="version">
[in] Version of the openNURBS archive to write. Must be 2, 3 or 4.
Rhino 2.x can read version 2 files.
Rhino 3.x can read version 2 and 3 files.
Rhino 4.x can read version 2, 3 and 4 files.
Use version 4 when possible.
</param>
            <param name="sStartSectionComment">
[in] Brief ASCII desciption of your app, today's date, etc.
</param>
            <param name="error_log">[out] any archive writing errors are logged here.</param>
            <returns>
True if archive is written with no error.
False if errors occur. Error details are logged in error_log.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Reads an openNURBS archive and saves the information in this model</summary>
            <param name="archive">[in] archive to read from</param>
            <returns>
true if archive is read with no error.
False if errors occur. Error details are logged in error_log.
If crc errors are in the archive, then m_crc_error_count is set
to the number of errors.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Read(RMA.OpenNURBS.OnBinaryArchive@,RMA.OpenNURBS.OnTextLog)">
            <summary>Reads an openNURBS archive and saves the information in this model</summary>
            <param name="archive">[in] archive to read from</param>
            <param name="error_log">[out] any archive reading errors are logged here.</param>
            <returns>
true if archive is read with no error.
False if errors occur. Error details are logged in error_log.
If crc errors are in the archive, then m_crc_error_count is set
to the number of errors.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXModel.Destroy">
            <summary>
Destroys contents of this model and leaves it ready to be reused.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_crc_error_count">
            <summary>
Number of crc errors found during archive reading.
If &gt; 0, then the archive is corrupt.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_file_length_big">
            <summary>
length of archive returned by ON_BinaryArchive::Read3dmEndMark()
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_settings">
            <summary>
Settings include tolerance, and unit system, and defaults used
for creating views and objects.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel.m_properties">
            <summary>
Properties include revision history, notes, information about
the applicaton that created the file, and an option preview image.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnXModel">
            <summary>
Pedegodgical example of all the things in an OpenNURBS 3dm archive.
The openNURBS examples use ONX_Model to store the information
read from 3dm archives.  Please study example_read.cpp for
details.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpUserDataTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of user data table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpHistoryRecordTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpObjectTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of object table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpIDefTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of instance definition table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpHatchPatternTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of hatch pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpDimStyleTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of dimstyle table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpFontTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of font table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpGroupTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of group table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpLightTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of light table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpLayerTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of layer table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpLinetypeTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of line type table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpMaterialTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of render material table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpTextureMappingTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of texture mapping table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpBitmapTable(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of bitmap table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.DumpSummary(RMA.OpenNURBS.OnTextLog)">
            <summary>
text dump of model properties and settings
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.Dump(RMA.OpenNURBS.OnTextLog)">
            <summary>text dump of entire model</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetUnusedLayerName(System.String)">
            <summary>
Get layer name that is not currently in use.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.LayerIndex(System.String)">
            <summary>Get layer definition from layer table.</summary>
            <param name="layer_name">[in] name to search for</param>
            <returns>Index of the layer or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.UsesIDef(RMA.OpenNURBS.IOnInstanceRef,System.Guid)">
            <summary>See if the instance reference iref refers to an instance definition.</summary>
            <param name="iref">[in]</param>
            <param name="idef_uuid">[in] id of idef we are looking for</param>
            <returns>
0 iref does not use idef
1 iref directly references idef
&gt;1 iref has a nested reference to idef (nesting depth returned)
-1 iref.m_instance_definition_uuid is not valid
-2 invalid idef found
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IDefIndex(System.String)">
            <summary>Get instance definition index from instance definition name.</summary>
            <param name="idef_name">[in] name to search for</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IDefIndex(System.Guid)">
            <summary>Get instance definition from instance definition table.</summary>
            <param name="idef_uuid">[in] instance definition uuid.</param>
            <returns>Index of the instance definition or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.ObjectIndex(System.Guid)">
            <summary>Get index of object in m_object_table from object_uuid.</summary>
            <param name="object_uuid">[in] object uuid.</param>
            <returns>Index of the object or -1 if it is not found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.WireframeColor(System.Int32)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.WireframeColor(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>Get wireframe drawing color from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <returns>Wireframe drawing color.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetLinetype(System.Int32,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetLinetype(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnLinetype@)">
            <summary>Get linetype from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="linetype">[out] linetype</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetRenderMaterial(System.Int32,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object_index.</summary>
            <param name="object_index">[in] m_object_table[] index</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.GetRenderMaterial(RMA.OpenNURBS.IOn3dmObjectAttributes,RMA.OpenNURBS.OnMaterial@)">
            <summary>Get render material from object attributes.</summary>
            <param name="attributes">[in] object attributes.</param>
            <param name="material">[out] render material</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.BoundingBox">
            <summary>
Returns: Bounding box of every object in m_object_table[].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IsValid">
            <summary>Check a model to make sure it is valid.</summary>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXModel.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Check a model to make sure it is valid.</summary>
            <param name="text_log">
[in] if not NULL and errors are found, a description of the problem is put in this text_log.
</param>
            <returns>True if the model is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_crc_error_count">
            <summary>
Number of crc errors found during archive reading.
If &gt; 0, then the archive is corrupt.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_file_length_big">
            <summary>
length of archive returned by ON_BinaryArchive::Read3dmEndMark()
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_settings">
            <summary>
Settings include tolerance, and unit system, and defaults used
for creating views and objects.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel.m_properties">
            <summary>
Properties include revision history, notes, information about
the applicaton that created the file, and an option preview image.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnXModel">
            <summary>
Pedegodgical example of all the things in an OpenNURBS 3dm archive.
The openNURBS examples use ONX_Model to store the information
read from 3dm archives.  Please study example_read.cpp for
details.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnXModel_RenderLight">
            <summary>Used to store render light table light definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnXModel_RenderLight">
            <summary>Used to store render light table light definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXModel_Object.m_bDeleteObject">
            <summary>
If m_bDeleteObject is true, then m_object will be deleted when
the last ONX_Model_Object that refers to it is destroyed.  The
default value of m_bDeleteObject is false.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnXModel_Object">
            <summary>Used to store geometry table object definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXModel_Object.m_bDeleteObject">
            <summary>
If m_bDeleteObject is true, then m_object will be deleted when
the last ONX_Model_Object that refers to it is destroyed.  The
default value of m_bDeleteObject is false.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnXModel_Object">
            <summary>Used to store geometry table object definition and attributes in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnX_Model_UserData">
            <summary>Used to store user data information in an ONX_Model.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_Model_UserData">
            <summary>Used to store user data information in an ONX_Model.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHistoryRecord.m_record_id">
            <summary>
Each history record has a unique id that is assigned
when the record is added to Rhino's history record table.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHistoryRecord.m_version">
            <summary>
A YYYYMMDDn version number that gets updated when
a command changes.  This version is checked so that
new versions of a command's ReplayHistory don't 
attempt to use information saved in old files.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHistoryRecord.m_command_id">
            <summary>
CRhinoCommand::CommandId() value of the command that
created this history record.  Each time the command
is run, it can create a history record.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHistoryRecord.ValueReport(RMA.OpenNURBS.OnTextLog)">
            <summary>Print a list of the values in text_log.</summary>
            <param name="text_log">[in]</param>
            <returns>Number of values listed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHistoryRecord.IsAntecedent(System.Guid)">
            <summary>Determine if object is an antecedent (input) in this history record</summary>
            <param name="object_uuid">[in]</param>
            <returns>true if object_uuid is the id of an input object.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHistoryRecord.m_record_id">
            <summary>
Each history record has a unique id that is assigned
when the record is added to Rhino's history record table.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHistoryRecord.m_version">
            <summary>
A YYYYMMDDn version number that gets updated when
a command changes.  This version is checked so that
new versions of a command's ReplayHistory don't 
attempt to use information saved in old files.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHistoryRecord.m_command_id">
            <summary>
CRhinoCommand::CommandId() value of the command that
created this history record.  Each time the command
is run, it can create a history record.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHistoryRecord.ValueReport(RMA.OpenNURBS.OnTextLog)">
            <summary>Print a list of the values in text_log.</summary>
            <param name="text_log">[in]</param>
            <returns>Number of values listed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHistoryRecord.IsAntecedent(System.Guid)">
            <summary>Determine if object is an antecedent (input) in this history record</summary>
            <param name="object_uuid">[in]</param>
            <returns>true if object_uuid is the id of an input object.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnDetailView.m_boundary">
            <summary>
2d curve in page layout coordinates in mm
(0,0) = lower left corner of page
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDetailView.m_view">
            <summary>
A view with ON_3dmView::m_view_type = ON::nested_view_type
This field is used for IO purposes only.  Runtime detail
view projection information is on CRhDetailViewObject.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDetailView.m_page_per_model_ratio">
            <summary>
m_page_per_model_ratio is the ratio of page length / model length
where both lengths are in the same unit system
(ex. 1/4" on page = 1' in model = 0.25/12 = 0.02083)
(    1mm on page  = 1m in model = 1/1000  = 0.001)
If m_page_per_model_ratio &gt; 0.0, then the detail
is drawn using the specified scale.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDetailView.m_boundary">
            <summary>
2d curve in page layout coordinates in mm
(0,0) = lower left corner of page
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDetailView.m_view">
            <summary>
A view with ON_3dmView::m_view_type = ON::nested_view_type
This field is used for IO purposes only.  Runtime detail
view projection information is on CRhDetailViewObject.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDetailView.m_page_per_model_ratio">
            <summary>
m_page_per_model_ratio is the ratio of page length / model length
where both lengths are in the same unit system
(ex. 1/4" on page = 1' in model = 0.25/12 = 0.02083)
(    1mm on page  = 1m in model = 1/1000  = 0.001)
If m_page_per_model_ratio &gt; 0.0, then the detail
is drawn using the specified scale.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurface.BaseSurface">
            <summary>
Returns: Base surface;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurface.SetBaseSurface(RMA.OpenNURBS.OnSurface,System.Boolean)">
            <summary>Sets base surface to a surface that is optionally managed by the ON_OffsetSurface class.</summary>
            <param name="base_surface">
[in] points to a base surface the caller insures will exist for the lifetime of the ON_OffsetSurface class.
</param>
            <param name="bManage">
[in] if true, the base_surface must point to a surface that is on the heap and the surface will be deleted by ~ON_OffsetSurface.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurface.SetBaseSurface(RMA.OpenNURBS.IOnSurface)">
            <summary>Sets base surface to a surface that is not managed by the ON_OffsetSurface class.</summary>
            <param name="base_surface">
[in] points to a base surface the caller insures will exist for the lifetime of the ON_OffsetSurface class.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnOffsetSurface">
            <summary>
This is still a work in progress.  In particular, this surface class can
not be saved in files, used as a brep surface, added to Rhino, etc.

As of January 2004, it is useful for calculating offset meshes and any
other fitting and approximation tools that requires a surface evaluator
but do not need NURBS forms, isocurves, and so on.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurface.BaseSurface">
            <summary>
Returns: Base surface;
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnOffsetSurface">
            <summary>
This is still a work in progress.  In particular, this surface class can
not be saved in files, used as a brep surface, added to Rhino, etc.

As of January 2004, it is useful for calculating offset meshes and any
other fitting and approximation tools that requires a surface evaluator
but do not need NURBS forms, isocurves, and so on.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.Destroy">
            <summary>
Resets this class if you want to reuse it.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.PointAt(System.Double,System.Double)">
            <summary>Value of the offset function at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>Point on the offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.EvaluateDistance(System.Double,System.Double,System.Int32,System.Double[]@)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="num_der">[in] number of derivatives</param>
            <param name="value">
[out] value and derivatives of distance function
value[0] = distance, value[1] = 1rst derivative,
value[2] = 2nd derivative, ...
</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.DistanceAt(System.Double,System.Double)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>offset distance at the surface parameter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.OffsetDistance(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Offset distance specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.OffsetSurfaceParameter(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Surface parameter specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.OffsetPointCount">
            <summary>
Returns: Number of points specified using SetOffsetPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetDistance(System.Int32,System.Double)">
            <summary>Set the offset distance for an existing point</summary>
            <param name="index">[in] index of the point to set</param>
            <param name="distance">[in] new distance</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetPoint(System.Int32,System.Double,System.Double)">
            <summary>Sets the surface parameters of an existing offset point.</summary>
            <param name="index">[in] index of the point to set</param>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetOffsetPoint(System.Double,System.Double,System.Double)">
            <summary>
Sets the offset distance at a point. Call this function once for each
point wher the user specifies an offset. 
</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="distance">[in] distance is the offset distance.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetOffsetPoint(System.Double,System.Double,System.Double,System.Double)">
            <summary>
Sets the offset distance at a point. Call this function once for each
point wher the user specifies an offset. 
</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="distance">[in] distance is the offset distance.</param>
            <param name="radius">
[in] if radius&gt;0, then this value will be the the approximate radius of the offset "bump".
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SideTangency(System.Int32)">
            <param name="side">
0 = south side
1 = east side
2 = north side
3 = west side
</param>
            <returns>True if side tangency is enabled.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetSideTangency(System.Int32,System.Boolean)">
            <summary>
Use set SetSideTangency if you want the offset surface and base surface
to have the same unit normals along a side of the surfaces's parameter spaces.
</summary>
            <param name="side">
0 = south side
1 = east side
2 = north side
3 = west side
</param>
            <param name="bEnable">[in] true to enable tangency, false to disable tangency</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.BaseSurface">
            <summary>
Returns: Base surface specified SetBaseSurface().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOffsetSurfaceFunction.SetBaseSurface(RMA.OpenNURBS.IOnSurface)">
            <summary>Sets base surface for the offset function.</summary>
            <param name="srf">
[in] pointer to the base surface.
This surface must remain valid while
the ON_OffsetSurfaceFunction class is used.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.PointAt(System.Double,System.Double)">
            <summary>Value of the offset function at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>Point on the offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.EvaluateDistance(System.Double,System.Double,System.Int32,System.Double[]@)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="num_der">[in] number of derivatives</param>
            <param name="value">
[out] value and derivatives of distance function
value[0] = distance, value[1] = 1rst derivative,
value[2] = 2nd derivative, ...
</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.DistanceAt(System.Double,System.Double)">
            <summary>Value of the offset distance at any surface parameter.</summary>
            <param name="s">[in] (s,t) is a base surface evaluation parameter</param>
            <param name="t">[in] (s,t) is a base surface evaluation parameter</param>
            <returns>offset distance at the surface parameter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.OffsetDistance(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Offset distance specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.OffsetSurfaceParameter(System.Int32)">
            <param name="i">[in] an index &gt;= 0 and &lt; OffsetPointCount()</param>
            <returns>Surface parameter specified using SetOffsetPoint().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.OffsetPointCount">
            <summary>
Returns: Number of points specified using SetOffsetPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.SideTangency(System.Int32)">
            <param name="side">
0 = south side
1 = east side
2 = north side
3 = west side
</param>
            <returns>True if side tangency is enabled.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOffsetSurfaceFunction.BaseSurface">
            <summary>
Returns: Base surface specified SetBaseSurface().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjRef.ProxyReferenceCount">
            <summary>
Returns:
0: This ON_ObjRef is not counting references.
&gt;0: Number of references.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjRef.SetProxy(RMA.OpenNURBS.OnObject,RMA.OpenNURBS.OnObject,System.Boolean)">
            <summary>
Expert user tool to initialize the ON_ObjRef m__proxy1, m__proxy2, and m__proxy_ref_count fields.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjRef.DecrementProxyReferenceCount">
            <summary>
Expert user tool to decrement reference counts. Most users will never need
to call this tool. It is called by ~ON_ObjRef and used in rare cases when a
ON_ObjRef needs to reference an object only by uuid and component index.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m__iref">
            <summary>
If m__iref[] is not empty, then m_uuid identifies
and instance reference (ON_InstanceRef/CRhinoInstanceObject)
and m__iref[] records the chain of instance references from
the base piece of geometry to the instance reference.
The top level instance reference is last in the list.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_evp">
            <summary>
If m_point != ON_UNSET_POINT and m_evp.m_t_type != 0, then
m_evp records the records the m_geometry evaluation
parameters for the m_point.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_osnap_mode">
            <summary>
If the point was the result of some type of object snap, then
the object snap is recorded here.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_point">
            <summary>
If m_point != ON_UNSET_POINT, then the ObjRef resolves to 
a point location.  The point location is saved here so the
information can persist if the object itself vanishes.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_runtime_sn">
            <summary>
If m_runtime_sn &gt; 0, then it is the value of a Rhino object's/ CRhinoObject::m_runtime_object_serial_number field.
The serial number is used instead of the pointer to prevent crashes in cases when the CRhinoObject is deleted but an
ON_ObjRef continues to reference the Rhino object. The value of m_runtime_sn is not saved in archives because it generally
changes if you save and reload an archive.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_parent_geometry">
            <summary>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_geometry">
            <summary>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef.m_uuid">
            <summary>
In Rhino, this uuid is the persistent id of the CRhinoObject
that owns the referenced geometry.  The value of the
CRhinoObject id is stored on ON_3dmObjectAttributes.m_uuid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjRef.ProxyReferenceCount">
            <summary>
Returns: 0: This ON_ObjRef is not counting references. &gt;0: Number of references.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m__iref">
            <summary>
If m__iref[] is not empty, then m_uuid identifies
and instance reference (ON_InstanceRef/CRhinoInstanceObject)
and m__iref[] records the chain of instance references from
the base piece of geometry to the instance reference.
The top level instance reference is last in the list.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_evp">
            <summary>
If m_point != ON_UNSET_POINT and m_evp.m_t_type != 0, then
m_evp records the records the m_geometry evaluation
parameters for the m_point.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_osnap_mode">
            <summary>
If the point was the result of some type of object snap, then
the object snap is recorded here.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_point">
            <summary>
If m_point != ON_UNSET_POINT, then the ObjRef resolves to 
a point location.  The point location is saved here so the
information can persist if the object itself vanishes.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_runtime_sn">
            <summary>
If m_runtime_sn &gt; 0, then it is the value of a Rhino object's/ CRhinoObject::m_runtime_object_serial_number field.
The serial number is used instead of the pointer to prevent crashes in cases when the CRhinoObject is deleted but an
ON_ObjRef continues to reference the Rhino object. The value of m_runtime_sn is not saved in archives because it generally
changes if you save and reload an archive.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_parent_geometry">
            <summary>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_geometry">
            <summary>
The m_geometry and m_parent_geometry pointers are runtime values
that point to the object being referenced.  The destructor 
~ON_ObjRef  does not delete the objects these pointers reference.

m_geometry_type records the type of geometry m_geometry points to.

When the referenced object is a subobject, like a part of a brep 
or mesh, m_geometry points to the subobject and m_parent_geometry 
points to the parent object, like the brep or mesh.  In this case
m_component_index records the location of the subobject.

Parts of instance reference objects:
 When the geometry belongs to an instance reference
 m_uuid is the id of the CRhinoInstanceObject,
 m_parent_geometry points to the instance definition
 geometry or a transformed proxy, and m_geometry points
 to the piece of m_geometry.  The m__iref[] array records
 the connection between the instance reference and the
 geometry the ON_ObjRef refers to.

 For example if the ON_ObjRef is to an edge of a brep in
 and instance reference, m_uuid would be the Rhino id of
 the CRhinoInstanceObject, m_parent_geometry would point
 to a, possibly proxy, ON_Brep object, m_geometry would point
 to the ON_BrepEdge in the ON_Brep, m_component_index would
 record the edge's index in the ON_Brep.m_E[] array and 
 m_geometry_type would be ON::curve_object or ON::brep_edge.
 m__iref-&gt;Last() would contain the information about the
 top level instance reference.  If the brep was at the bottom
 of a chain of instance references, m__iref[0] would be the
 reference that immediately used the brep.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef.m_uuid">
            <summary>
In Rhino, this uuid is the persistent id of the CRhinoObject
that owns the referenced geometry.  The value of the
CRhinoObject id is stored on ON_3dmObjectAttributes.m_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_evp">
            <summary>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If there is an evaluation parameter for the geometry,
it is saved in m_evp.
In all other cases, m_evp is not set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_component_index">
            <summary>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If the reference is to a subobject of the real piece
of geometry, then m_component_index records
the subobject index.
In all other cases, m_component_index is not set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_geometry_xform">
            <summary>
m_geometry_xform is the transformation to map the
base geometry to world coordinates.  If the
instance reference is not nested, then
m_geometry_xform = m_iref_xform.  If the instance
reference is nested, then
 m_geometry_xform = m_iref_xform * .... * T1
where the Ts are the transformations from the children.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_idef_geometry_index">
            <summary>
m_geometry_index is the index of the uuid of the pertinant
piece of geometry in the ON_InstanceRef.m_object_uuid[] 
array.  This index is identical to the index of the
geometry's CRhinoObject in the
CRhinoInstanceDefinition.m_objects[] array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_idef_uuid">
            <summary>
m_idef_uuid is the instance definition id stored in
ON_InstanceRef.m_instance_definition_uuid and
ON_InstanceDefinition.m_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_iref_xform">
            <summary>
m_iref_xform is the value stored in ON_InstanceRef.m_xform.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRef_IRefID.m_iref_uuid">
            <summary>
m_iref_uuid is the CRhinoInstanceObject's uuid stored
in its ON_3dmObjectAttributes.m_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_evp">
            <summary>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If there is an evaluation parameter for the geometry,
it is saved in m_evp.
In all other cases, m_evp is not set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_component_index">
            <summary>
If this ON_ObjRef_IRefID is the first entry in the
ON_ObjRef.m__iref[] array, then it references a "real"
piece of geometry (not a nested instance reference).  
If the reference is to a subobject of the real piece
of geometry, then m_component_index records
the subobject index.
In all other cases, m_component_index is not set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_geometry_xform">
            <summary>
m_geometry_xform is the transformation to map the
base geometry to world coordinates.  If the
instance reference is not nested, then
m_geometry_xform = m_iref_xform.  If the instance
reference is nested, then
 m_geometry_xform = m_iref_xform * .... * T1
where the Ts are the transformations from the children.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_idef_geometry_index">
            <summary>
m_geometry_index is the index of the uuid of the pertinant
piece of geometry in the ON_InstanceRef.m_object_uuid[] 
array.  This index is identical to the index of the
geometry's CRhinoObject in the
CRhinoInstanceDefinition.m_objects[] array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_idef_uuid">
            <summary>
m_idef_uuid is the instance definition id stored in
ON_InstanceRef.m_instance_definition_uuid and
ON_InstanceDefinition.m_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_iref_xform">
            <summary>
m_iref_xform is the value stored in ON_InstanceRef.m_xform.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRef_IRefID.m_iref_uuid">
            <summary>
m_iref_uuid is the CRhinoInstanceObject's uuid stored
in its ON_3dmObjectAttributes.m_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRefEvaluationParameter.m_t_ci">
            <summary>
Not necesarily the same as m_component_index
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRefEvaluationParameter.m_s(System.Int32)">
            <summary>
curve/surface/cage domains
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjRefEvaluationParameter.m_t_type">
            <summary>
If m_point != ON_UNSET_POINT and m_t_type != 0, then
m_t_type, m_t, and m_t_ci record the m_geometry evaluation
parameters of the m_point.

 m_t_type values

0: no parameter values; m_t_ci and m_t[] have no meaning.

1: m_geometry points to a curve, m_t[0] is a curve
  parameter for m_point, and m_t_ci has no meaning.

2: m_geometry points to surface or single faced brep,
  (m_t[0],m_t[1]) is a surface parameter for m_point,
  and m_t_ci has no meaning.
  In this case, m_component_index may not be set or,
  if m_geometry points to a brep face, m_component_index
  may identify the face in the parent brep.

3: m_geometry points to a brep edge with an associated
  trim and m_t[0] is the edge parameter for m_point.
  m_t_ci is the ON_BrepTrim component index and m_t[1]
  is the ON_BrepTrim parameter that corresponds to the
  edge point.  m_s[0] and m_s[1] are normalized parameters.
  In this case m_component_index identifies the
  the edge in the brep and m_t_ci identifies a trim.

4: m_geometry points to a mesh or mesh face and 
  m_t_ci identifies the mesh face.
  If the face is a triangle, the barycentric coordinates
  of m_point are(m_t[0], m_t[1], m_t[2]) and m_t[3] is zero. 
  If the mesh face is a quadrangle, the barycentric coordinates
  of m_point are (m_t[0], m_t[1], m_t[2], m_t[3]) and at least 
  one of the coordinates is zero.  In both cases, the point
  can be evaluated using the formula
  m_t[0]*mesh.m_V[f.vi[0]] + ... + m_t[3]*mesh.m_V[f.vi[3]],
  where f = mesh.m_F[m_component_index.m_index].
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

5: m_geometry points to a mesh or mesh edge and m_t_ci
  identifies the mesh edge. The normalized coordinate of
  the point on the mesh edge is m_t[0].  The point can be evaluated
  using the formula
  m_t[0]*mesh.m_V[v0] + (1.0-m_t[0])*mesh.m_V[v1],
  where v0 and v1 are the indices of the mesh vertices at
  the edge's ends.
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

6: m_geometry points to a NURBS cage and (m_t[0],m_t[1],m_t[2])
  are cage evaluation parameters.

7: m_geometry points to an annotation object and m_t_ci identifies
  a point on the annotation object.

8: m_geometry points to a mesh or mesh vertex object and m_t_ci
  identifies a vertex on the mesh object.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRefEvaluationParameter.m_t_ci">
            <summary>
Not necesarily the same as m_component_index
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRefEvaluationParameter.m_s(System.Int32)">
            <summary>
curve/surface/cage domains
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjRefEvaluationParameter.m_t_type">
            <summary>
If m_point != ON_UNSET_POINT and m_t_type != 0, then
m_t_type, m_t, and m_t_ci record the m_geometry evaluation
parameters of the m_point.

 m_t_type values

0: no parameter values; m_t_ci and m_t[] have no meaning.

1: m_geometry points to a curve, m_t[0] is a curve
  parameter for m_point, and m_t_ci has no meaning.

2: m_geometry points to surface or single faced brep,
  (m_t[0],m_t[1]) is a surface parameter for m_point,
  and m_t_ci has no meaning.
  In this case, m_component_index may not be set or,
  if m_geometry points to a brep face, m_component_index
  may identify the face in the parent brep.

3: m_geometry points to a brep edge with an associated
  trim and m_t[0] is the edge parameter for m_point.
  m_t_ci is the ON_BrepTrim component index and m_t[1]
  is the ON_BrepTrim parameter that corresponds to the
  edge point.  m_s[0] and m_s[1] are normalized parameters.
  In this case m_component_index identifies the
  the edge in the brep and m_t_ci identifies a trim.

4: m_geometry points to a mesh or mesh face and 
  m_t_ci identifies the mesh face.
  If the face is a triangle, the barycentric coordinates
  of m_point are(m_t[0], m_t[1], m_t[2]) and m_t[3] is zero. 
  If the mesh face is a quadrangle, the barycentric coordinates
  of m_point are (m_t[0], m_t[1], m_t[2], m_t[3]) and at least 
  one of the coordinates is zero.  In both cases, the point
  can be evaluated using the formula
  m_t[0]*mesh.m_V[f.vi[0]] + ... + m_t[3]*mesh.m_V[f.vi[3]],
  where f = mesh.m_F[m_component_index.m_index].
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

5: m_geometry points to a mesh or mesh edge and m_t_ci
  identifies the mesh edge. The normalized coordinate of
  the point on the mesh edge is m_t[0].  The point can be evaluated
  using the formula
  m_t[0]*mesh.m_V[v0] + (1.0-m_t[0])*mesh.m_V[v1],
  where v0 and v1 are the indices of the mesh vertices at
  the edge's ends.
  In this case, if m_geometry points to a mesh, then
  m_component_index !=  m_t_ci.

6: m_geometry points to a NURBS cage and (m_t[0],m_t[1],m_t[2])
  are cage evaluation parameters.

7: m_geometry points to an annotation object and m_t_ci identifies
  a point on the annotation object.

8: m_geometry points to a mesh or mesh vertex object and m_t_ci
  identifies a vertex on the mesh object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.DimExtension">
            <summary>
added version 1.3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.InvalidateField(RMA.OpenNURBS.IOnDimStyle.eField)">
            <summary>
mark a single field as invalid
Setting a field value marks that field as valid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.Composite(RMA.OpenNURBS.IOnDimStyle)">
            <summary>
replace the values in this with any valid fields in override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.LengthFactor">
            <summary>
added at ver 1.3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDimStyle.op_Implicit(RMA.OpenNURBS.IOn3dmAnnotationSettings)~RMA.OpenNURBS.OnDimStyle">
            <summary>
C++ default copy construction and operator= work fine.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_leaderarrowsize">
            <summary>
fields added version 1.5 Mar 23 06
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_dimextension">
            <summary>
(dimdle) dimension line extension past the "tip" location
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_valid">
            <summary>
flags of what fields are being used
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_suffix">
            <summary>
string following alternate value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_prefix">
            <summary>
string preceding alternate value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_suffix">
            <summary>
string following dimension value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_prefix">
            <summary>
string preceding dimension value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_angleresolution">
            <summary>
for decimal degrees, digits past decimal
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_angleformat">
            <summary>
0: decimal degrees, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_lengthresolution">
            <summary>
depends on m_lengthformat
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_lengthformat">
            <summary>
0: decimal, 1: feet, 2: feet &amp; inches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_alternate_lengthfactor">
            <summary>
(dimaltf) model units multiplier for alternate length display
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_bAlternate">
            <summary>
(dimalt) display alternate dimension string (or not)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_lengthfactor">
            <summary>
(dimlfac) model units multiplier for length display
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_fontindex">
            <summary>
index of the ON_Font used by this dimstyle
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_lengthresolution">
            <summary>
depends on m_lengthformat
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_angleresolution">
            <summary>
for decimal degrees, digits past decimal
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_angleformat">
            <summary>
0: decimal degrees, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_lengthformat">
            <summary>
0: decimal, 1: feet, 2: feet &amp; inches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_angularunits">
            <summary>
0: degrees, 1: radians
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_arrowtype">
            <summary>
0: filled narrow triangular arrow
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_textalign">
            <summary>
text alignment relative to the dimension line
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_textheight">
            <summary>
model unit height of dimension text before applying dimscale
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_textgap">
            <summary>
gap around the text for clipping dim line
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_centermark">
            <summary>
size of the + at circle centers
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_arrowsize">
            <summary>
length of an arrow - may mean different things to different arrows
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_extoffset">
            <summary>
extension line offset
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_extextension">
            <summary>
extension line extension
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_dimstyle_index">
            <summary>
Index in the dimstyle table
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDimStyle.m_dimstyle_name">
            <summary>
String name of the style
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnDimStyle.DimExtension">
            <summary>
added version 1.3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnDimStyle.LengthFactor">
            <summary>
added at ver 1.3
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_leaderarrowsize">
            <summary>
fields added version 1.5 Mar 23 06
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_dimextension">
            <summary>
(dimdle) dimension line extension past the "tip" location
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_valid">
            <summary>
flags of what fields are being used
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_suffix">
            <summary>
string following alternate value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_prefix">
            <summary>
string preceding alternate value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_suffix">
            <summary>
string following dimension value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_prefix">
            <summary>
string preceding dimension value string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_angleresolution">
            <summary>
for decimal degrees, digits past decimal
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_angleformat">
            <summary>
0: decimal degrees, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_lengthresolution">
            <summary>
depends on m_lengthformat
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_lengthformat">
            <summary>
0: decimal, 1: feet, 2: feet &amp; inches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_alternate_lengthfactor">
            <summary>
(dimaltf) model units multiplier for alternate length display
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_bAlternate">
            <summary>
(dimalt) display alternate dimension string (or not)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_lengthfactor">
            <summary>
(dimlfac) model units multiplier for length display
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_fontindex">
            <summary>
index of the ON_Font used by this dimstyle
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_lengthresolution">
            <summary>
depends on m_lengthformat
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_angleresolution">
            <summary>
for decimal degrees, digits past decimal
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_angleformat">
            <summary>
0: decimal degrees, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_lengthformat">
            <summary>
0: decimal, 1: feet, 2: feet &amp; inches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_angularunits">
            <summary>
0: degrees, 1: radians
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_arrowtype">
            <summary>
0: filled narrow triangular arrow
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_textalign">
            <summary>
text alignment relative to the dimension line
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_textheight">
            <summary>
model unit height of dimension text before applying dimscale
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_textgap">
            <summary>
gap around the text for clipping dim line
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_centermark">
            <summary>
size of the + at circle centers
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_arrowsize">
            <summary>
length of an arrow - may mean different things to different arrows
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_extoffset">
            <summary>
extension line offset
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_extextension">
            <summary>
extension line extension
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_dimstyle_index">
            <summary>
Index in the dimstyle table
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDimStyle.m_dimstyle_name">
            <summary>
String name of the style
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPatternIndex(System.Int32)">
            <summary>Set the index of the hatch's pattern</summary>
            <param name="index">[in] pattern index to set</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.PatternIndex">
            <summary>Get the index of the hatch's pattern</summary>
            <returns>index of the pattern</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.LoopCurve3d(System.Int32)">
            <summary>Get the 3d curve corresponding to loop[index]</summary>
            <param name="index">[in] which loop to get</param>
            <returns>
pointer to 3d curve of loop at index NULL if index is out of range or curve
can't be made Caller deletes the returned curve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.Loop(System.Int32)">
            <summary>Get the loop at index</summary>
            <param name="index">[in] which loop to get</param>
            <returns>pointer to loop at index NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.RemoveLoop(System.Int32)">
            <summary>Remove a loop in the hatch</summary>
            <param name="index">[in] zero based index of the loop to remove.</param>
            <returns>true if success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.InsertLoop(System.Int32,RMA.OpenNURBS.OnHatchLoop)">
            <summary>Insert a loop to the hatch at the specified index</summary>
            <param name="index">[in] zero based index of the position where insert the loop to.</param>
            <param name="loop">[in] the loop to insert</param>
            <returns>
true if success
false if index is lower than 0 or greater than current loop count.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.AddLoop(RMA.OpenNURBS.OnHatchLoop)">
            <summary>Add a loop to the hatch</summary>
            <param name="loop">[in] the loop to add</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.LoopCount">
            <summary>Get the number of loops used by this hatch</summary>
            <returns>the number of loops</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPatternScale(System.Double)">
            <summary>
Sets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <param name="scale">[in] The scale</param>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.PatternScale">
            <summary>
Gets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The scale</returns>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPatternRotation(System.Double)">
            <summary>
Sets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <param name="rotation">[in] The rotation in radians</param>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.PatternRotation">
            <summary>
Gets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The rotation in radians</returns>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
Set the plane defining the hatch's coordinate system
</summary>
            <param name="plane">[in] the plane to set</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.Plane">
            <summary>Get the plane defining the hatch's coordinate system</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.Create(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnCurve[],System.Int32,System.Double,System.Double)">
            <summary>Create a hatch from input geometry and parameters</summary>
            <param name="plane">[IN] - ON_Plane to make the hatch on</param>
            <param name="loops">[IN] - Array of boundary loops with the outer one first</param>
            <param name="pattern_index">[IN] - Index into the hatch table</param>
            <param name="pattern_rotation">[IN] - ccw in radians about plane origin</param>
            <param name="pattern_scale">[IN] - Scale factor for pattern definition</param>
            <returns>true = success, false = failure</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatch.#ctor">
            <summary>
Default constructor
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatch">
            <summary>
Represents a hatch in planar boundary loop or loops 
This is a 2d entity with a plane defining a local coordinate system
The loops, patterns, angles, etc are all in this local coordinate system

The ON_Hatch object manages the plane and loop array
Fill definitions are in the ON_HatchPattern or class derived from ON_HatchPattern
ON_Hatch has an index to get the pattern definition from the pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.PatternIndex">
            <summary>Get the index of the hatch's pattern</summary>
            <returns>index of the pattern</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.LoopCurve3d(System.Int32)">
            <summary>Get the 3d curve corresponding to loop[index]</summary>
            <param name="index">[in] which loop to get</param>
            <returns>
pointer to 3d curve of loop at index NULL if index is out of range or curve
can't be made Caller deletes the returned curve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.Loop(System.Int32)">
            <summary>Get the loop at index</summary>
            <param name="index">[in] which loop to get</param>
            <returns>pointer to loop at index NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.LoopCount">
            <summary>Get the number of loops used by this hatch</summary>
            <returns>the number of loops</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.PatternScale">
            <summary>
Gets the scale applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The scale</returns>
            <remarks>The pattern is scaled around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.PatternRotation">
            <summary>
Gets the rotation applied to the hatch pattern when it is mapped to the hatch's plane
</summary>
            <returns>The rotation in radians</returns>
            <remarks>The pattern is rotated counter-clockwise around the hatch's plane origin by this value</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatch.Plane">
            <summary>Get the plane defining the hatch's coordinate system</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatch">
            <summary>
Represents a hatch in planar boundary loop or loops 
This is a 2d entity with a plane defining a local coordinate system
The loops, patterns, angles, etc are all in this local coordinate system

The ON_Hatch object manages the plane and loop array
Fill definitions are in the ON_HatchPattern or class derived from ON_HatchPattern
ON_Hatch has an index to get the pattern definition from the pattern table
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetHatchLines(RMA.OpenNURBS.IArrayOnHatchLine)">
            <summary>Set all of the hatch lines at once. Existing hatchlines are deleted.</summary>
            <param name="lines">[in] Array of lines to add. Lines are copied</param>
            <returns>number of lines added</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.RemoveAllHatchLines">
            <summary>
Remove all of the hatch lines from the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.RemoveHatchLine(System.Int32)">
            <summary>Remove a hatch line from the pattern</summary>
            <param name="index">[in] Index of the line to remove</param>
            <returns>true - success false - index out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.HatchLine(System.Int32)">
            <summary>Get the ON_HatchLine at index</summary>
            <param name="index">[in] Index of the line to get</param>
            <returns>the hatch line NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.AddHatchLine(RMA.OpenNURBS.IOnHatchLine)">
            <summary>Add an ON_HatchLine to the pattern</summary>
            <param name="line">[in] the line to add</param>
            <returns>&gt;= 0 index of the new line -1 on failure</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.HatchLineCount">
            <summary>Get the number of ON_HatchLines in the pattern</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.Index">
            <summary>Return the table index of the pattern</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetIndex(System.Int32)">
            <summary>Set the table index of the pattern</summary>
            <param name="index">[in] the new index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.Description">
            <summary>Return a short text description of the pattern type</summary>
            <returns>The description string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.GetDescription(System.String@)">
            <summary>Get a short description of the pattern</summary>
            <param name="string">[out] The string is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetDescription(System.String)">
            <summary>Set the name of the pattern</summary>
            <param name="pDescription">[in] the new description</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.Name">
            <summary>Get the name of the pattern</summary>
            <returns>The name string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.GetName(System.String@)">
            <summary>Get the name of the pattern</summary>
            <param name="string">[out] The name is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetName(System.String)">
            <summary>Set the name of the pattern</summary>
            <param name="pName">[in] the new name</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.SetFillType(RMA.OpenNURBS.IOnHatchPattern.eFillType)">
            <summary>Set the pattern's fill type</summary>
            <param name="type">[in] the new filltype</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchPattern.FillType">
            <summary>
Return the pattern's fill type
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_lines">
            <summary>
used by line hatches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_description">
            <summary>
String description of the pattern
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_hatchpattern_name">
            <summary>
String name of the pattern
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnHatchPattern.m_hatchpattern_index">
            <summary>
Index in the hatch pattern table
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatchPattern">
            <summary>
Fill definition for a hatch
The hatch  will be one of 
 ON_Hatch::ftLines     - pat file style definition
 ON_Hatch::ftGradient  - uses a color function
 ON_Hatch::ftSolid     - uses entity color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.HatchLine(System.Int32)">
            <summary>Get the ON_HatchLine at index</summary>
            <param name="index">[in] Index of the line to get</param>
            <returns>the hatch line NULL if index is out of range</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.HatchLineCount">
            <summary>Get the number of ON_HatchLines in the pattern</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.Index">
            <summary>
Description: Return the table index of the pattern Parameters: Returns: The table index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.Description">
            <summary>Return a short text description of the pattern type</summary>
            <returns>The description string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.GetDescription(System.String@)">
            <summary>Get a short description of the pattern</summary>
            <param name="string">[out] The string is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.Name">
            <summary>Get the name of the pattern</summary>
            <returns>The name string</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.GetName(System.String@)">
            <summary>Get the name of the pattern</summary>
            <param name="string">[out] The name is returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchPattern.FillType">
            <summary>
Return the pattern's fill type
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_lines">
            <summary>
used by line hatches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_description">
            <summary>
String description of the pattern
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_hatchpattern_name">
            <summary>
String name of the pattern
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnHatchPattern.m_hatchpattern_index">
            <summary>
Index in the hatch pattern table
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatchPattern">
            <summary>
Fill definition for a hatch
The hatch  will be one of 
 ON_Hatch::ftLines     - pat file style definition
 ON_Hatch::ftGradient  - uses a color function
 ON_Hatch::ftSolid     - uses entity color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.GetPatternLength">
            <summary>Get the total length of a pattern repeat</summary>
            <returns>Pattern length</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.GetLineData(System.Double@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dVector@,RMA.OpenNURBS.Arraydouble@)">
            <summary>Get the line's angle, base, offset and dashes in one function call</summary>
            <param name="angle">[out] angle in radians CCW from x-axis</param>
            <param name="base">[out] origin of the master line</param>
            <param name="offset">[out] offset for line replications</param>
            <param name="dashes">[out] the dash array for the line</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetPattern(RMA.OpenNURBS.IArraydouble)">
            <summary>Specify a new dash array</summary>
            <param name="dashes">[in] array of dash lengths</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.AppendDash(System.Double)">
            <summary>Add a dash to the pattern</summary>
            <param name="dash">[in] length to append - &lt; 0 for a gap</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Dash(System.Int32)">
            <summary>Get the dash length at index</summary>
            <param name="index">[in] the dash to get</param>
            <returns>the length of the dash ( gap if negative)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.DashCount">
            <summary>Get the number of gaps + dashes in the line</summary>
            <returns>nummber of dashes in the line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetOffset(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Set this line's 2d offset for line repetitions
Offset().x is shift parallel to line
Offset().y is spacing perpendicular to line
</summary>
            <param name="offset">[in] the shift,spacing for repeated lines</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Offset">
            <summary>
Get this line's 2d offset for line repetitions Offset().x is shift parallel
to line Offset().y is spacing perpendicular to line
</summary>
            <returns>the offset</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetBase(RMA.OpenNURBS.IOn2dPoint)">
            <summary>Set this line's 2d basepoint</summary>
            <param name="base">[in] the basepoint</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Base">
            <summary>Get this line's 2d basepoint</summary>
            <returns>the base point</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.SetAngle(System.Double)">
            <summary>Set angle of the hatch line. CCW from x-axis</summary>
            <param name="angle">[in] angle in radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Angle">
            <summary>Get angle of the hatch line. CCW from x-axis</summary>
            <returns>The angle in radians</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
restore definition from binary archive
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
serialize definition to binary archive
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLine.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatchLine">
            <summary>
Represents one line of a hatch pattern
Similar to AutoCAD's .pat file definition
ON_HatchLine's are used by ON_HatchPattern
to specify the dashes and offset patterns of the lines.

Each line has the following information:
Angle is the direction of the line CCW from the x axis
The first line origin is at base
Each line repetition is offset by offset from the previous line
 offset.x is parallel to the line and 
 offset.y is perpendicular to the line
The base and offset values are rotated by the line's angle to 
 produce a location in the hatch pattern's coordinate system
There can be gaps and dashes specified for drawing the line

If there are no dashes, the line is solid
Negative length dashes are gaps
Positive length dashes are drawn as line segments
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.GetPatternLength">
            <summary>Get the total length of a pattern repeat</summary>
            <returns>Pattern length</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.GetLineData(System.Double@,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dVector@,RMA.OpenNURBS.Arraydouble@)">
            <summary>Get the line's angle, base, offset and dashes in one function call</summary>
            <param name="angle">[out] angle in radians CCW from x-axis</param>
            <param name="base">[out] origin of the master line</param>
            <param name="offset">[out] offset for line replications</param>
            <param name="dashes">[out] the dash array for the line</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Dash(System.Int32)">
            <summary>Get the dash length at index</summary>
            <param name="index">[in] the dash to get</param>
            <returns>the length of the dash ( gap if negative)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.DashCount">
            <summary>Get the number of gaps + dashes in the line</summary>
            <returns>nummber of dashes in the line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Offset">
            <summary>
Get this line's 2d offset for line repetitions Offset().x is shift parallel
to line Offset().y is spacing perpendicular to line
</summary>
            <returns>the offset</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Base">
            <summary>Get this line's 2d basepoint</summary>
            <returns>the base point</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Angle">
            <summary>Get angle of the hatch line. CCW from x-axis</summary>
            <returns>The angle in radians</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
serialize definition to binary archive
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLine.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatchLine">
            <summary>
Represents one line of a hatch pattern
Similar to AutoCAD's .pat file definition
ON_HatchLine's are used by ON_HatchPattern
to specify the dashes and offset patterns of the lines.

Each line has the following information:
Angle is the direction of the line CCW from the x axis
The first line origin is at base
Each line repetition is offset by offset from the previous line
 offset.x is parallel to the line and 
 offset.y is perpendicular to the line
The base and offset values are rotated by the line's angle to 
 produce a location in the hatch pattern's coordinate system
There can be gaps and dashes specified for drawing the line

If there are no dashes, the line is solid
Negative length dashes are gaps
Positive length dashes are drawn as line segments
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.SetType(RMA.OpenNURBS.IOnHatchLoop.eLoopType)">
            <summary>Specify the type flag of the loop</summary>
            <param name="type">[in] ltInner or ltOuter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.Type">
            <summary>Get the type flag of the loop</summary>
            <returns>eLoopType::ltInner or eLoopType::ltOuter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.SetCurve(RMA.OpenNURBS.IOnCurve)">
            <summary>Specify the 2d loop curve in the hatch's plane coordinates</summary>
            <param name="curve">[in] 2d input curve</param>
            <returns>true: success, false, curve couldn't be duplicated</returns>
            <remarks>The curve is copied</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.Curve">
            <summary>Get a closed 2d curve boundary loop</summary>
            <returns>Pointer to loop's 2d curve</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnHatchLoop.#ctor">
            <summary>
class ON_HatchLoop
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnHatchLoop">
            <summary>Represents a 3d boundary loop curve</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLoop.Type">
            <summary>Get the type flag of the loop</summary>
            <returns>eLoopType::ltInner or eLoopType::ltOuter</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLoop.Curve">
            <summary>Get a closed 2d curve boundary loop</summary>
            <returns>Pointer to loop's 2d curve</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnHatchLoop.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnHatchLoop">
            <summary>Represents a 3d boundary loop curve</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextDot.m_display">
            <summary>
some future display flags -
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextDot.m_height">
            <summary>
in points
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnTextDot">
            <summary>A simple dot with text that doesn't rotate witn the world axes</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextDot.m_display">
            <summary>
some future display flags -
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextDot.m_height">
            <summary>
in points
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextDot">
            <summary>A simple dot with text that doesn't rotate witn the world axes</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.GetV2Form(RMA.OpenNURBS.OnLeader@)">
            <summary>Converts an ON_Leader2 to the v2 form ON_Leader</summary>
            <param name="leader">[out] - the result of the conversion</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.RemovePoint">
            <summary>Remove point from the leader</summary>
            <returns>
TRUE Success
False Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.RemovePoint(System.Int32)">
            <summary>Remove point from the leader</summary>
            <param name="index">[in] the point to delete</param>
            <returns>
TRUE Success
False Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.AddPoint(RMA.OpenNURBS.IOn2dPoint)">
            <summary>Add point to the leader</summary>
            <param name="point">[in] The point to add</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLeader2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnLeader2">
            <summary>
The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

Leaders:
 Polyline with N=m_points.Count() points (N &gt;= 2).

                 [N-2] ----- [N-1] TEXT
                   /         (tail)
                  /
                 /
       [1]------[2]
       /
      /
     /
   [0] (arrow)

Leaders ignore the m_userpositionedtext setting.  If the
default leader text handling is not adequate, then use
a leader with no text and an ON_TextEntity2.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLeader2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLeader2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnLeader2">
            <summary>
The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

Leaders:
 Polyline with N=m_points.Count() points (N &gt;= 2).

                 [N-2] ----- [N-1] TEXT
                   /         (tail)
                  /
                 /
       [1]------[2]
       /
      /
     /
   [0] (arrow)

Leaders ignore the m_userpositionedtext setting.  If the
default leader text handling is not adequate, then use
a leader with no text and an ON_TextEntity2.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextEntity2.SetFontIndex(System.Int32)">
            <summary>Set the Font index in the Font Table for the text</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextEntity2.FontIndex">
            <summary>Get the Font index in the Font Table for the text</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextEntity2.FontIndex">
            <summary>
Get the Font index in the Font Table for the text
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.CalcKinkPoints(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,System.Int32,System.Double,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>Calculates the 2d point locations of the dimension line kinks</summary>
            <param name="p0">[in] - End points of the dimension line</param>
            <param name="p1">[in] - End points of the dimension line</param>
            <param name="direction">[in] - orientation of the dimension</param>
            <param name="default_offset">[in] - Use this if offsets are ON_UNSET_VALUE</param>
            <param name="k0">[out] - The kink points</param>
            <param name="k1">[out] - The kink points</param>
            <remarks>
The offsets must be set to the right values before calling this,
or If they are ON_UNSET_VALUE, they will be set to the defaults
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.SetKinkOffset(System.Int32,System.Double)">
            <summary>
Set the offset distance parallel to the dimension line direction of from the
text end of the dimension line to the offset point
If the offset point hasn't been explicitly defined, returns ON_UNSET_VALUE
and a default should be used to find the point.
</summary>
            <param name="index">[in] - which offset distance to return (0 is closer to the text)</param>
            <param name="offset">[in] - the offset distance to set</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.KinkOffset(System.Int32)">
            <summary>
Returns the offset distance parallel to the dimension line direction of from the
text end of the dimension line to the offset point
If the offset point hasn't been explicitly defined, returns ON_UNSET_VALUE
and a default should be used to find the point.
</summary>
            <param name="index">[in] - which offset distance to return (0 is closer to the text)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.DefaultText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.SetDirection(System.Int32)">
            <summary>Sets the direction ( X or Y) that the ordinate dimension measures</summary>
            <param name="direction">
-1: direction determined by dim point and leader point
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Direction">
            <summary>Gets the direction ( X or Y) that the ordinate dimension measures</summary>
            <returns>
-1: direction determined by dim point and leader point
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.ImpliedDirection">
            <summary>
Gets the direction ( X or Y) that the ordinate dimension measures
based on the relative location of the defining point and leader endpoint
</summary>
            <returns>
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
            <remarks>This does not consider the dimension's explicit Direction setting</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.SetStyleIndex(System.Int32)">
            <summary>
Set the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim3dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnOrdinateDimension2.Dim2dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnOrdinateDimension2.m_kink_offset_1">
            <summary>
from first break point to second break point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnOrdinateDimension2.m_kink_offset_0">
            <summary>
from leader_end_point to first break point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnOrdinateDimension2.m_direction">
            <summary>
-1 == underermined
0 == x direction
1 == y direction
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnOrdinateDimension2">
            <summary>
In the picture below, [n] means ON_Annotation2::m_points[n].
Measures in X direction

                     [1]
                      |
                      |
                      |
                      |
                      |
                     [0]
     +
[plane origin]                                      [plane origin]
                                                         +

    or - Measures in Y direction                                                   *---[1]       
                                                                                  /
                                                                                 /
                 [0]--------------------[1]                   [0]---------------*


                                                                            * = calculated, not stored


     +     
[plane origin]


The reference point of for the dimension is at the entity plane origin
The "x" and "y" coordinates of [1] can be any value.
The "x" and "y" coordinates of [2] can be any value.
If Direction is "x", the dimension measures along the "x" axis
If Direction is "y", the dimension measures along the "y" axis
If Direction is "x" and [1][x] &lt;&gt; [0][x], an offset segment is drawn
If Direction is "y" and [1][y] &lt;&gt; [0][y], an offset segment is drawn
The dimension lines are always drawn in the X or Y directions of the entity plane
The distance represented by the dimension is measured from the 
 plane origin to point [0], parallel to the appropriate axis.
The points of the offset segment are calculated rather than stored
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.CalcKinkPoints(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,System.Int32,System.Double,RMA.OpenNURBS.On2dPoint@,RMA.OpenNURBS.On2dPoint@)">
            <summary>Calculates the 2d point locations of the dimension line kinks</summary>
            <param name="p0">[in] - End points of the dimension line</param>
            <param name="p1">[in] - End points of the dimension line</param>
            <param name="direction">[in] - orientation of the dimension</param>
            <param name="default_offset">[in] - Use this if offsets are ON_UNSET_VALUE</param>
            <param name="k0">[out] - The kink points</param>
            <param name="k1">[out] - The kink points</param>
            <remarks>
The offsets must be set to the right values before calling this,
or If they are ON_UNSET_VALUE, they will be set to the defaults
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.KinkOffset(System.Int32)">
            <summary>
Returns the offset distance parallel to the dimension line direction of from the
text end of the dimension line to the offset point
If the offset point hasn't been explicitly defined, returns ON_UNSET_VALUE
and a default should be used to find the point.
</summary>
            <param name="index">[in] - which offset distance to return (0 is closer to the text)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Direction">
            <summary>Gets the direction ( X or Y) that the ordinate dimension measures</summary>
            <returns>
-1: direction determined by dim point and leader point
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.ImpliedDirection">
            <summary>
Gets the direction ( X or Y) that the ordinate dimension measures
based on the relative location of the defining point and leader endpoint
</summary>
            <returns>
0: measures parallel to the entity plane x axis
1: measures parallel to the entity plane y axis
</returns>
            <remarks>This does not consider the dimension's explicit Direction setting</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim3dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnOrdinateDimension2.Dim2dPoint(System.Int32,System.Double)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <param name="default_offset">[in] - kink offset to use if m_kink_offset_0 or m_kink_offset_1 are ON_UNSET_VALUE</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnOrdinateDimension2.m_kink_offset_1">
            <summary>
from first break point to second break point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnOrdinateDimension2.m_kink_offset_0">
            <summary>
from leader_end_point to first break point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnOrdinateDimension2.m_direction">
            <summary>
-1 == underermined
0 == x direction
1 == y direction
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnOrdinateDimension2">
            <summary>
In the picture below, [n] means ON_Annotation2::m_points[n].
Measures in X direction

                     [1]
                      |
                      |
                      |
                      |
                      |
                     [0]
     +
[plane origin]                                      [plane origin]
                                                         +

    or - Measures in Y direction                                                   *---[1]       
                                                                                  /
                                                                                 /
                 [0]--------------------[1]                   [0]---------------*


                                                                            * = calculated, not stored


     +     
[plane origin]


The reference point of for the dimension is at the entity plane origin
The "x" and "y" coordinates of [1] can be any value.
The "x" and "y" coordinates of [2] can be any value.
If Direction is "x", the dimension measures along the "x" axis
If Direction is "y", the dimension measures along the "y" axis
If Direction is "x" and [1][x] &lt;&gt; [0][x], an offset segment is drawn
If Direction is "y" and [1][y] &lt;&gt; [0][y], an offset segment is drawn
The dimension lines are always drawn in the X or Y directions of the entity plane
The distance represented by the dimension is measured from the 
 plane origin to point [0], parallel to the appropriate axis.
The points of the offset segment are calculated rather than stored
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.GetDimensionArcSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>Get the annotation plane angles of the dimension arc.</summary>
            <param name="gdi_text_rect">[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="a">[out] angles at the ends of the arc segment(s) and the arrow tips</param>
            <param name="bInside">[out] true if arrowheads go inside, false if they go outside</param>
            <returns>
number of arc segments to draw
0: the input or class is not valid
1: A single arc from a[0] to a[1] with arrow heads at a[4] &amp; a[5].
2: Two arcs from a[0] to a[1] &amp; from a[2] to a[3]. Arrowheads are at a[4] &amp; a[5].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.ConvertBack(RMA.OpenNURBS.OnAngularDimension2@)">
            <summary>Convert back to the version of ON_Annotation used in Rhino 2</summary>
            <param name="target">[out] the old-style object</param>
            <returns>
TRUE Success
False Failure
See Also: ON_AnnotationObject::ConvertBack()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.DefaultText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.SetStyleIndex(System.Int32)">
            <summary>
Set the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.Angle">
            <summary>
Get the measured angle in radians
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.SetAngle(System.Double)">
            <summary>
Set the measured angle in radians
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.CreateFromArc(RMA.OpenNURBS.IOnArc)">
            <summary>Set the plane and definition points from a 3d arc.</summary>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Set the plane and definition points from 3d points in world coordinates.</summary>
            <param name="apex">[in] 3d apex of the dimension (center of arc)</param>
            <param name="p0">[in] 3d point on first line</param>
            <param name="p1">[in] 3d point on second line</param>
            <param name="arcpt">[in] 3d point on dimension arc (determines radius of arc)</param>
            <param name="Normal">[in] normal of the plane on which to make the dimension (must be perpendicular to p0-apex and p1-apex)</param>
            <returns>
TRUE Success 
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAngularDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnAngularDimension2.m_radius">
            <summary>
radius for dimension arc
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAngularDimension2.m_angle">
            <summary>
angle being dimensioned
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnAngularDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].

[0] = if m_userpositionedtext=true, this is the center of text.
     If m_userpositionedtext=false, this point is not used and
     the center of the text is at the arc's midpoint.

Always counter clockwise arc in m_plane with center = (0,0)
[1] = a point somewhere on the line from the center through the start point.
     The distance from center to [1] can be any value.
[2] = a point somewhere on the line from the center through the end point.
     The distance from center to [2] can be any value.
[3] = a point on the interior of the arc.  The distance 
     from (0,0) to [3] is the radius of the arc.

             /
           [2]
           /
          /         [0]TEXT
         /
        /    [3]
-----(0,0)----------[1]---
      /
     /
    /
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.GetDimensionArcSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>Get the annotation plane angles of the dimension arc.</summary>
            <param name="gdi_text_rect">[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="a">[out] angles at the ends of the arc segment(s) and the arrow tips</param>
            <param name="bInside">[out] true if arrowheads go inside, false if they go outside</param>
            <returns>
number of arc segments to draw
0: the input or class is not valid
1: A single arc from a[0] to a[1] with arrow heads at a[4] &amp; a[5].
2: Two arcs from a[0] to a[1] &amp; from a[2] to a[3]. Arrowheads are at a[4] &amp; a[5].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.Angle">
            <summary>
Get the measured angle in radians
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAngularDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAngularDimension2.m_radius">
            <summary>
radius for dimension arc
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAngularDimension2.m_angle">
            <summary>
angle being dimensioned
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAngularDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].

[0] = if m_userpositionedtext=true, this is the center of text.
     If m_userpositionedtext=false, this point is not used and
     the center of the text is at the arc's midpoint.

Always counter clockwise arc in m_plane with center = (0,0)
[1] = a point somewhere on the line from the center through the start point.
     The distance from center to [1] can be any value.
[2] = a point somewhere on the line from the center through the end point.
     The distance from center to [2] can be any value.
[3] = a point on the interior of the arc.  The distance 
     from (0,0) to [3] is the radius of the arc.

             /
           [2]
           /
          /         [0]TEXT
         /
        /    [3]
-----(0,0)----------[1]---
      /
     /
    /
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.DefaultDiameterText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.SetStyleIndex(System.Int32)">
            <summary>
Set the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,System.Double)">
            <summary>Set the plane and definition points from WCS 3d input</summary>
            <param name="center">[in] center of circle</param>
            <param name="arrowtip">[in] 3d point on the circle at the dimension arrow tip</param>
            <param name="xaxis">[in] x axis of the dimension's plane</param>
            <param name="normal">[in] normal to the dimension's plane</param>
            <param name="offset_distance">[in] distance from arrow tip to knee point</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRadialDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnRadialDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
and the size of the arrowheads.

In the picture below, [n] means ON_Annotation2::m_points[n].

Radial dimensions do not permit user positioned text

      knee
       [3]--------[2] TEXT
       /         (tail)
      /
     /
   [1] (arrow head here)

+ [0] = (usually at (0,0) = center of circle)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRadialDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRadialDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRadialDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnRadialDimension2">
            <summary>
The annotation dimstyle controls the position of TEXT,
and the size of the arrowheads.

In the picture below, [n] means ON_Annotation2::m_points[n].

Radial dimensions do not permit user positioned text

      knee
       [3]--------[2] TEXT
       /         (tail)
      /
     /
   [1] (arrow head here)

+ [0] = (usually at (0,0) = center of circle)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.GetDimensionLineSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>
Get the annotation plane x coordinates of the dimension line.
The y coordinate of the dimension line is m_ponts[1].y.
</summary>
            <param name="gdi_text_rect">
[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.
The baseline of the text should be at y=0 in the rect coordinates.
</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text in the same.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="bInside">
[out] true if arrowheads go inside extension lines, false if they go outside
</param>
            <returns>
0: the input or class is not valid
1: A single line from x[0] to x[1] with arrow heads at both ends. Arrowtips at x[4] &amp; x[5]
2: Two lines from x[0] to x[1] and from x[1] to x[2]. The Arrowtips at x[4] &amp; x[5]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.DefaultText">
            <summary>
static function to provide the default UserText string for the object. Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.SetStyleIndex(System.Int32)">
            <summary>Set the DimStyle index in the dimstyle table for the dimension</summary>
            <param name="arg1">[in] the new index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinearDimension2.Repair">
            <summary>
Checks the linear dimension and repairs any point locations or flags that are not set correctly.
</summary>
            <returns>
0: linear dimension is damaged beyond repair
1: linear dimension was perfect and nothing needed to be repaired.
2: linear dimension had flaws that were repaired.
</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnLinearDimension2">
            <summary>
Subclass of ON_Annotation2 to provide linear dimensions

The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].
                                                [2]
                                                 |
   |                                             |
  [1]-------------------------------------------[3]
   |                                             |
   |                       TEXT
   |                       [4]
  [0]

The x and y coordinates of [0] can be any value.

The x coordinate of [1] = x of [0]
The y coordinate of [1] can be any value.

The x coordinate of [1] = x coordinate of 0.0;
The y coordinate of [1] can be any value.

The x and y coordinates of [2] can be any value.

The x coordinate of [3] = x coordinate of [2].
The y coordinate of [3] = y coordinate of [1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.GetDimensionLineSegments(System.Drawing.Rectangle,System.Int32,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,System.Double[],System.Boolean@)">
            <summary>
Get the annotation plane x coordinates of the dimension line.
The y coordinate of the dimension line is m_ponts[1].y.
</summary>
            <param name="gdi_text_rect">
[in] Windows rect (left &lt; right, top &lt; bottom) that bounds text.
The baseline of the text should be at y=0 in the rect coordinates.
</param>
            <param name="gdi_height_of_I">[in] Height of an I in the text in the same.</param>
            <param name="gdi_to_world">[in] transform returned by ON_Annotation2::GetTextXform().</param>
            <param name="bInside">
[out] true if arrowheads go inside extension lines, false if they go outside
</param>
            <returns>
0: the input or class is not valid
1: A single line from x[0] to x[1] with arrow heads at both ends. Arrowtips at x[4] &amp; x[5]
2: Two lines from x[0] to x[1] and from x[1] to x[2]. The Arrowtips at x[4] &amp; x[5]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.StyleIndex">
            <summary>
Get the DimStyle index in the dimstyle table for the dimension
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.Dim3dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinearDimension2.Dim2dPoint(System.Int32)">
            <summary>Get the m_plane coordinates of the dimension point.</summary>
            <param name="point_index">[in] One of the POINT_INDEX enum values</param>
            <returns>2d point or ON_UNSET_POINT if point_index or m_points[] array is not valid.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnLinearDimension2">
            <summary>
Subclass of ON_Annotation2 to provide linear dimensions

The annotation's dimstyle controls the position of TEXT,
the size of the arrowheads, and the amount the ends of 
linear dimension's extension lines extend beyond the 
dimension lines.

In the picture below, [n] means ON_Annotation2::m_points[n].
                                                [2]
                                                 |
   |                                             |
  [1]-------------------------------------------[3]
   |                                             |
   |                       TEXT
   |                       [4]
  [0]

The x and y coordinates of [0] can be any value.

The x coordinate of [1] = x of [0]
The y coordinate of [1] can be any value.

The x coordinate of [1] = x coordinate of 0.0;
The y coordinate of [1] can be any value.

The x and y coordinates of [2] can be any value.

The x coordinate of [3] = x coordinate of [2].
The y coordinate of [3] = y coordinate of [1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetTextPoint(RMA.OpenNURBS.On2dPoint@)">
            <summary>
Get the annotation plane coordinates (ECS) of the point that is used to position the text.
The relative position of the text to this points depends on the type of annotation,
the dimstyle's text alignment flag, and the view projection.
This point is not the same as the base point of the text.
</summary>
            <returns>True if text_point is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetTextXform(System.Drawing.Rectangle,RMA.OpenNURBS.IOnFont,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>Get the transformation that maps the annotation's text to world coordinates.</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetTextXform(System.Drawing.Rectangle,System.Int32,System.Double,System.Double,RMA.OpenNURBS.IOn.eTextDisplayMode,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnXform@)">
            <summary>
Get the transformation that maps the annotation's text to world coordinates.
</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with
LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="gdi_height_of_I">[in] Value returned by ON_Font::HeightOfI().</param>
            <param name="dimstyle_textheight">
[in] Height of text in world units.
If the annotation is an ON_TextEntity2, this is the m_textheight value.
If the annotation is not an ON_TextEntity2, pass in the value returned
by the dimension style's ON_DimStyle::TextHeight()
</param>
            <param name="dimstyle_textgap">
[in] The value of the annotation's dimension style's ON_DimStyle::TextGap().
</param>
            <param name="dimstyle_textalignment">[in] ON::TextDisplayMode(ON_DimStyle::TextAlignment()).</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is
returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <param name="cameraX">[in] zero or the view's unit camera right vector</param>
            <param name="cameraY">[in] zero or the view's unit camera up vector</param>
            <param name="xform">[out]</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Justification">
            <summary>Get the text justification</summary>
            <returns>The justification for the text in this object</returns>
            <remarks>
This is not implemented on all annotation objects.
The default SetJustification() does nothing The default Justification() always returns 0
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetJustification(System.UInt32)">
            <summary>Set the text justification</summary>
            <param name="justification">[in] See enum eJustification for meanings</param>
            <remarks>
This is not implemented on all annotation objects.
The default SetJustification() does nothing The default Justification() always returns 0
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.ConvertBack(RMA.OpenNURBS.OnAnnotation@)">
            <summary>Convert back to the version of ON_Annotation used in Rhino 2</summary>
            <param name="target">[out] the old-style object</param>
            <returns>
TRUE Success
False Failure
See Also: ON_AngularDimension::ConvertBack()
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.DefaultText">
            <summary>
static function to provide the default UserText string for the object Returns the default string to use
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.ReservePoints(System.Int32)">
            <summary>Set the object's point array to a specified length</summary>
            <param name="length">[in] the new size of the array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from to 3d WCS to the object's 2d ECS
</summary>
            <param name="xform">set to produce the WCS to ECS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from the object's 2d ECS to 3d WCS
</summary>
            <param name="arg1">[out] xform set to produce the ECS to WCS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.TextDisplayMode">
            <remarks>
This is the way the text is oriented with respect to the dimension line or screen:
Above line, In LIne, Horizontal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetTextDisplayMode(RMA.OpenNURBS.IOn.eTextDisplayMode)">
            <summary>Set the text display mode for the annotation</summary>
            <remarks>
This is the way the text is oriented with respect to the dimension line or screen:
Above line, In LIne, Horizontal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.UserPositionedText">
            <summary>
get a flag indication that the dimension text has been moved
from the default location.
</summary>
            <returns>
TRUE    The text has been moved
FALSE   The text is in the default location
</returns>
            <remarks>
If the text is in the default location, it should be repositioned
automatically when the dimension is adjusted.
If it has been moved, it should not be automatically positioned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetUserPositionedText(System.Boolean)">
            <summary>
set a flag indication that the dimension text has been moved
from the default location.
</summary>
            <param name="bUserPositionedText">
TRUE to indicate that the text has been placed by the user.
FALSE to indicate that it hasn't
</param>
            <remarks>
If the text is in the default location, it should be repositioned
automatically when the dimension is adjusted.
If it has been moved, it should not be automatically positioned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.UserText">
            <summary>get the string value of the user text, with no substitution for "&lt;&gt;"</summary>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the DimStyle settings.
"&lt;&gt;" is the default for linear dimensions.
Other dimensions include "&lt;&gt;" in their default string
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetUserText(System.String)">
            <summary>set the string value of the user text, with no substitution for "&lt;&gt;"</summary>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the DimStyle settings.
"&lt;&gt;" is the default for linear dimensions.
Other dimensions include "&lt;&gt;" in their default string
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Point(System.Int32)">
            <summary>Get individual definition point for the annotation</summary>
            <param name="index">[in] index of the point to set in ECS 2d coordinates</param>
            <returns>the point coordinates in ECS</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetPoint(System.Int32,RMA.OpenNURBS.IOn2dPoint)">
            <summary>Set individual definition point for the annotation</summary>
            <param name="index">[in] index of the point to set in ECS 2d coordinates</param>
            <param name="pt">[in] the new point value</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Points">
            <summary>get the object's whole points array at once</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetPoints(RMA.OpenNURBS.IOn2dPointArray)">
            <summary>set the object's whole points array at once</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.PointCount">
            <summary>Returns the number of definition points this object has</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Plane">
            <summary>get the plane for the object's ECS</summary>
            <returns>the object's ECS plane in WCS coords</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>set the plane for the object's ECS</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Type">
            <summary>
gets the object type member to a specific annotation type:
dtDimLinear, dtDimAligned, dtDimAngular, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetType(RMA.OpenNURBS.IOn.eAnnotationType)">
            <summary>
sets the object type member to a specific annotation type:
dtDimLinear, dtDimAligned, dtDimAngular, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Height">
            <summary>Get the height of the text in this annotation</summary>
            <remarks>Height is in model units</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetHeight(System.Double)">
            <summary>Set the height of the text in this annotation</summary>
            <param name="arg1">[in] double new text height to set</param>
            <remarks>Height is in model units</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.NumericValue">
            <returns>
Dimension type
Linear dim:  distance between arrow tips
Radial dim:  radius or diameter depending on m_type value
Angular dim: angle in degrees
Leader:      ON_UNSET_VALUE
Text:        ON_UNSET_VALUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.SetIndex(System.Int32)">
            <summary>
Set the index in the appropriate table for either the font or dimstyle of this object
</summary>
            <param name="arg1">[in] int the new index</param>
            <remarks>
If the object is a text object the index is of object's font in the Font Table
If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Index">
            <summary>get the index in the appropriate table for either the font or dimstyle of this object</summary>
            <remarks>
If the object is a text object the index is of object's font in the Font Table
If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.IsDimension">
            <summary>Query if the annotation object is a dimension</summary>
            <returns>
TRUE It is a dimension
FALSE Its not a dimension
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.IsLeader">
            <summary>Query if the annotation object is a leader</summary>
            <returns>
TRUE It is a leader
FALSE Its not a leader
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.IsText">
            <summary>Query if the annotation object is a text object</summary>
            <returns>
TRUE It is text
FALSE Its not text
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation2.Create">
            <summary>
convert from old style annotation
</summary>
            <summary>
Sets initial defaults
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_justification">
            <summary>
Left, Center, Right / Bottom, Middle, Top text justification
See eTextJustification above
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_textheight">
            <summary>
Text height in model units
This is used by text, but not by dimensions
Dimensions get their height from dimension styles
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_index">
            <summary>
For dimensions, this is the ON_DimStyle index
For text, its the ON_Font index
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_userpositionedtext">
            <summary>
TRUE: User has positioned text
FALSE: use default location
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_usertext">
            <summary>
"&lt;&gt;", or user override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_points">
            <summary>
Definition points for the dimension.
These are 2d coordinates in m_plane.
The location of these points depends on the
type of annotation class.  There is a comment
at the start of the definions for
ON_LinearDimension2, ON_RadialDimension2,
ON_AngularDimension2, ON_TextEntity2, and
ON_Leader2 that explains how the points are used.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_plane">
            <summary>
m_plane is the plane containing the annotation.
All parts of the annotation that are not
text lie in this plane. If
m_textdisplaymode != dtHorizontal, then
the text lies in the plane too.  
(ECS reference plane in WCS coordinates.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_textdisplaymode">
            <summary>
m_textdisplaymode controls the orientation
of the text.
If m_textdisplaymode = dtHorizontal, then
the text is always horizontal and in the
view plane.  Otherwise it lies in m_plane.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2.m_type">
            <summary>
enum for tyoe of annotation DimLinear, DimRadius, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetTextPoint(RMA.OpenNURBS.On2dPoint@)">
            <summary>
Get the annotation plane coordinates (ECS) of the point that is used to position the text.
The relative position of the text to this points depends on the type of annotation,
the dimstyle's text alignment flag, and the view projection.
This point is not the same as the base point of the text.
</summary>
            <returns>True if text_point is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetTextXform(System.Drawing.Rectangle,RMA.OpenNURBS.IOnFont,RMA.OpenNURBS.IOnDimStyle,System.Double,RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.OnXform@)">
            <summary>Get the transformation that maps the annotation's text to world coordinates.</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetTextXform(System.Drawing.Rectangle,System.Int32,System.Double,System.Double,RMA.OpenNURBS.IOn.eTextDisplayMode,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnXform@)">
            <summary>
Get the transformation that maps the annotation's text to world coordinates.
</summary>
            <param name="gdi_text_rect">
[in] Windows gdi rect of text when it is drawn with
LOGFONT lfHeight = ON_Font::normal_font_height.
</param>
            <param name="gdi_height_of_I">[in] Value returned by ON_Font::HeightOfI().</param>
            <param name="dimstyle_textheight">
[in] Height of text in world units.
If the annotation is an ON_TextEntity2, this is the m_textheight value.
If the annotation is not an ON_TextEntity2, pass in the value returned
by the dimension style's ON_DimStyle::TextHeight()
</param>
            <param name="dimstyle_textgap">
[in] The value of the annotation's dimension style's ON_DimStyle::TextGap().
</param>
            <param name="dimstyle_textalignment">[in] ON::TextDisplayMode(ON_DimStyle::TextAlignment()).</param>
            <param name="dimscale">
[in] Global dimension scaling value. If you are using the Rhino SDK, this value is
returned by CRhinoDoc::Properties().AnnotationSettings().DimScale().
</param>
            <param name="cameraX">[in] zero or the view's unit camera right vector</param>
            <param name="cameraY">[in] zero or the view's unit camera up vector</param>
            <param name="xform">[out]</param>
            <returns>True if xform is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from to 3d WCS to the object's 2d ECS
</summary>
            <param name="xform">set to produce the WCS to ECS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Gets a transform matrix to change from the object's 2d ECS to 3d WCS
</summary>
            <param name="arg1">[out] xform set to produce the ECS to WCS transform</param>
            <returns>
TRUE Success
FALSE Failure
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.TextDisplayMode">
            <remarks>
This is the way the text is oriented with respect to the dimension line or screen:
Above line, In LIne, Horizontal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.UserPositionedText">
            <summary>
get a flag indication that the dimension text has been moved
from the default location.
</summary>
            <returns>
TRUE    The text has been moved
FALSE   The text is in the default location
</returns>
            <remarks>
If the text is in the default location, it should be repositioned
automatically when the dimension is adjusted.
If it has been moved, it should not be automatically positioned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.UserText">
            <summary>get the string value of the user text, with no substitution for "&lt;&gt;"</summary>
            <remarks>
UserText is the string that gets printed when the dimensoin is drawn.
If it contains the token "&lt;&gt;", that token is replaced
with the measured value for the dimension, formatted according to the DimStyle settings.
"&lt;&gt;" is the default for linear dimensions.
Other dimensions include "&lt;&gt;" in their default string
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Point(System.Int32)">
            <summary>Get individual definition point for the annotation</summary>
            <param name="index">[in] index of the point to set in ECS 2d coordinates</param>
            <returns>the point coordinates in ECS</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Points">
            <summary>get the object's whole points array at once</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.PointCount">
            <summary>Returns the number of definition points this object has</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Plane">
            <summary>get the plane for the object's ECS</summary>
            <returns>the object's ECS plane in WCS coords</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Type">
            <summary>
gets the object type member to a specific annotation type:
dtDimLinear, dtDimAligned, dtDimAngular, etc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Height">
            <summary>Get the height of the text in this annotation</summary>
            <remarks>Height is in model units</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.NumericValue">
            <returns>
Dimension type
Linear dim:  distance between arrow tips
Radial dim:  radius or diameter depending on m_type value
Angular dim: angle in degrees
Leader:      ON_UNSET_VALUE
Text:        ON_UNSET_VALUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.Index">
            <summary>get the index in the appropriate table for either the font or dimstyle of this object</summary>
            <remarks>
If the object is a text object the index is of object's font in the Font Table
If the object is anything else, the index is of the object's dimstyle in the DimStyle Table
Derived objects can use FontIndex() and StyleIndex() to set/get these same values.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.IsDimension">
            <summary>Query if the annotation object is a dimension</summary>
            <returns>
TRUE It is a dimension
FALSE Its not a dimension
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.IsLeader">
            <summary>Query if the annotation object is a leader</summary>
            <returns>
TRUE It is a leader
FALSE Its not a leader
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation2.IsText">
            <summary>Query if the annotation object is a text object</summary>
            <returns>
TRUE It is text
FALSE Its not text
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_justification">
            <summary>
Left, Center, Right / Bottom, Middle, Top text justification
See eTextJustification above
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_textheight">
            <summary>
Text height in model units
This is used by text, but not by dimensions
Dimensions get their height from dimension styles
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_index">
            <summary>
For dimensions, this is the ON_DimStyle index
For text, its the ON_Font index
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_userpositionedtext">
            <summary>
TRUE: User has positioned text
FALSE: use default location
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_usertext">
            <summary>
"&lt;&gt;", or user override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_points">
            <summary>
Definition points for the dimension.
These are 2d coordinates in m_plane.
The location of these points depends on the
type of annotation class.  There is a comment
at the start of the definions for
ON_LinearDimension2, ON_RadialDimension2,
ON_AngularDimension2, ON_TextEntity2, and
ON_Leader2 that explains how the points are used.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_plane">
            <summary>
m_plane is the plane containing the annotation.
All parts of the annotation that are not
text lie in this plane. If
m_textdisplaymode != dtHorizontal, then
the text lies in the plane too.  
(ECS reference plane in WCS coordinates.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_textdisplaymode">
            <summary>
m_textdisplaymode controls the orientation
of the text.
If m_textdisplaymode = dtHorizontal, then
the text is always horizontal and in the
view plane.  Otherwise it lies in m_plane.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2.m_type">
            <summary>
enum for tyoe of annotation DimLinear, DimRadius, etc.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation2Text.m_rect">
            <summary>
m_rect is a Windows gdi RECT that bounds text 
("x" increases to the right and "y" increases downwards).
If all fields are 0, then m_rect is not set.
If left &lt; right and top &lt; bottom, then the rect bounds 
the text when it is drawn with its font's 
lfHeight=ON_Font::normal_font_height and (0,0) left baseline
point of the leftmost character on the first line
of text. If (x,y) is a point on the drawn text, then
left &lt;= x &lt; right and top &lt;= y &lt; bottom.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation2Text.m_rect">
            <summary>
m_rect is a Windows gdi RECT that bounds text 
("x" increases to the right and "y" increases downwards).
If all fields are 0, then m_rect is not set.
If left &lt; right and top &lt; bottom, then the rect bounds 
the text when it is drawn with its font's 
lfHeight=ON_Font::normal_font_height and (0,0) left baseline
point of the leftmost character on the first line
of text. If (x,y) is a point on the drawn text, then
left &lt;= x &lt; right and top &lt;= y &lt; bottom.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.GeWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Converts from WCS 3d points to 2d points in annotation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
to convert world 3d points to and from annotation 2d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.Destroy">
            <summary>
memory is uninitialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnAnnotation.Create">
            <summary>
initialize class's fields assuming memory is uninitialized
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_userpositionedtext">
            <summary>
TRUE: User has positioned text
FALSE: use default location
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_defaulttext">
            <summary>
The displayed text string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_usertext">
            <summary>
"&lt;&gt;", or user override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_points">
            <summary>
Definition points for the dimension
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_plane">
            <summary>
ECS reference plane in WCS coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_textdisplaymode">
            <summary>
how the text is displayed
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnAnnotation.m_type">
            <summary>
enum for type of annotation
DimLinear, DimRadius, etc.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnAnnotation">
            <summary>
used to serialize definitions of annotation
objects (dimensions, text blocks, etc.).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation.GeWCStoECSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
Converts from WCS 3d points to 2d points in annotation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnAnnotation.GetECStoWCSXform(RMA.OpenNURBS.OnXform@)">
            <summary>
to convert world 3d points to and from annotation 2d points
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_userpositionedtext">
            <summary>
TRUE: User has positioned text
FALSE: use default location
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_defaulttext">
            <summary>
The displayed text string
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_usertext">
            <summary>
"&lt;&gt;", or user override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_points">
            <summary>
Definition points for the dimension
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_plane">
            <summary>
ECS reference plane in WCS coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_textdisplaymode">
            <summary>
how the text is displayed
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnAnnotation.m_type">
            <summary>
enum for type of annotation
DimLinear, DimRadius, etc.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAnnotation">
            <summary>
used to serialize definitions of annotation
objects (dimensions, text blocks, etc.).
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnAnnotationArrow">
            <summary>3d annotation arrow</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAnnotationArrow">
            <summary>3d annotation arrow</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnAnnotationTextDot">
            <summary>
3d annotation dot with text
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnAnnotationTextDot">
            <summary>
3d annotation dot with text
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.DisplayMaterialRefCount">
            <summary>
Returns: Number of diplay material refences.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveAllDisplayMaterialRefs">
            <summary>
Remove the entire display material reference list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveDisplayMaterialRef(System.Guid)">
            <summary>
Remove a display material reference from the list. Parameters: viewport_id - [in] Any display material references with this viewport id will be removed. If nil, then viewport_id is ignored. display_material_id - [in] Any display material references that match the viewport_id and have this display_material_id will be removed. If nil, then display_material_id is ignored. Returns: True if a display material reference was removed. See Also: ON_3dmObjectAttributes::FindDisplayMaterialRef ON_3dmObjectAttributes::AddDisplayMaterialRef
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveDisplayMaterialRef(System.Guid,System.Guid)">
            <summary>
Remove a display material reference from the list. Parameters: viewport_id - [in] Any display material references with this viewport id will be removed. If nil, then viewport_id is ignored. display_material_id - [in] Any display material references that match the viewport_id and have this display_material_id will be removed. If nil, then display_material_id is ignored. Returns: True if a display material reference was removed. See Also: ON_3dmObjectAttributes::FindDisplayMaterialRef ON_3dmObjectAttributes::AddDisplayMaterialRef
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.AddDisplayMaterialRef(RMA.OpenNURBS.IOnDisplayMaterialRef)">
            <summary>
Add a display material reference to the attributes. If there is an existing entry
with a matching viewport id, the existing entry is replaced.
</summary>
            <param name="display_material">[in]</param>
            <returns>True if input is valid (material id != nil)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.FindDisplayMaterialId(System.Guid,System.Guid@)">
            <summary>Quick way to see if a viewport has a special material.</summary>
            <param name="viewport_id">[in]</param>
            <param name="display_material_id">[out]</param>
            <returns>True if a material_id is assigned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.FindDisplayMaterialRef(RMA.OpenNURBS.IOnDisplayMaterialRef,RMA.OpenNURBS.OnDisplayMaterialRef)">
            <summary>
Searches for a matching display material. For a given viewport id, there is at most one display material.
For a given display material id, there can be multiple viewports.  If there is a display reference in the
list with a nil viewport id, then the display material will be used in all viewports that are not explictly
referenced in other ON_DisplayMaterialRefs.
</summary>
            <param name="search_material">[in]</param>
            <param name="found_material">
[out] optional, may be NULL
If FindDisplayMaterialRef(), the input value of search_material is never changed.
If FindDisplayMaterialRef() returns true, the chart shows the output value of display_material.
When there are multiple possibilities for a match, the matches at the top of the chart have
higher priority.

search_material  found_material
input value      output value
(nil,nil)        (nil,did) if (nil,did) is in the list.
(nil,did)        (vid,did) if (vid,did) is in the list.
(nil,did)        (nil,did) if (nil,did) is in the list.
(vid,nil)        (vid,did) if (vid,did) is in the list
(vid,nil)        (vid,did) if (nil,did) is in the list
(vid,did)        (vid,did) if (vid,did) is in the list.
</param>
            <returns>True if a matching display material is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveFromAllGroups">
            <summary>
Removes object from all groups.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveFromTopGroup">
            <summary>
removes the object from the last group in the group list
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.RemoveFromGroup(System.Int32)">
            <summary>
Removes object from the group with specified index.  If the 
object is not in the group, nothing is changed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.AddToGroup(System.Int32)">
            <summary>
Adds object to the group with specified index by appending index to
group list (If the object is already in group, nothing is changed.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsInGroups(RMA.OpenNURBS.IArrayint)">
            <summary>
Returns TRUE if object is in any of the groups in the list
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsInGroup(System.Int32)">
            <summary>Returns TRUE if object is in group with the specified index</summary>
            <param name="groupId">the group index that we are checking for</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.TopGroup">
            <summary>
Returns the index of the last group in the group list
or -1 if the object is not in any groups
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.GetGroupList(RMA.OpenNURBS.Arrayint@)">
            <summary>
Returns and array an array of GroupCount() zero based 
group indices.  If GroupCount() is zero, then GroupList()
returns NULL.
</summary>
            <summary>
Returns GroupCount() and puts a list of zero based group indices 
into the array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.GroupCount">
            <summary>
group interface
returns number of groups object belongs to
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetMaterialSource(RMA.OpenNURBS.IOn.object_material_source)">
            <summary>
Specifies if the simple material should be the one indicated by the material index or the one indicated by the object's layer. Parameters: ms - [in]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.MaterialSource">
            <summary>
Determine if the simple material should come from the object or from it's layer. High qualigy rendering plug-ins should use m_rendering_attributes. Returns: Where to get material information if you do are too lazy to look in m_rendering_attributes.m_materials[].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.ApplyParentalControl(RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <summary>
If "this" has attributes (color, plot weight, ...) with "by parent" sources,
then the values of those attributes on parent_attributes are copied.
</summary>
            <param name="parent_attributes">[in]</param>
            <returns>
The bits in the returned integer indicate which attributes were actually modified.
1: visibility 2: color 4: render material 8: plot color 0x10: plot weight 0x20: linetype 0x40: display order
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.ApplyParentalControl(RMA.OpenNURBS.IOn3dmObjectAttributes,System.UInt32)">
            <summary>
If "this" has attributes (color, plot weight, ...) with "by parent" sources,
then the values of those attributes on parent_attributes are copied.
</summary>
            <param name="parent_attributes">[in]</param>
            <param name="control_limits">
[in] The bits in control_limits determine which attributes may may be copied.
1: visibility
2: color
4: render material
8: plot color
0x10: plot weight
0x20: linetype
0x40: display order
</param>
            <returns>
The bits in the returned integer indicate which attributes were actually modified.
1: visibility 2: color 4: render material 8: plot color 0x10: plot weight 0x20: linetype 0x40: display order
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetDisplayMode(RMA.OpenNURBS.IOn.display_mode)">
            <summary>
See DisplayMode().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.DisplayMode">
            <summary>
OpenNURBS objects can be displayed in one of three ways: wireframe,
shaded, or render preview.  If the display mode is ON::default_display,
then the display mode of the viewport detrmines how the object
is displayed.  If the display mode is ON::wireframe_display,
ON::shaded_display, or ON::renderpreview_display, then the object is
forced to display in that mode.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetPlotColorSource(RMA.OpenNURBS.IOn.plot_color_source)">
            <summary>
See PlotColorSource().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.PlotColorSource">
            <summary>
The color used to plot an OpenNURBS object on paper is specified 
in one of three ways.
If PlotColorSource() is ON::plot_color_from_layer, then the object's layer 
ON_Layer::PlotColor() is used.
If PlotColorSource() is ON::plot_color_from_object, then value of PlotColor() is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetColorSource(RMA.OpenNURBS.IOn.object_color_source)">
            <summary>
See ColorSource().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.ColorSource">
            <summary>
The color used to display an OpenNURBS object is specified in one of three ways.
If ColorSource() is ON::color_from_layer, then the object's layer 
ON_Layer::Color() is used.
If ColorSource() is ON::color_from_object, then value of m_color is used.
If ColorSource() is ON::color_from_material, then the diffuse color of the object's
render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
determine where to get the definition of the object's render material.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetLinetypeSource(RMA.OpenNURBS.IOn.object_linetype_source)">
            <summary>
See LinetypeSource().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.LinetypeSource">
            <summary>
The Linetype used to display an OpenNURBS object is specified in one of two ways.
If LinetypeSource() is ON::linetype_from_layer, then the object's layer 
ON_Layer::Linetype() is used.
If LinetypeSource() is ON::linetype_from_object, then value of m_linetype is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetVisible(System.Boolean)">
            <summary>Controls object visibility</summary>
            <param name="bVisible">[in] true to make object visible, false to make object invisible</param>
            <remarks>See Also: ON_3dmObjectAttributes::IsVisible</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsVisible">
            <summary>
Returns: Returns true if object is visible. See Also: ON_3dmObjectAttributes::SetVisible
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.IsInstanceDefinitionObject">
            <summary>
Use this query to determine if an object is part of an instance definition.
</summary>
            <returns>True if the object is part of an instance definition.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.SetMode(RMA.OpenNURBS.IOn.object_mode)">
            <summary>
See Mode().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.Mode">
            <summary>
An OpenNURBS object must be in one of three modes: normal, locked
or hidden.  If an object is in normal mode, then the object's layer
controls visibility and selectability.  If an object is locked, then
the object's layer controls visibility by the object cannot be selected.
If the object is hidden, it is not visible and it cannot be selected.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.Default">
            <summary>
Initializes all attributes to the default values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmObjectAttributes.Transform(RMA.OpenNURBS.IOnXform)">
            <returns>True if successful. (xform is invertable or didn't need to be).</returns>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_space">
            <summary>
Starting with V4, objects can be in either model space
or page space.  If an object is in page space, then
m_viewport_id is not nil and identifies the page it 
is on.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_viewport_id">
            <summary>
If m_viewport_id is nil, the object is active in
all viewports. If m_viewport_id is not nil, then 
this object is only active in a specific view.  
This field is primarily used to assign page space
objects to a specific page, but it can also be used 
to restrict model space to a specific view.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_wire_density">
            <summary>
When a surface object is displayed in wireframe, m_wire_density controls
how many isoparametric wires are used.
 value    number of isoparametric wires
 0        boundary and knot wires 
 1        boundary and knot wires and, if there are no interior knots, a single interior wire.
 N&gt;=2     boundary and knot wires and (N+1) interior wires
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_object_decoration">
            <summary>
Used to indicate an object has a decoration (like an arrowhead on a curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_plot_weight_mm">
            <summary>
Plot weight in millimeters.
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_plot_color">
            <summary>
If ON::plot_color_from_object == PlotColorSource(), then m_color is the object's
display color.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_color">
            <summary>
If ON::color_from_object == ColorSource(), then m_color is the object's
display color.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_material_index">
            <summary>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of the rendering material 
 and ignore m_rendering_attributes.
 If you are developing a high quality plug-in renderer, 
 and a user is assigning one of your fabulous rendering 
 materials to this object, then add rendering material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_linetype_index">
            <summary>
Linetype definitions in an OpenNURBS model are stored in a linetype table.
The linetype table is conceptually an array of ON_Linetype classes.  Every
OpenNURBS object in a model references some linetype.  The object's linetype
is specified by zero based indicies into the ON_Linetype array.
index 0 is reserved for continuous linetype (no pattern)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_layer_index">
            <summary>
Layer definitions in an OpenNURBS model are stored in a layer table.
The layer table is conceptually an array of ON_Layer classes.  Every
OpenNURBS object in a model is on some layer.  The object's layer
is specified by zero based indicies into the ON_Layer array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_url">
            <summary>
OpenNURBS objects may have an URL.  There are no restrictions on what
value this URL may have.  As an example, if the object came from a
commercial part library, the URL might point to the definition of that
part.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_name">
            <summary>
OpenNURBS object have optional text names.  More than one object in
a model can have the same name and some objects may have no name.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmObjectAttributes.m_uuid">
            <summary>
Every OpenNURBS object has a UUID (universally unique identifier).  The
default value is NULL.  When an OpenNURBS object is added to a model, the
value is checked.  If the value is NULL, a new UUID is created.  If the
value is not NULL but it is already used by another object in the model,
a new UUID is created.  If the value is not NULL and it is not used by 
another object in the model, then that value persists. When an object
is updated, by a move for example, the value of m_uuid persists.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.On3dmObjectAttributes">
            <summary>
Top level OpenNURBS objects have geometry and attributes.  The
geometry is stored in some class derived from ON_Geometry and 
the attributes are stored in an ON_3dmObjectAttributes class.
Examples of attributes are object name, object id, display 
attributes, group membership, layer membership, and so on.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.DisplayMaterialRefCount">
            <returns>Number of diplay material refences.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.FindDisplayMaterialId(System.Guid,System.Guid@)">
            <summary>Quick way to see if a viewport has a special material.</summary>
            <param name="viewport_id">[in]</param>
            <param name="display_material_id">[out]</param>
            <returns>True if a material_id is assigned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.FindDisplayMaterialRef(RMA.OpenNURBS.IOnDisplayMaterialRef,RMA.OpenNURBS.OnDisplayMaterialRef)">
            <summary>
Searches for a matching display material. For a given viewport id, there is at most one display material.
For a given display material id, there can be multiple viewports.  If there is a display reference in the
list with a nil viewport id, then the display material will be used in all viewports that are not explictly
referenced in other ON_DisplayMaterialRefs.
</summary>
            <param name="search_material">[in]</param>
            <param name="found_material">
[out] optional, may be NULL
If FindDisplayMaterialRef(), the input value of search_material is never changed.
If FindDisplayMaterialRef() returns true, the chart shows the output value of display_material.
When there are multiple possibilities for a match, the matches at the top of the chart have
higher priority.

search_material  found_material
input value      output value
(nil,nil)        (nil,did) if (nil,did) is in the list.
(nil,did)        (vid,did) if (vid,did) is in the list.
(nil,did)        (nil,did) if (nil,did) is in the list.
(vid,nil)        (vid,did) if (vid,did) is in the list
(vid,nil)        (vid,did) if (nil,did) is in the list
(vid,did)        (vid,did) if (vid,did) is in the list.
</param>
            <returns>True if a matching display material is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsInGroups(RMA.OpenNURBS.IArrayint)">
            <summary>
Returns TRUE if object is in any of the groups in the list
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsInGroup(System.Int32)">
            <summary>Returns TRUE if object is in group with the specified index</summary>
            <param name="groupId">the group index that we are checking for</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.TopGroup">
            <summary>
Returns the index of the last group in the group list
or -1 if the object is not in any groups
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.GetGroupList(RMA.OpenNURBS.Arrayint@)">
            <summary>
Returns and array an array of GroupCount() zero based 
group indices.  If GroupCount() is zero, then GroupList()
returns NULL.
</summary>
            <summary>
Returns GroupCount() and puts a list of zero based group indices 
into the array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.GroupCount">
            <summary>
returns number of groups object belongs to
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.MaterialSource">
            <summary>
Determine if the simple material should come from the object or from it's layer.
High quality rendering plug-ins should use m_rendering_attributes.
</summary>
            <returns>
Where to get material information if you do are too lazy to look in m_rendering_attributes.m_materials[].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.DisplayMode">
            <summary>
OpenNURBS objects can be displayed in one of three ways: wireframe,
shaded, or render preview.  If the display mode is ON::default_display,
then the display mode of the viewport detrmines how the object
is displayed.  If the display mode is ON::wireframe_display,
ON::shaded_display, or ON::renderpreview_display, then the object is
forced to display in that mode.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.PlotColorSource">
            <summary>
The color used to plot an OpenNURBS object on paper is specified 
in one of three ways.
If PlotColorSource() is ON::plot_color_from_layer, then the object's layer 
ON_Layer::PlotColor() is used.
If PlotColorSource() is ON::plot_color_from_object, then value of PlotColor() is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.ColorSource">
            <summary>
The color used to display an OpenNURBS object is specified in one of three ways.
If ColorSource() is ON::color_from_layer, then the object's layer 
ON_Layer::Color() is used.
If ColorSource() is ON::color_from_object, then value of m_color is used.
If ColorSource() is ON::color_from_material, then the diffuse color of the object's
render material is used.  See ON_3dmObjectAttributes::MaterialSource() to
determine where to get the definition of the object's render material.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.LinetypeSource">
            <summary>
The Linetype used to display an OpenNURBS object is specified in one of two ways.
If LinetypeSource() is ON::linetype_from_layer, then the object's layer 
ON_Layer::Linetype() is used.
If LinetypeSource() is ON::linetype_from_object, then value of m_linetype is used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsVisible">
            <summary>
Returns true if object is visible. See Also: ON_3dmObjectAttributes::SetVisible
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.IsInstanceDefinitionObject">
            <summary>Use this query to determine if an object is part of an instance definition.</summary>
            <returns>True if the object is part of an instance definition.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmObjectAttributes.Mode">
            <summary>
An OpenNURBS object must be in one of three modes: normal, locked
or hidden.  If an object is in normal mode, then the object's layer
controls visibility and selectability.  If an object is locked, then
the object's layer controls visibility by the object cannot be selected.
If the object is hidden, it is not visible and it cannot be selected.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_space">
            <summary>
Starting with V4, objects can be in either model space
or page space.  If an object is in page space, then
m_viewport_id is not nil and identifies the page it 
is on.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_viewport_id">
            <summary>
If m_viewport_id is nil, the object is active in
all viewports. If m_viewport_id is not nil, then 
this object is only active in a specific view.  
This field is primarily used to assign page space
objects to a specific page, but it can also be used 
to restrict model space to a specific view.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_wire_density">
            <summary>
When a surface object is displayed in wireframe, m_wire_density controls
how many isoparametric wires are used.
 value    number of isoparametric wires
 0        boundary and knot wires 
 1        boundary and knot wires and, if there are no interior knots, a single interior wire.
 N&gt;=2     boundary and knot wires and (N+1) interior wires
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_object_decoration">
            <summary>
Used to indicate an object has a decoration (like an arrowhead on a curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_plot_weight_mm">
            <summary>
Plot weight in millimeters.
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_plot_color">
            <summary>
If ON::plot_color_from_object == PlotColorSource(), then m_color is the object's
display color.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_color">
            <summary>
If ON::color_from_object == ColorSource(), then m_color is the object's
display color.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_material_index">
            <summary>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of the rendering material 
 and ignore m_rendering_attributes.
 If you are developing a high quality plug-in renderer, 
 and a user is assigning one of your fabulous rendering 
 materials to this object, then add rendering material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_linetype_index">
            <summary>
Linetype definitions in an OpenNURBS model are stored in a linetype table.
The linetype table is conceptually an array of ON_Linetype classes.  Every
OpenNURBS object in a model references some linetype.  The object's linetype
is specified by zero based indicies into the ON_Linetype array.
index 0 is reserved for continuous linetype (no pattern)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_layer_index">
            <summary>
Layer definitions in an OpenNURBS model are stored in a layer table.
The layer table is conceptually an array of ON_Layer classes.  Every
OpenNURBS object in a model is on some layer.  The object's layer
is specified by zero based indicies into the ON_Layer array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_url">
            <summary>
OpenNURBS objects may have an URL.  There are no restrictions on what
value this URL may have.  As an example, if the object came from a
commercial part library, the URL might point to the definition of that
part.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_name">
            <summary>
OpenNURBS object have optional text names.  More than one object in
a model can have the same name and some objects may have no name.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmObjectAttributes.m_uuid">
            <summary>
Every OpenNURBS object has a UUID (universally unique identifier).  The
default value is NULL.  When an OpenNURBS object is added to a model, the
value is checked.  If the value is NULL, a new UUID is created.  If the
value is not NULL but it is already used by another object in the model,
a new UUID is created.  If the value is not NULL and it is not used by 
another object in the model, then that value persists. When an object
is updated, by a move for example, the value of m_uuid persists.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOn3dmObjectAttributes">
            <summary>
Top level OpenNURBS objects have geometry and attributes.  The
geometry is stored in some class derived from ON_Geometry and 
the attributes are stored in an ON_3dmObjectAttributes class.
Examples of attributes are object name, object id, display 
attributes, group membership, layer membership, and so on.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_plugin_list">
            <summary>
Plugins that were loaded when the file was saved.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_linetype_display_scale">
            <summary>
World scale factor to apply to non-solid linetypes
for model display.  For plotting, the linetype settings
are used without scaling.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_GridDefaults">
            <summary>
default settings for construction plane grids
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_current_wire_density">
            <summary>
Surface wireframe density
 @untitled table
 0       boundary + "knot" wires 
 1       boundary + "knot" wires + 1 interior wire if no interior "knots"
 N&gt;=2    boundry + "knot" wires + (N-1) interior wires
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_current_layer_index">
            <summary>
These fields determine what layer, material, color, line style, and
wire density are used for new objects.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_active_view_id">
            <summary>
id of "active" viewport
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_views">
            <summary>
current viewports
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_AnnotationSettings">
            <summary>
settings used when annotation objects are created
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_AnalysisMeshSettings">
            <summary>
settings used for automatically created analysis meshes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_CustomRenderMeshSettings">
            <summary>
saved custom settings
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_RenderMeshSettings">
            <summary>
settings used for automatically created rendering meshes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_PageUnitsAndTolerances">
            <summary>
Page space (printing/paper) tolerances and unit system
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_ModelUnitsAndTolerances">
            <summary>
Model space tolerances and unit system
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_earth_anchor_point">
            <summary>
If set, this is the model's location on the earth.
This information is used when the model is used
with GIS information.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_model_basepoint">
            <summary>
Model basepoint is used when the file is read as
an instance definition and is the point that is
mapped to the origin in the instance definition.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmSettings.m_model_URL">
            <summary>
model URL (can be empty)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_plugin_list">
            <summary>
Plugins that were loaded when the file was saved.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_linetype_display_scale">
            <summary>
World scale factor to apply to non-solid linetypes
for model display.  For plotting, the linetype settings
are used without scaling.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_GridDefaults">
            <summary>
default settings for construction plane grids
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_current_wire_density">
            <summary>
Surface wireframe density
 0       boundary + "knot" wires 
 1       boundary + "knot" wires + 1 interior wire if no interior "knots"
 N&gt;=2    boundry + "knot" wires + (N-1) interior wires
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_current_layer_index">
            <summary>
These fields determine what layer, material, color, line style, and
wire density are used for new objects.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_active_view_id">
            <summary>
id of "active" viewport
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_views">
            <summary>
current viewports
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_AnnotationSettings">
            <summary>
settings used when annotation objects are created
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_AnalysisMeshSettings">
            <summary>
settings used for automatically created analysis meshes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_CustomRenderMeshSettings">
            <summary>
saved custom settings
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_RenderMeshSettings">
            <summary>
settings used for automatically created rendering meshes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_PageUnitsAndTolerances">
            <summary>
Page space (printing/paper) tolerances and unit system
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_ModelUnitsAndTolerances">
            <summary>
Model space tolerances and unit system
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_earth_anchor_point">
            <summary>
If set, this is the model's location on the earth.
This information is used when the model is used
with GIS information.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_model_basepoint">
            <summary>
Model basepoint is used when the file is read as
an instance definition and is the point that is
mapped to the origin in the instance definition.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmSettings.m_model_URL">
            <summary>
model URL (can be empty)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmIOSettings.m_idef_link_update">
            <summary>
linked instance defintion settings
0 = use ON_InstanceDefinition setting
      The ON_InstanceDefinition::m_idef_update_type
      field controls when and with how much
      prompting embedded or linked idefs get updated.
1 = prompt
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, ask the user what to do.
2 = always update - no prompting
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, silently update it.
3 = never update - no prompting
      Ignore m_idef_update_type settings.
      Do not update embedded or linked idefs.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmIOSettings.m_bSaveTextureBitmapsInFile">
            <summary>
bitmaps associated with rendering materials
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmIOSettings.m_idef_link_update">
            <summary>
linked instance defintion settings
0 = use ON_InstanceDefinition setting
      The ON_InstanceDefinition::m_idef_update_type
      field controls when and with how much
      prompting embedded or linked idefs get updated.
1 = prompt
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, ask the user what to do.
2 = always update - no prompting
      Ignore m_idef_update_type settings.
      If an embedded or linked idef needs to 
      be updated, silently update it.
3 = never update - no prompting
      Ignore m_idef_update_type settings.
      Do not update embedded or linked idefs.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmIOSettings.m_bSaveTextureBitmapsInFile">
            <summary>
bitmaps associated with rendering materials
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEarthAnchorPoint.GetModelToEarthXform(RMA.OpenNURBS.IOnUnitSystem,RMA.OpenNURBS.OnXform@)">
            <summary>
Get a transformation from model coordinates to earth coordinates.
This transformation assumes the model is small enough that the curvature of the earth can be ignored.
</summary>
            <param name="model_unit_system">[in]</param>
            <param name="model_to_earth">[out] Transformation from model coordinates to earth locations (degrees latitude,degrees longitude,elevation in meters)</param>
            <remarks>
If M is a point in model coordinates and E = model_to_earth*M, then
E.x = latitude in decimal degrees
E.y = longitude in decimal degrees
E.z = elevation in meters above mean sea level
Because the earth is not flat, there is a small amount of error when
using a linear transformation to calculate oblate spherical coordinates.
This error is small. If the distance from P to M is d meters,
then the approximation error is
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 6379000*((1 + (d/6356000)^2)-1) meters
In particular, if every point in the model is within 1000 meters
of the m_model_basepoint, then the maximum approximation errors are
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 8 centimeters
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnEarthAnchorPoint.GetModelCompass(RMA.OpenNURBS.OnPlane@)">
            <summary>
Parameters: model_compass - [out] A plane in model coordinates whose xaxis points East, yaxis points North and zaxis points up. The origin is set to m_model_basepoint.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_url_tag">
            <summary>
UI link text for m_url
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_id">
            <summary>
unique id for this anchor point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_model_east">
            <summary>
in model coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_model_north">
            <summary>
in model coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_model_basepoint">
            <summary>
Corresponding model point in model coordinates.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_elevation_zero">
            <summary>
0 = ground level
1 = mean sea level
2 = center of earth
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_elevation">
            <summary>
in meters
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_longitude">
            <summary>
Longitude (degrees):   0 = prime meridian (Greenwich meridian)
in decimal degrees
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEarthAnchorPoint.m_earth_basepoint_latitude">
            <summary>
Latitude (degrees):  +90 = north pole, 0 = equator, -90 = south pole
in decimal degrees
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEarthAnchorPoint.GetModelToEarthXform(RMA.OpenNURBS.IOnUnitSystem,RMA.OpenNURBS.OnXform@)">
            <summary>
Get a transformation from model coordinates to earth coordinates.
This transformation assumes the model is small enough that the curvature of the earth can be ignored.
</summary>
            <param name="model_unit_system">[in]</param>
            <param name="model_to_earth">[out] Transformation from model coordinates to earth locations (degrees latitude,degrees longitude,elevation in meters)</param>
            <remarks>
If M is a point in model coordinates and E = model_to_earth*M, then
E.x = latitude in decimal degrees
E.y = longitude in decimal degrees
E.z = elevation in meters above mean sea level
Because the earth is not flat, there is a small amount of error when
using a linear transformation to calculate oblate spherical coordinates.
This error is small. If the distance from P to M is d meters,
then the approximation error is
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 6379000*((1 + (d/6356000)^2)-1) meters
In particular, if every point in the model is within 1000 meters
of the m_model_basepoint, then the maximum approximation errors are
  latitude error &lt;=
  longitude error &lt;=
  elevation error &lt;= 8 centimeters
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEarthAnchorPoint.GetModelCompass(RMA.OpenNURBS.OnPlane@)">
            <summary>
Parameters: model_compass - [out] A plane in model coordinates whose xaxis points East, yaxis points North and zaxis points up. The origin is set to m_model_basepoint.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_url_tag">
            <summary>
UI link text for m_url
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_id">
            <summary>
unique id for this anchor point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_model_east">
            <summary>
in model coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_model_north">
            <summary>
in model coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_model_basepoint">
            <summary>
Corresponding model point in model coordinates.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_elevation_zero">
            <summary>
0 = ground level
1 = mean sea level
2 = center of earth
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_elevation">
            <summary>
in meters
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_longitude">
            <summary>
Longitude (degrees):   0 = prime meridian (Greenwich meridian)
in decimal degrees
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEarthAnchorPoint.m_earth_basepoint_latitude">
            <summary>
Latitude (degrees):  +90 = north pole, 0 = equator, -90 = south pole
in decimal degrees
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesHiddenLightsAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesAnnotationAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesMeshEdgesAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesIsoparmsAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesCurvesAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesPointsAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesBackfaceAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesBackgroundAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bUsesAmbientAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_shadowmap_style">
            <summary>
0 = none, 1 = normal, 2 = best
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_antialias_style">
            <summary>
0 = none, 1 = normal, 2 = best
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_background_style">
            <summary>
0 = solid color, 1 = "wallpaper" image
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_us">
            <summary>
unit system to use when converting image pixel size and dpi
information into a print size.  Default = inches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_dpi">
            <summary>
Number of dots/inch (dots=pixels) to use when printing and 
saving bitmaps. The default is 72.0 dots/inch.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_height">
            <summary>
image height in pixels
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_image_width">
            <summary>
image width in pixels
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmRenderSettings.m_bCustomImageSize">
            <summary>
FALSE: image pixel size = current viewport size
TRUE:  image pixel size = m_image_width X m_image_height pixels
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesHiddenLightsAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesAnnotationAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesMeshEdgesAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesIsoparmsAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesCurvesAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesPointsAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesBackfaceAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesBackgroundAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bUsesAmbientAttr">
            <summary>
Flag used to determine which render settings a render plugin uses, and which ones the display pipeline should use.
Note: Render plugins set these, and they don't need to persist in the document...Also, when set, they turn OFF their
corresponding setting in the Display Attributes Manager's UI pages for "Rendered" mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_shadowmap_style">
            <summary>
0 = none, 1 = normal, 2 = best
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_antialias_style">
            <summary>
0 = none, 1 = normal, 2 = best
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_background_style">
            <summary>
0 = solid color, 1 = "wallpaper" image
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_us">
            <summary>
unit system to use when converting image pixel size and dpi
information into a print size.  Default = inches
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_dpi">
            <summary>
Number of dots/inch (dots=pixels) to use when printing and 
saving bitmaps. The default is 72.0 dots/inch.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_height">
            <summary>
image height in pixels
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_image_width">
            <summary>
image width in pixels
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmRenderSettings.m_bCustomImageSize">
            <summary>
FALSE: image pixel size = current viewport size
TRUE:  image pixel size = m_image_width X m_image_height pixels
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_wallpaper_image">
            <summary>wallpaper image</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_trace_image">
            <summary>tracing image</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_bShowWorldAxes">
            <summary>world axes icon</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_cplane">
            <summary>construction plane</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_page_settings">
            <summary>
If m_view_type == ON::page_view_type, then the m_page_settings
records the page size.  Otherwise, m_page_settings should
be ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_view_type">
            <summary>model, page, or nested</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_position">
            <summary>
position of view in parent window 
(relative display device coordinates)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_display_mode_id">
            <summary>
If m_display_mode_id is nil, then use m_display_mode
to show one of the "standard" (wireframe, shaded, rendered)
display modes.  If m_display_mode_id is not nil, then
ignore m_display_mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_name">
            <summary>name on window</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_bLockedProjection">
            <summary>
If true, the the camera location, camera direction,
and lens angle should not be changed.
It is ok to adjust clipping planes.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_clipping_planes">
            <summary>clipping planes</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmView.m_vp">
            <summary>view projection information</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_wallpaper_image">
            <summary>wallpaper image</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_trace_image">
            <summary>tracing image</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_bShowWorldAxes">
            <summary>world axes icon</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_cplane">
            <summary>construction plane</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_page_settings">
            <summary>
If m_view_type == ON::page_view_type, then the m_page_settings
records the page size.  Otherwise, m_page_settings should
be ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_view_type">
            <summary>model, page, or nested</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_position">
            <summary>
position of view in parent window 
(relative display device coordinates)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_display_mode_id">
            <summary>
If m_display_mode_id is nil, then use m_display_mode
to show one of the "standard" (wireframe, shaded, rendered)
display modes.  If m_display_mode_id is not nil, then
ignore m_display_mode.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_name">
            <summary>name on window</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_bLockedProjection">
            <summary>
If true, the the camera location, camera direction,
and lens angle should not be changed.
It is ok to adjust clipping planes.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_clipping_planes">
            <summary>clipping planes</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmView.m_vp">
            <summary>view projection information</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_bottom_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_top_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_right_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_left_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_height_mm">
            <summary>Overall size of the page in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmPageSettings.m_width_mm">
            <summary>Overall size of the page in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_bottom_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_top_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_right_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_left_margin_mm">
            <summary>Page margins in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_height_mm">
            <summary>Overall size of the page in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmPageSettings.m_width_mm">
            <summary>Overall size of the page in millimeters</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmWallpaperImage.m_bHidden">
            <summary>true if image is currently hidden from view</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmWallpaperImage.m_bGrayScale">
            <summary>true if image should be black and white</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmWallpaperImage.m_bHidden">
            <summary>true if image is currently hidden from view</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmWallpaperImage.m_bGrayScale">
            <summary>true if image should be black and white</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_bFiltered">
            <summary>true if image should be filtered (bilinear) before displayed.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_bHidden">
            <summary>true if image is currently hidden from view</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_bGrayScale">
            <summary>true if image should be black and white</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewTraceImage.m_plane">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_bFiltered">
            <summary>true if image should be filtered (bilinear) before displayed.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_bHidden">
            <summary>true if image is currently hidden from view</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_bGrayScale">
            <summary>true if image should be black and white</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewTraceImage.m_plane">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmViewPosition.#ctor">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_floating_viewport">
            <summary>
m_floating_viewport is used to track floating viewport information.
0 = the view is docked in the main application window.
&gt;0 = the view is floating. When floating, this corresponds to the
number of monitors on on the user's computer when the file was saved
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_bMaximized">
            <summary>TRUE if view window is maximized</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_wnd_bottom">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_wnd_top">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_wnd_right">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmViewPosition.m_wnd_left">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.On3dmViewPosition">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_floating_viewport">
            <summary>
m_floating_viewport is used to track floating viewport information.
0 = the view is docked in the main application window.
&gt;0 = the view is floating. When floating, this corresponds to the
number of monitors on on the user's computer when the file was saved
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_bMaximized">
            <summary>TRUE if view window is maximized</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_wnd_bottom">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_wnd_top">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_wnd_right">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmViewPosition.m_wnd_left">
            <summary>
0.0 to 1.0
if m_floating_viewport&gt;0, this is relative position of the view window
on the virtual screen (union of potentially multiple monitors)
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOn3dmViewPosition">
            <summary>view window relative position and state in parent frame</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_name">
            <summary>
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_bDepthBuffer">
            <summary>
false=grid is always drawn behind 3d geometry
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_grid_thick_frequency">
            <summary>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_grid_line_count">
            <summary>number of grid lines in each direction</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_snap_spacing">
            <summary>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlane.m_grid_spacing">
            <summary>distance between grid lines</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_name">
            <summary>
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_bDepthBuffer">
            <summary>
false=grid is always drawn behind 3d geometry
true=grid is drawn at its depth as a 3d plane
and grid lines obscure things behind the grid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_grid_thick_frequency">
            <summary>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_grid_line_count">
            <summary>number of grid lines in each direction</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_snap_spacing">
            <summary>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlane.m_grid_spacing">
            <summary>distance between grid lines</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_grid_thick_frequency">
            <summary>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_grid_line_count">
            <summary>number of grid lines in each direction</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_snap_spacing">
            <summary>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmConstructionPlaneGridDefaults.m_grid_spacing">
            <summary>distance between grid lines</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_grid_thick_frequency">
            <summary>
thick line frequency
0: none, 
1: all lines are thick, 
2: every other is thick, ...
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_grid_line_count">
            <summary>number of grid lines in each direction</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_snap_spacing">
            <summary>
when "grid snap" is enabled, the
distance between snap points.  Typically
this is the same distance as grid spacing.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults.m_grid_spacing">
            <summary>distance between grid lines</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOn3dmConstructionPlaneGridDefaults">
            <summary>
Default settings used for construction plane grids
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_facename">
            <summary>windows font name</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_resolution">
            <summary>depends on m_lengthformat</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_textalign">
            <summary>0: above line, 1: in line, 2: horizontal</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_angleformat">
            <summary>0: decimal degrees, ...</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_lengthformat">
            <summary>0: decimal, ...</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_angularunits">
            <summary>0: degrees, 1: radians</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_arrowtype">
            <summary>0: filled narrow triangular arrow</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_dimunits">
            <summary>units used to measure the dimension</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmAnnotationSettings.m_dimscale">
            <summary>model size / plotted size</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_facename">
            <summary>windows font name</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_resolution">
            <summary>depends on m_lengthformat</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_textalign">
            <summary>0: above line, 1: in line, 2: horizontal</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_angleformat">
            <summary>0: decimal degrees, ...</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_lengthformat">
            <summary>0: decimal, ...</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_angularunits">
            <summary>0: degrees, 1: radians</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_arrowtype">
            <summary>0: filled narrow triangular arrow</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_dimunits">
            <summary>units used to measure the dimension</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmAnnotationSettings.m_dimscale">
            <summary>model size / plotted size</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmUnitsAndTolerances.Scale(RMA.OpenNURBS.IOn.unit_system)">
            <summary>
Returns scale factor that needs to be applied to change from
the argument's unit system to m_unit_system.  
When m_unit_system is not ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,m_unit_system).  When Scale(us)
When m_unit_system is ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,ON::meters)*m_custom_unit_scale.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_distance_display_precision">
            <summary>
decimal mode: number of decimal places
fractional modes:
   denominator = (1/2)^m_distance_display_precision
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_relative_tolerance">
            <summary>fraction &gt;= 0 and &lt; 1 (default = 1%)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_angle_tolerance">
            <summary>in radians (default = 3 degrees)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmUnitsAndTolerances.m_absolute_tolerance">
            <summary>in units (default = 1/100)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.Scale(RMA.OpenNURBS.IOn.unit_system)">
            <summary>
Returns scale factor that needs to be applied to change from
the argument's unit system to m_unit_system.  
When m_unit_system is not ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,m_unit_system).  When Scale(us)
When m_unit_system is ON::custom_unit_system,
Scale(us) = ON::UnitScale(us,ON::meters)*m_custom_unit_scale.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_distance_display_precision">
            <summary>
decimal mode: number of decimal places
fractional modes:
   denominator = (1/2)^m_distance_display_precision
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_relative_tolerance">
            <summary>fraction &gt;= 0 and &lt; 1 (default = 1%)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_angle_tolerance">
            <summary>in radians (default = 3 degrees)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmUnitsAndTolerances.m_absolute_tolerance">
            <summary>in units (default = 1/100)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmProperties.m_Application">
            <summary>application that created 3DM file</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmProperties.m_PreviewImage">
            <summary>
preview image of model
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmProperties.m_Application">
            <summary>application that created 3DM file</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmProperties.m_PreviewImage">
            <summary>preview image of model</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmApplication.m_application_details">
            <summary>
whatever you want
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmApplication.m_application_URL">
            <summary>
URL
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmApplication.m_application_name">
            <summary>
short name like "Rhino 2.0"
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmApplication.m_application_details">
            <summary>whatever you want</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmApplication.m_application_URL">
            <summary>URL</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmApplication.m_application_name">
            <summary>short name like "Rhino 5.0"</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_window_left">
            <summary>last window position</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_bHTML">
            <summary>TRUE if notes are in HTML</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3dmNotes.m_bVisible">
            <summary>TRUE if notes window is showing</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_window_left">
            <summary>last window position</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_bHTML">
            <summary>TRUE if notes are in HTML</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3dmNotes.m_bVisible">
            <summary>TRUE if notes window is showing</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dmRevisionHistory.NewRevision">
            <summary>
returns updated revision count
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceRef.m_bbox">
            <summary>
Bounding box for this reference.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceRef.m_xform">
            <summary>
Transformation for this reference.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceRef.m_instance_definition_uuid">
            <summary>
Unique id of the instance definition (ON_InstanceDefinition) 
in the instance definition table that defines the geometry
used by this reference.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnInstanceRef">
            <summary>
An ON_InstanceRef is a reference to an instance definition
along with transformation to apply to the definition.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceRef.m_bbox">
            <summary>
Bounding box for this reference.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceRef.m_xform">
            <summary>
Transformation for this reference.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceRef.m_instance_definition_uuid">
            <summary>
Unique id of the instance definition (ON_InstanceDefinition) 
in the instance definition table that defines the geometry
used by this reference.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnInstanceRef">
            <summary>
An ON_InstanceRef is a reference to an instance definition
along with transformation to apply to the definition.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SetUnitSystem(RMA.OpenNURBS.IOn.unit_system)">
            <summary>
Description: Sets m_us and m_unit_scale.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SourceArchiveCheckSum">
            <summary>
Returns: Check sum of source archive.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SourceArchive">
            <summary>
Returns: Name of source archive.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInstanceDefinition.SetSourceArchive(System.String,RMA.OpenNURBS.IOnCheckSum,RMA.OpenNURBS.IOnInstanceDefinition.IDEF_UPDATE_TYPE)">
            <summary>
If the instance definition is linked or embedded, use SetSource to specify the source archive.
</summary>
            <param name="source_archive">[in] name of source archive</param>
            <param name="checksum">[in] check sum used to detect changed</param>
            <param name="update_type">[in] See comments for ON_InstanceDefinition::IDEF_UPDATE_TYPE</param>
            <remarks>
In all cases, the complete instance definition geometry is stored in the 3dm archive.
When an instance definition is linked or embedded, applications can examine the source
archive settings and update the definition when appropriate. The checksum can be used
to detect changed files.
</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_source_archive_checksum">
            <summary>
used to detect when idef is out of synch with source archive.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_source_bRelativePath">
            <summary>
True if the filename in m_source_archive is
a relative the location of the 3dm file
containing this instance definition.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_source_archive">
            <summary>
filename used to update idef (it can be empty or relative)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_idef_update_depth">
            <summary>
Controls how much geometry is read when
a linked idef is updated.
 0: read everything, included nested linked idefs
 1: skip nested linked idefs.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_url_tag">
            <summary>
UI link text for m_url
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_description">
            <summary>
It can be empty and duplicates
may exist. Instance reference use
m_uuid to find instance definitions.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_name">
            <summary>
The "name" is for human comfort.
It can be empty and duplicates may exist. Instance reference use
m_uuid to find instance definitions.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_uuid">
            <summary>
unique id for this instance definition
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInstanceDefinition.m_object_uuid">
            <summary>
list of object ids in the instance geometry table.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInstanceDefinition.SourceArchiveCheckSum">
            <summary>
Returns: Check sum of source archive.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInstanceDefinition.SourceArchive">
            <summary>
Returns: Name of source archive.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_source_archive_checksum">
            <summary>
used to detect when idef is out of synch with source archive.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_source_bRelativePath">
            <summary>
True if the filename in m_source_archive is
a relative the location of the 3dm file
containing this instance definition.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_source_archive">
            <summary>
filename used to update idef (it can be empty or relative)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_idef_update_depth">
            <summary>
Controls how much geometry is read when
a linked idef is updated.
 0: read everything, included nested linked idefs
 1: skip nested linked idefs.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_url_tag">
            <summary>
UI link text for m_url
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_description">
            <summary>
It can be empty and duplicates
may exist. Instance reference use
m_uuid to find instance definitions.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_name">
            <summary>
The "name" is for human comfort.
It can be empty and duplicates may exist. Instance reference use
m_uuid to find instance definitions.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_uuid">
            <summary>
unique id for this instance definition
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInstanceDefinition.m_object_uuid">
            <summary>
list of object ids in the instance geometry table.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnInstanceDefinition.IDEF_UPDATE_TYPE">
            <summary>
IDEF_UPDATE_TYPE lists the possible relationships between
the instance definition geometry and the archive 
(m_source_archive) containing the original defition.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnInstanceDefinition">
            <summary>
An ON_InstanceDefinition defines the geometry used by instance references.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEmbeddedBitmap.m_biffer_crc32">
            <summary>
32 bit crc from ON_CRC32
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEmbeddedBitmap.m_free_buffer">
            <summary>
1 = ~ON_EmbeddedBitmap will onfree m_buffer.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEmbeddedBitmap.m_biffer_crc32">
            <summary>
32 bit crc from ON_CRC32
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEmbeddedBitmap.m_free_buffer">
            <summary>
1 = ~ON_EmbeddedBitmap will onfree m_buffer.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnWindowsBitmapEx">
            <summary>
ON_WindowsBitmapEx is identical to ON_WindowsBitmap except that
it's Read/Write functions save bitmap names.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnWindowsBitmapEx">
            <summary>
ON_WindowsBitmapEx is identical to ON_WindowsBitmap except that
it's Read/Write functions save bitmap names.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.IsContiguous">
            <summary>Create an ON_WindowsBitmap from a bitmap. Copies source</summary>
            <summary>
Description: Create an ON_WindowsBitmap from a contiguous bitmap. Copies src. Parameters: src - [in] contiguous Windows device independent bitmap. See Also: ON_WindowsBitmap::Create
</summary>
            <summary>
True if m_bmi and m_bits are in a single contiguous block of memory.
False if m_bmi and m_bits are in two blocks of memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.Pixel(System.Int32,System.Int32)">
            <param name="i">0 &lt;= i &lt; width</param>
            <param name="j">0 &lt;= j &lt; height</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.SizeofPalette">
            <summary>
number of bytes in palette
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.PaletteColorCount">
            <summary>
number of colors in palette
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnWindowsBitmap.Create(System.Int32,System.Int32,System.Int32)">
            <param name="bpp">bits per pixel ( 1, 2, 4, 8, 16, 24, or 32 )</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnWindowsBitmap">
            <summary>
Uncompressed 8 bpp, 24 bpp, or 32 bpp Windows device 
independent bitmaps (DIB)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.IsContiguous">
            <summary>
True if m_bmi and m_bits are in a single contiguous block of memory.
False if m_bmi and m_bits are in two blocks of memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.Pixel(System.Int32,System.Int32)">
            <param name="i">0 &lt;= i &lt; width</param>
            <param name="j">0 &lt;= j &lt; height</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.SizeofPalette">
            <summary>
number of bytes in palette
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnWindowsBitmap.PaletteColorCount">
            <summary>
number of colors in palette
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnWindowsBitmap">
            <summary>
Uncompressed 8 bpp, 24 bpp, or 32 bpp Windows device 
independent bitmaps (DIB)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBitmap.SizeofImage">
            <summary>size of current map in bytes</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBitmap.SizeofScan">
            <summary>number of bytes per scan line</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBitmap.Height">
            <summary>
&gt;0 means it's a bottom-up bitmap with origin at lower right
&lt;0 means it's a top-down bitmap with origin at upper left
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBitmap.m_ON_Bitmap_class_id">
            <summary>
virtual base class for bitmap objects
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBitmap.m_bitmap_filename">
            <summary>
full path to file
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBitmap.m_bitmap_name">
            <summary>
descriptive name
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnBitmap">
            <summary>
virtual base class for bitmap objects
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.SizeofImage">
            <summary>size of current map in bytes</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.SizeofScan">
            <summary>number of bytes per scan line</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.BitsPerPixel">
            <summary>
&lt;0 means it's a top-down bitmap with origin at upper left
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBitmap.Height">
            <summary>
&gt;0 means it's a bottom-up bitmap with origin at lower right
&lt;0 means it's a top-down bitmap with origin at upper left
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBitmap.m_bitmap_filename">
            <summary>
full path to file
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBitmap.m_bitmap_name">
            <summary>
descriptive name
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBitmap">
            <summary>
virtual base class for bitmap objects
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_user_i">
            <summary>
zero all brep's m_*_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_face_user_i">
            <summary>
zero all brep's m_face_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_loop_user_i">
            <summary>
zero all brep's m_loop_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_trim_user_i">
            <summary>
zero all brep's m_trim_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_edge_user_i">
            <summary>
zero all brep's m_edge_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_edge_user_i(System.Int32)">
            <summary>
zero all brep's m_edge_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Clear_vertex_user_i">
            <summary>
set every brep m_*_user value to u
</summary>
            <summary>
zero all brep's m_vertex_user values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveWireVertices">
            <summary>Remove vertices that are not connected to an edge.</summary>
            <returns>Number of vertices that were deleted.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove deleted vertices from the m_V[] array.
See Also: ON_Brep::RemoveWireEdges
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveWireEdges">
            <summary>Remove edges that are not connected to a face.</summary>
            <returns>Number of edges that were removed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.

If you want to remove wire edges and wiere After you finish cleaning up the brep,
you need to call ON_Brep::Compact() to remove deleted vertices from the m_V[] array.
See Also: ON_Brep::RemoveWireVertices
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveWireEdges(System.Boolean)">
            <summary>Remove edges that are not connected to a face.</summary>
            <param name="bDeleteVertices">
[in] if true, then the vertices at the ends of the wire edges are deleted
if they are not connected to face trimming edges.
</param>
            <returns>Number of edges that were removed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays. Remarks: If you want to remove wire
edges and wiere After you finish cleaning up the brep, you need to call
ON_Brep::Compact() to remove deleted vertices from the m_V[] array.
See Also: ON_Brep::RemoveWireVertices
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CloseTrimGap(RMA.OpenNURBS.OnBrepTrim@,RMA.OpenNURBS.OnBrepTrim@)">
            <summary>Expert user tool to remove any gap between adjacent trims.</summary>
            <param name="trim0">[in]</param>
            <param name="trim1">[in]</param>
            <returns>True if successful.</returns>
            <remarks>
The trims must be in the same trimming loop. The vertex at the end of teim0 must
be the same as the vertex at the start of trim1. The trim's m_iso and m_type
flags need to be correctly set.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ChangeVertex(System.Int32,System.Int32,System.Boolean)">
            <summary>Expert user tool to move trims and edges from one vertex to another.</summary>
            <param name="old_vi">[in] index of old vertex</param>
            <param name="new_vi">[in] index of new vertex</param>
            <param name="bClearTolerances">
[in] if true, then tolerances of edges and trims that are connected ot the old
vertex are set to ON_UNSET_VALUE. vertex_index - [in] if &gt;= 0, this the edge
is collapsed to this vertex. Otherwise a vertex is automatically selected or created.
</param>
            <returns>True if successful.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CollapseEdge(System.Int32)">
            <summary>
Expert user tool to collapse a "short" edge to a vertex. The edge is
removed and the topology is repaired so that everything that used to connect to
the edge connects the specified vertex.
</summary>
            <param name="edge_index">[in] index of edge to remove</param>
            <returns>True if edge was successfully collapsed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CollapseEdge(System.Int32,System.Boolean)">
            <summary>
Expert user tool to collapse a "short" edge to a vertex. The edge is
removed and the topology is repaired so that everything that used to connect to
the edge connects the specified vertex.
</summary>
            <param name="edge_index">[in] index of edge to remove</param>
            <param name="bCloseTrimGap">
[in] if true and the removal of the edge creates a gap in the parameter space trimming loop,
then the 2d trim curves will be adjusted to close the gap.
</param>
            <returns>True if edge was successfully collapsed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CollapseEdge(System.Int32,System.Boolean,System.Int32)">
            <summary>
Expert user tool to collapse a "short" edge to a vertex. The edge is
removed and the topology is repaired so that everything that used to connect to
the edge connects the specified vertex.
</summary>
            <param name="edge_index">[in] index of edge to remove</param>
            <param name="bCloseTrimGap">
[in] if true and the removal of the edge creates a gap in the parameter space trimming loop,
then the 2d trim curves will be adjusted to close the gap.
</param>
            <param name="vertex_index">
[in] if &gt;= 0, this the edge is collapsed to this vertex. Otherwise a vertex is
automatically selected or created.
</param>
            <returns>True if edge was successfully collapsed.</returns>
            <remarks>
After you finish cleaning up the brep, you need to call ON_Brep::Compact()
to remove unused edge, trim, and vertex information from the brep's m_E[],
m_V[], m_T[], m_C2[], and m_C3[] arrays.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveNesting(System.Boolean)">
            <summary>
Removes nested polycurves from the m_C2[] and m_C3[] arrays.
</summary>
            <param name="bExtractSingleSegments">
[in] if true, polycurves with a single segment are replaced with the segment curve.
</param>
            <returns>True if any nesting was removed and false if no nesting was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveNesting(System.Boolean,System.Boolean)">
            <summary>
Removes nested polycurves from the m_C2[] and m_C3[] arrays.
</summary>
            <param name="bExtractSingleSegments">
[in] if true, polycurves with a single segment are replaced with the segment curve.
</param>
            <param name="bEdges">[in] if true, the m_C3[] array is processed</param>
            <returns>True if any nesting was removed and false if no nesting was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveNesting(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
Removes nested polycurves from the m_C2[] and m_C3[] arrays.
</summary>
            <param name="bExtractSingleSegments">
[in] if true, polycurves with a single segment are replaced with the segment curve.
</param>
            <param name="bEdges">[in] if true, the m_C3[] array is processed</param>
            <param name="bTrimCurves">[in] if true, the m_C2[] array is processed.</param>
            <returns>True if any nesting was removed and false if no nesting was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveSlits(RMA.OpenNURBS.OnBrepFace@)">
            <summary>remove slit trims and slit boundaries from a face</summary>
            <param name="F">[in] brep face</param>
            <returns>true if any slits were removed</returns>
            <remarks>Caller should call Compact() when done.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RemoveSlits">
            <summary>remove slit trims and slit boundaries from each face</summary>
            <returns>true if any slits were removed</returns>
            <remarks>Caller should call Compact() afterwards.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Face(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Face(System.Int32)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop(System.Int32)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Trim(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Trim(System.Int32)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Edge(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Edge(System.Int32)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Vertex(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Vertex(System.Int32)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.BrepComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a brep component from its index.</summary>
            <param name="component_index">[in]</param>
            <returns>
A const pointer to the component. Do not delete the returned object.
It points to an object managed by this brep.
</returns>
            <remarks>
See Also:
ON_Brep::Face
ON_Brep::Edge
ON_Brep::Loop
ON_Brep::Trim 
ON_Brep::Vertex
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NextEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NextEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="next_endi">
[out] 0 if next edge begins at the vertex, 1 if next edge ends at the vertex
</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.PrevEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.PrevEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="prev_endi">
[out] 0 if previous edge begins at the vertex, 1 if previous edge ends at the vertex
</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NextTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of next trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.PrevTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of prev trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedSurfaces">
            <summary>
culls surfaces not referenced by a face
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnused2dCurves">
            <summary>
culls 3d curves not referenced by an edge
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnused3dCurves">
            <summary>
culls 2d curves not referenced by a trim
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedVertices">
            <summary>
culls vertices with m_vertex_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedEdges">
            <summary>
culls edges with m_edge_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedTrims">
            <summary>
culls trims with m_trim_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedLoops">
            <summary>
culls loops with m_loop_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CullUnusedFaces">
            <summary>
culls faces with m_face_index == -1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Compact">
            <summary>
Uses the CullUnused*() members to delete any unreferenced objects from arrays,
reindexes as needed, and shrinks arrays to minimum required size.
</summary>
            <remarks>
See Also:
ON_Brep::CullUnusedFaces
ON_Brep::CullUnusedLoops
ON_Brep::CullUnusedTrims 
ON_Brep::CullUnusedEdges
ON_Brep::CullUnusedVertices
ON_Brep::CullUnused3dCurves
ON_Brep::CullUnused2dCurves 
ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ShrinkSurfaces">
            <summary>
Sometimes the ON_Surface used by a face extends far beyond the face's outer boundary.
ShrinkSurfaces calls ON_Shrink::ShrinkSurface on each face to remove portions of surfaces
that extend beyond their face's outer boundary loop.
</summary>
            <returns>
true successful
false failure
</returns>
            <remarks>
If a surface needs to be shrunk it is copied. After shrinking, you may want
to call ON_Brep::CullUnusedSurfaces to remove any unused surfaces.
See Also: ON_Brep::ShrinkSurface ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ShrinkSurface(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Sometimes the ON_Surface used by a face extends far beyond the face's outer boundary.
ShrinkSurface uses ON_Surface::Trim to remove portions of the surface that extend beyond
the face's outer boundary loop.
</summary>
            <param name="face">[in] face to test and whose surface should be shrunk.</param>
            <returns>
true successful
false failure
</returns>
            <remarks>
If a surface needs to be shrunk it is copied. After shrinking, you may want
to call ON_Brep::CullUnusedSurfaces to remove any unused surfaces.
See Also: ON_Brep::ShrinkSurfaces ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ShrinkSurface(RMA.OpenNURBS.OnBrepFace@,System.Int32)">
            <summary>
Sometimes the ON_Surface used by a face extends far beyond the face's outer boundary.
ShrinkSurface uses ON_Surface::Trim to remove portions of the surface that extend beyond
the face's outer boundary loop.
</summary>
            <param name="face">[in] face to test and whose surface should be shrunk.</param>
            <param name="DisableSide">
[in] This is a bit field. A set bit indicates not to shrink the surface on a given side.
The default of 0 enables shrinking on all four sides.
value  meaning
0x0001 Dont shrink on the west side of domain.
0x0002 Dont shrink on the south side of domain.
0x0004 Dont shrink on the east side of domain.
0x0008 Dont shrink on the north side of domain.
</param>
            <returns>
true successful
false failure
</returns>
            <remarks>
If a surface needs to be shrunk it is copied. After shrinking, you may want
to call ON_Brep::CullUnusedSurfaces to remove any unused surfaces.
See Also: ON_Brep::ShrinkSurfaces ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Standardize">
            <summary>Standardize all trims, edges, and faces in the brep.</summary>
            <remarks>
After standardizing, there may be unused curves and surfaces in the brep.
Call ON_Brep::Compact to remove these unused curves and surfaces.
See Also:
ON_Brep::StandardizeTrimCurves
ON_Brep::StandardizeEdgeCurves
ON_Brep::StandardizeFaceSurface
ON_Brep::Compact
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StardardizeFaceSurfaces">
            <summary>
Standardize all faces in the brep.
See Also: ON_Brep::StandardizeFaceSurface ON_Brep::Standardize
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeFaceSurface(System.Int32)">
            <summary>
Standardizes the relationship between an ON_BrepFace and the 3d surface it uses.
When done, the face will be the only face that references its 3d surface,
and the orientations of the face and 3d surface will be the same.
</summary>
            <param name="face_index">[in] index of face to standardize.</param>
            <remarks>See Also: ON_Brep::StardardizeFaceSurfaces ON_Brep::Standardize</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeTrimCurves">
            <summary>
Standardize all trims in the brep.
See Also: ON_Brep::StandardizeTrimCurve ON_Brep::Standardize
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeTrimCurve(System.Int32)">
            <summary>
Standardizes the relationship between an ON_BrepTrim and the 2d curve it uses.
When done, the trim will be the only trim that references its 2d curve,
the domains of the trim and 2d curve will be the same, and the trim will use
the entire locus of the 2d curve.
</summary>
            <param name="trim_index">[in] index of trim to standardize.</param>
            <remarks>
See Also: ON_Brep::StandardizeTrimCurves ON_Brep::Standardize
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeEdgeCurves(System.Boolean)">
            <summary>Standardize all edges in the brep.</summary>
            <param name="bAdjustEnds">[in] if true, move edge curve endpoints to vertices</param>
            <remarks>See Also: ON_Brep::StandardizeEdgeCurve ON_Brep::Standardize</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.StandardizeEdgeCurve(System.Int32,System.Boolean)">
            <summary>
Standardizes the relationship between an ON_BrepEdge and the 3d curve it uses.
When done, the edge will be the only edge that references its 3d curve, the domains
of the edge and 3d curve will be the same, and the edge will use the entire locus
of the 3d curve.
</summary>
            <param name="edge_index">[in] index of edge to standardize.</param>
            <param name="bAdjustEnds">[in] if true, move edge curve endpoints to vertices</param>
            <remarks>See Also: ON_Brep::StandardizeEdgeCurves ON_Brep::Standardize</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ExtractFace(System.Int32)">
            <summary>Extract a face from a brep.</summary>
            <param name="face_index">[in] index of face to extract</param>
            <returns>Single face brep.</returns>
            <remarks>
See Also: ON_Brep::DeleteFace, ON_Brep::DuplicateFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DuplicateFaces(System.Int32[],System.Boolean)">
            <summary>Duplicate a a subset of a brep</summary>
            <param name="face_index">[in] array of face indices</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>A brep made by duplicating the faces listed in the face_index[] array.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DuplicateFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DuplicateFace(System.Int32,System.Boolean)">
            <summary>Duplicate a single brep face.</summary>
            <param name="face_index">[in] index of face to duplicate</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>Single face brep.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DeleteFace, ON_Brep::ExtractFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RegionTopology">
            <summary>
Get region topology information:
In order to keep the ON_Brep class efficient, rarely used
region topology information is not maintained.  If you 
require this information, call RegionTopology().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SubBrep(System.Int32[],RMA.OpenNURBS.OnBrep)">
            <summary>Copy a subset of this brep.</summary>
            <param name="sub_fi">
[in] array of face indices in this brep to copy. (If any values in sub_fi[]
are out of range or if sub_fi[] contains duplicates, this function will return null.)
</param>
            <param name="sub_brep">
[in] if this pointer is not null, then the subbrep will be created in this class.
</param>
            <returns>
If the input is valid, a pointer to the subbrep is returned.
If the input is not valid, null is returned.  The faces in
in the subbrep's m_F array are in the same
order as they were specified in sub_fi[].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetConnectedComponents(RMA.OpenNURBS.OnBrep[]@,System.Boolean)">
            <summary>
If this brep has two or more connected components,
then duplicates of the connected components are appended to the components[] array.
</summary>
            <param name="components">[in] connected components are appended to this array.</param>
            <param name="bDuplicateMeshes">[in] if true, any meshes on this brep are copied to the output breps.</param>
            <returns>
Number of connected components appended to components[] or
zero if this brep has only one connected component.
See Also: ON_Brep::GetConnectedComponents
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LabelConnectedComponents">
            <summary>
Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i, and m_trim_user.i
values values to distinguish connected components.
</summary>
            <returns>number of connected components</returns>
            <remarks>
For each face in the ith component, sets m_face_user.i to i&gt;0.
Chases through trim lists of face edges to find adjacent faces.
Numbering starts at 1. Does NOT check for vertex-vertex connections.
See Also: ON_Brep::GetConnectedComponents
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LabelConnectedComponent(System.Int32,System.Int32)">
            <summary>
Set m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of faces of component including
m_F[face_index] to label. Numbering starts at 1.
</summary>
            <param name="face_index">[in] index of face in component</param>
            <param name="label">[in] value for m_*_user.i</param>
            <remarks>
Chases through trim lists of face edges to find adjacent faces.
Does NOT check for vertex-vertex connections
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Delete3dCurve(System.Int32)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Delete2dCurve(System.Int32)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteSurface(System.Int32)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteFace(RMA.OpenNURBS.OnBrepFace@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete edges and vertices used only by face
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteLoop(RMA.OpenNURBS.OnBrepLoop@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete edges and vertices used only by trim
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteTrim(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete edges and vertices used only by trim
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteEdge(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.

pass true to delete vertices used only by edge
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DeleteVertex(RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These remove a topology piece from a b-rep but do not
rearrange the arrays that hold the brep objects.  The
deleted objects have their indices set to -1.  Deleting
an object that is connected to other objects will 
modify thos objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitBipolarFaces">
            <summary>
Splits surfaces with two singularities, like spheres, so the results have at most one singularity.
</summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitClosedFaces">
            <summary>Splits closed surfaces so they are not closed.</summary>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitClosedFaces(System.Int32)">
            <summary>Splits closed surfaces so they are not closed.</summary>
            <param name="min_degree">
[in] If the degree of the surface &lt; min_degree, the surface is not split.
In some cases, min_degree = 2 is useful to preserve piecewise linear surfaces.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitEdge(System.Int32,System.Double,RMA.OpenNURBS.IArraydouble)">
            <summary>
Expert user function. Splits an edge into two edges.
The input edge becomes the left portion and a new edge is created for the right portion.
</summary>
            <param name="edge_index">[in] index of edge in brep.m_E[]</param>
            <param name="edge_t">[in] 3d edge splitting parameter</param>
            <param name="trim_t">
[in] array of trim splitting parameters. trim_t[eti] is the parameter for
splitting the trim brep.m_T[edge.m_ti[eti]].
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitEdge(System.Int32,System.Double,RMA.OpenNURBS.IArraydouble,System.Int32)">
            <summary>
Expert user function. Splits an edge into two edges.
The input edge becomes the left portion and a new edge is created for the right portion.
</summary>
            <param name="edge_index">[in] index of edge in brep.m_E[]</param>
            <param name="edge_t">[in] 3d edge splitting parameter</param>
            <param name="trim_t">
[in] array of trim splitting parameters. trim_t[eti] is the parameter for
splitting the trim brep.m_T[edge.m_ti[eti]].
</param>
            <param name="vertex_index">
[in] if not -1, then this vertex will be used for the new vertex.
Otherwise a new vertex is created.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitEdge(System.Int32,System.Double,RMA.OpenNURBS.IArraydouble,System.Int32,System.Boolean)">
            <summary>
Expert user function. Splits an edge into two edges.
The input edge becomes the left portion and a new edge is created for the right portion.
</summary>
            <param name="edge_index">[in] index of edge in brep.m_E[]</param>
            <param name="edge_t">[in] 3d edge splitting parameter</param>
            <param name="trim_t">
[in] array of trim splitting parameters. trim_t[eti] is the parameter for
splitting the trim brep.m_T[edge.m_ti[eti]].
</param>
            <param name="vertex_index">
[in] if not -1, then this vertex will be used for the new vertex.
Otherwise a new vertex is created.
</param>
            <param name="bSetTrimBoxesAndFlags">
[in] if true, trim boxes and flags are set.
If false, the user is responsible for doing this.
Set to true if you are unsure what to use.
If you pass false, then need to call SetTrimBoundingBoxes(..,bLazy=true) so
that the trim iso flags and bounding info is correctly updated.
If you pass true, then the trim flags and bounding boxes get set inside of SplitEdge.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetEdgeParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the 2d trim curve, get the corresponding parameter on the 3d edge curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="trim_t">[in] parameter on 2d trim curve</param>
            <param name="edge_t">[out] parameter on 3d edge</param>
            <returns>
TRUE successful
FALSE failure - edge_t not set
See Also: TL_Brep::GetTrimParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@,System.Boolean)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <param name="bOkToBuildTrimPline">
[in] if TRUE and m_T[trim_index].m_pline[] does not have its edge parameters set,
then they are filled in. This is slow the first time, but greatly increases the
speed of GetTrimParameter and GetEdgeParameter on subsequent calls.
</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineContiguousEdges(System.Int32,System.Int32)">
            <summary>
Expert user function. Combines contiguous edges into a single edge.
The edges must share a common vertex, then angle between the edge
tangents are the common vertex must be less than or equal to angle_tolerance_radians,
and any associated trims must be contiguous in there respective boundaries.
</summary>
            <param name="edge_index0">[in]</param>
            <param name="edge_index1">[in]</param>
            <returns>Pointer to the new edge or NULL if the edges cannot be combined into a single edge.</returns>
            <remarks>
The input edges are deleted but are still in the brep's m_E[] arrays.
Use ON_Brep::Compact to remove the unused edges.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineContiguousEdges(System.Int32,System.Int32,System.Double)">
            <summary>
Expert user function. Combines contiguous edges into a single edge.
The edges must share a common vertex, then angle between the edge
tangents are the common vertex must be less than or equal to angle_tolerance_radians,
and any associated trims must be contiguous in there respective boundaries.
</summary>
            <param name="edge_index0">[in]</param>
            <param name="edge_index1">[in]</param>
            <param name="angle_tolerance_radians">[in]</param>
            <returns>Pointer to the new edge or NULL if the edges cannot be combined into a single edge.</returns>
            <remarks>
The input edges are deleted but are still in the brep's m_E[] arrays.
Use ON_Brep::Compact to remove the unused edges.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineCoincidentEdges(RMA.OpenNURBS.OnBrepEdge@,RMA.OpenNURBS.OnBrepEdge@)">
            <summary>
Expert user function. See Also: ON_Brep::JoinEdges
moves information to first edge and deletes second
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CombineCoincidentVertices(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
Expert user function. See Also: ON_Brep::JoinEdges
moves information to first vertex and deletes second
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.JoinEdges(RMA.OpenNURBS.OnBrepEdge@,RMA.OpenNURBS.OnBrepEdge@,System.Double)">
            <summary>Join coincident edges.</summary>
            <param name="edge">
[in] this edge will survive the joining process and the vertices at
its ends will survive the joining process.
</param>
            <param name="other_edge">[in] this edge and the vertices at its ends will be removed.</param>
            <param name="join_tolerance">
[in] The distances between the ends of edge and other_edge must be at most
join_tolerance in order for the edges to be joined. The caller is responsible
for insuring that the 3d location of other_edge is within join_tolerance of edge.
</param>
            <returns>true if join is successful</returns>
            <example>
extrude an edge of a brep to make a new face
NOTE WELL:
THIS IS A SIMPLE EXAMPLE THAT IS NOT VERY EFFICIENT
Use ON_BrepExtrudeEdge if you really want to extrude an edge.
ON_Brep brep = ...;
edge = some valid edge in brep
const ON_BrepEdge&amp; edge = brep.m_E[...];
extrude edge to make a surface
ON_3dVector v = ...;
ON_SumSurface* new_surface = new ON_SumSurface();
new_surface-&gt;Create( edge, v );
ON_Brep new_brep;
new_brep.AddFace( Create( new_surface );
brep.
See Also: ON_Brep:CullUnusedEdges ON_Brep:CullUnusedVertices ON_Brep:CullUnused3dCurves
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.JoinEdges(RMA.OpenNURBS.OnBrepEdge@,RMA.OpenNURBS.OnBrepEdge@,System.Double,System.Boolean)">
            <summary>Join coincident edges.</summary>
            <param name="edge">
[in] this edge will survive the joining process and the vertices at
its ends will survive the joining process.
</param>
            <param name="other_edge">[in] this edge and the vertices at its ends will be removed.</param>
            <param name="join_tolerance">
[in] The distances between the ends of edge and other_edge must be at most
join_tolerance in order for the edges to be joined. The caller is responsible
for insuring that the 3d location of other_edge is within join_tolerance of edge.
</param>
            <param name="bCheckFaceOrientaion">
[in] If true and edge and other_edge are boundary edges, then the orientation of
the face using other_edge is adjusted to match the orientation of the face using edge.
</param>
            <returns>true if join is successful</returns>
            <example>
extrude an edge of a brep to make a new face
NOTE WELL:
THIS IS A SIMPLE EXAMPLE THAT IS NOT VERY EFFICIENT
Use ON_BrepExtrudeEdge if you really want to extrude an edge.
ON_Brep brep = ...;
edge = some valid edge in brep
const ON_BrepEdge&amp; edge = brep.m_E[...];
extrude edge to make a surface
ON_3dVector v = ...;
ON_SumSurface* new_surface = new ON_SumSurface();
new_surface-&gt;Create( edge, v );
ON_Brep new_brep;
new_brep.AddFace( Create( new_surface );
brep.
See Also: ON_Brep:CullUnusedEdges ON_Brep:CullUnusedVertices ON_Brep:CullUnused3dCurves
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RebuildEdges(RMA.OpenNURBS.OnBrepFace@,System.Double,System.Boolean,System.Boolean)">
            <summary>
Rebuild the edges used by a face so they lie on the surface.
</summary>
            <param name="face">[in] face whose surface should be changed</param>
            <param name="tolerance">[in] tolerance for fitting 3d edge curves</param>
            <param name="bRebuildSharedEdges">
[in] if false and and edge is used by this face and a neighbor, then the edge will be skipped.
</param>
            <param name="bRebuildVertices">[in] if true, vertex locations are updated to lie on the surface.</param>
            <remarks>See Also: ON_Brep::RebuildEdges</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SortFaceLoops(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Sort the face.m_li[] array by loop type (outer, inner, slit, crvonsrf, ptonsrf)
</summary>
            <param name="face">[in/out] face whose m_li[] array should be sorted.</param>
            <returns>
true success
false failure - no loops or loops with unset loop.m_type
See Also: ON_Brep::ComputeLoopType ON_Brep::LoopDirection
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LoopDirection(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
LoopDirection() examines the 2d trimming curve geometry that defines
the loop and returns
 +1    the loop is a counter-clockwise loop.
 -1    the loop is a clockwise loop.
  0    the loop is not a continuous closed loop.
Since LoopDirection() calculates its result based on the 2d trimming
curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner
when translating from data definition where this distinction is murky.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FlipLoop(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
Reverses orientation of trimming loop. 
This function is intended to be used by brep experts and does
does NOT modify ON_BrepLoop::m_type.  You should make sure 
ON_BrepLoop::m_type jibes with the loop's direction.  (Outer loops
should be counter-clockwise and inner loops should be clockwise.)
You can use ON_Brep::LoopDirection() to determine the direction of
a loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FlipFace(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
reverses orientation of a face by toggling ON_BrepFace::m_bRev
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Flip">
            <summary>
Reverses entire brep orientation of all faces by toggling 
value of all face's ON_BrepFace::m_bRev flag.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeDomain(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
Change the domain of an edge.  This changes only the
parameterization of the 3d edge curve; the locus of the 
3d edge curve is not changed.
</summary>
            <param name="edge_index">index of edge in m_E[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimDomain(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
Change the domain of a trim's 2d curve.  This changes only the
parameterization of the 2d trimming curve; the locus of the 
2d trimming curve is not changed.
</summary>
            <param name="trim_index">index of trim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FlipReversedSurfaces">
            <summary>
Clears all ON_BrepFace.m_bRev flags by ON_BrepFace::Transpose
on each face with a true m_bRev.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.LoopIsSurfaceBoundary(System.Int32)">
            <summary>
returns true if the loop's trims all run along the edge's of the underlying surface's
parameter space.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.FaceIsSurface(System.Int32)">
returns true if the face has a single outer boundary and that boundary runs
along the edges of the underlying surface. In this case the geometry of the surface
is the same as the geometry of the face. If FaceIsSurface() is true, then
m_S[m_F[face_index].m_si] is the surface. The flag m_F[face_index].m_bRev records
the correspondence between the surface's natural parametric orientation and the
orientation of face in the b-rep.
</member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsSurface">
            <summary>
returns true if the b-rep has a single face
and that face is geometrically the same
as the underlying surface.  I.e., the face
has trivial trimming.  In this case, the
surface is m_S[0].
The flag m_F[0].m_bRev records
the correspondence between the surface's
natural parametric orientation and the
orientation of the b-rep.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsPointInside(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Boolean)">
            <summary>
Determine if P is inside Brep.  This question only makes sense
when the brep is a closed manifold.  This function does not
not check for closed or manifold, so result is not valid in
those cases.  Intersects a line through P with brep, finds
the intersection point Q closest to P, and looks at face 
normal at Q.  If the point Q is on an edge or the intersection
is not transverse at Q, then another line is used.
</summary>
            <param name="P">[in] 3d point</param>
            <param name="tolerance">
[in] 3d distance tolerance used for intersection and determining strict inclusion.
</param>
            <param name="bStrictlyInside">
[in] If bStrictlInside is true, then this function will return false
if the distance from P is within tolerance of a brep face.
</param>
            <returns>True if P is in, false if not. See parameter bStrictlyIn.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsManifold">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsManifold(System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsManifold(System.Boolean@,System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <param name="pbHasBoundary">
[in] if not null, *pbHasBoundary is set to true if b-rep has a boundary edge
and false if brep does not have a boundary edge.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsSolid">
            <summary>
Test brep to see if it is a solid. (A "solid" is a closed oriented manifold.)
</summary>
            <returns>
true brep is a solid fals brep is not a solid
See Also: ON_Brep::SolidOrientation ON_Brep::IsManifold
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SolidOrientation">
            <summary>Determine orientation of a brep.</summary>
            <returns>
+2 brep is a solid but orientation cannot be computed
+1 brep is a solid with outward facing normals
-1 brep is a solid with inward facing normals
0 brep is not a solid
</returns>
            <remarks>
The base class implementation returns 2 or 0. This function is 
overridden in the Rhino SDK and returns +1, -1, or 0.
See Also: ON_Brep::IsSolid
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop2dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 2d curve should be duplicated</param>
            <returns>A pointer to a 2d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@,System.Boolean)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curves have an orientation compatible with
the 2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curves are reversed.
</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,System.Boolean)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curve has an orientation compatible with the
2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curve is reversed.
</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimCurveUseCount(System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count trims use the 2d curve.
</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.EdgeCurveUseCount(System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.EdgeCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count edges use the 3d curve.
</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SurfaceUseCount(System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SurfaceUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <param name="max_count">[in] counting stops if max_count &gt; 0 and at least max_count faces use the surface.</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags">
            <summary>Set tolerances and flags in a brep</summary>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <param name="bSetTrimTypeFlags">[in] true to compute trim.m_type values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <param name="bSetTrimTypeFlags">[in] true to compute trim.m_type values</param>
            <param name="bSetLoopTypeFlags">[in] true to compute loop.m_type values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTolerancesBoxesAndFlags(System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Set tolerances and flags in a brep</summary>
            <param name="bLazy">[in] if true, only flags and tolerances that are not set will be calculated.</param>
            <param name="bSetVertexTolerances">[in] true to compute vertex.m_tolerance values</param>
            <param name="bSetEdgeTolerances">[in] true to compute edge.m_tolerance values</param>
            <param name="bSetTrimTolerances">[in] true to compute trim.m_tolerance[0,1] values</param>
            <param name="bSetTrimIsoFlags">[in] true to compute trim.m_iso values</param>
            <param name="bSetTrimTypeFlags">[in] true to compute trim.m_type values</param>
            <param name="bSetLoopTypeFlags">[in] true to compute loop.m_type values</param>
            <param name="bSetTrimBoxes">[in] true to compute trim.m_pbox values</param>
            <remarks>
See Also:
ON_Brep::SetVertexTolerance ON_Brep::SetEdgeTolerance ON_Brep::SetTrimTolerance ON_Brep::SetTrimTypeFlags ON_Brep::SetTrimIsoFlags ON_Brep::ComputeLoopType ON_Brep::SetTrimBoundingBox ON_Brep::SetTrimBoundingBoxes
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the brep.
</summary>
            <returns>true if all the loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(System.Boolean)">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the brep.
</summary>
            <param name="bLazy">
[in] if true and trim trim.m_pbox is valid, then that trim.m_pbox is not recalculated.
</param>
            <returns>true if all the loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the face
</summary>
            <param name="face">[in]</param>
            <returns>true if all the face's loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepFace@,System.Boolean)">
            <summary>
Set the loop and trim parameter space bounding boxes for every loop and trim in the face
</summary>
            <param name="face">[in]</param>
            <param name="bLazy">[in] if true and trim trim.m_pbox is valid, then that trim.m_pbox is not recalculated.</param>
            <returns>true if all the face's loop and trim parameter space bounding boxes are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>Set the loop parameter space bounding box (loop.m_pbox).</summary>
            <param name="loop">[in]</param>
            <returns>true if loop ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBoxes(RMA.OpenNURBS.OnBrepLoop@,System.Boolean)">
            <summary>Set the loop parameter space bounding box (loop.m_pbox).</summary>
            <param name="loop">[in]</param>
            <param name="bLazy">
[in] if true and loop trim trim.m_pbox is valid, then that trim.m_pbox is not recalculated.
</param>
            <returns>true if loop ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBox(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>Set the trim parameter space bounding box (trim.m_pbox).</summary>
            <param name="trim">[in]</param>
            <returns>true if trim ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimBoundingBox(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>Set the trim parameter space bounding box (trim.m_pbox).</summary>
            <param name="trim">[in]</param>
            <param name="bLazy">[in] if true and trim.m_pbox is valid, then the box is not set.</param>
            <returns>true if trim ends up with a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerances">
            <summary>Set the brep's edge tolerances.</summary>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerances(System.Boolean)">
            <summary>Set the brep's edge tolerances.</summary>
            <param name="bLazy">
[in] if true, only edge tolerances with the value ON_UNSET_VALUE will be set.
If false, the edge tolerance is recomputed from the geometry in the brep.
</param>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerances">
            <summary>Set the brep's trim tolerances.</summary>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerances(System.Boolean)">
            <summary>Set the brep's trim tolerances.</summary>
            <param name="bLazy">
[in] if true, only trim tolerances with the value ON_UNSET_VALUE will be set.
If false, the trim tolerance is recomputed from the geometry in the brep.
</param>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerances">
            <summary>Set the brep's vertex tolerances.</summary>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerances(System.Boolean)">
            <summary>Set the brep's vertex tolerances.</summary>
            <param name="bLazy">
[in] if true, only vertex tolerances with the value ON_UNSET_VALUE will be set.
If false, the vertex tolerance is recomputed from the geometry in the brep.
</param>
            <returns>
true if successful.
See Also:
ON_Brep::SetVertexTolerance
ON_Brep::SetTrimTolerance
ON_Brep::SetEdgeTolerance
ON_Brep::SetVertexTolerances
ON_Brep::SetTrimTolerances
ON_Brep::SetEdgeTolerances
ON_Brep::SetTolerancesAndFlags
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.ComputeLoopType(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
This function examines the 2d parameter space curves and returns
the loop's type based on their orientation.  Use this function for
debugging loop orientation problems.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim3dEnd(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dEnd() evaluates the 3d surface at the end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim3dStart(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dStart() evaluates the 3d surface at the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim2dEnd(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dEnd() evaluates end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetTrim2dStart(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dStart() evaluates the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepLoop@,System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(RMA.OpenNURBS.OnBrepFace@,System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances

sets all trim iso flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimTypeFlags(System.Boolean)">
            <summary>
This function can be used to set the ON_BrepTrim::m_type
flag.  If the optional bLazy argument is true, then only
trims with m_type = unknown are set.
See Also: ON_BrepSetFlagsAndTolerances

sets all trim iso flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim,System.Boolean)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <param name="bLazy">
[in] if true and trim.m_type is set to something other than ON_BrepTrim::unknown,
then no calculation is performed and the value of trim.m_type is returned.
If false, the value of trim.m_type is ignored and is caluculated.
</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags(RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimIsoFlags">
            <summary>
This function can be used to set the ON_BrepTrim::m_iso
flag. It is intended to be used when creating a ON_Brep from
a definition that does not include compatible parameter space
type information.
See Also: ON_BrepSetFlagsAndTolerances

sets all trim iso flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetVertices">
            <summary>
This function can be used to compute vertex information for a
b-rep when everything but the m_V array is properly filled in.
It is intended to be used when creating a ON_Brep from a 
definition that does not include explicit vertex information.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Append(RMA.OpenNURBS.IOnBrep)">
            <summary>
appends a copy of brep to this and updates
indices of appended brep parts.  Duplicates are not removed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewCurveOnFace(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.OnBrepEdge@)">
            <summary>Add a new curve on face to the brep.</summary>
            <param name="face">[in] face that curve lies on</param>
            <param name="edge">[in] 3d edge associated with this curve on surface</param>
            <returns>new trim that represents the curve on surface</returns>
            <remarks>You should set the trim's ON_BrepTrim::m_tolerance and ON_BrepTrim::m_iso values.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewCurveOnFace(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>Add a new curve on face to the brep.</summary>
            <param name="face">[in] face that curve lies on</param>
            <param name="edge">[in] 3d edge associated with this curve on surface</param>
            <param name="bRev3d">[in] true if the 3d edge and the 2d parameter space curve have opposite directions.</param>
            <returns>new trim that represents the curve on surface</returns>
            <remarks>You should set the trim's ON_BrepTrim::m_tolerance and ON_BrepTrim::m_iso values.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewCurveOnFace(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.OnBrepEdge@,System.Boolean,System.Int32)">
            <summary>Add a new curve on face to the brep.</summary>
            <param name="face">[in] face that curve lies on</param>
            <param name="edge">[in] 3d edge associated with this curve on surface</param>
            <param name="bRev3d">[in] true if the 3d edge and the 2d parameter space curve have opposite directions.</param>
            <param name="c2i">[in] index of 2d curve in face's parameter space</param>
            <returns>new trim that represents the curve on surface</returns>
            <remarks>You should set the trim's ON_BrepTrim::m_tolerance and ON_BrepTrim::m_iso values.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewPointOnFace(RMA.OpenNURBS.OnBrepFace@,System.Double,System.Double)">
            <summary>Adds a new point on face to the brep.</summary>
            <param name="face">[in] face that vertex lies on</param>
            <param name="s">[in] surface parameters</param>
            <param name="t">[in] surface parameters</param>
            <returns>new vertex that represents the point on face.</returns>
            <remarks>
If a vertex is a point on a face, then brep.m_E[m_ei] will be an edge with no 3d curve.
This edge will have a single trim with type ON_BrepTrim::ptonsrf. There will be a loop
containing this single trim.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewSingularTrim(RMA.OpenNURBS.IOnBrepVertex,RMA.OpenNURBS.OnBrepLoop@,RMA.OpenNURBS.IOnSurface.ISO)">
            <summary>Add a new singular trim to the brep.</summary>
            <param name="vertex">[in] vertex along collapsed surface edge</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="iso">[in] one of ON_Surface::S_iso, ON_Surface::E_iso, ON_Surface::N_iso, or ON_Surface::W_iso.</param>
            <returns>
new trim
See Also: ON_Brep::NewTrim
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewSingularTrim(RMA.OpenNURBS.IOnBrepVertex,RMA.OpenNURBS.OnBrepLoop@,RMA.OpenNURBS.IOnSurface.ISO,System.Int32)">
            <summary>Add a new singular trim to the brep.</summary>
            <param name="vertex">[in] vertex along collapsed surface edge</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="iso">[in] one of ON_Surface::S_iso, ON_Surface::E_iso, ON_Surface::N_iso, or ON_Surface::W_iso.</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>
new trim
See Also: ON_Brep::NewTrim
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean,RMA.OpenNURBS.OnBrepLoop@)">
            <summary>Add a new trim that will be part of an inner, outer, or slit loop to the brep.</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = brep-&gt;NewTrim( edge, bRev3d, loop, c2i );
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance values. If c2i is -1,
you must set the trim's ON_BrepTrim::m_iso values.
This version of NewTrim sets the trim.m_type value. If the input edge or loop 
are not currently valid, then you may need to adjust the trim.m_type value.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean,RMA.OpenNURBS.OnBrepLoop@,System.Int32)">
            <summary>Add a new trim that will be part of an inner, outer, or slit loop to the brep.</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = brep-&gt;NewTrim( edge, bRev3d, loop, c2i );
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance values. If c2i is -1,
you must set the trim's ON_BrepTrim::m_iso values.
This version of NewTrim sets the trim.m_type value. If the input edge or loop 
are not currently valid, then you may need to adjust the trim.m_type value.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, c2i );
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, and ON_BrepTrim::m_li values. In general, you should try
to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags 
ON_Brep::NewSingularTrim 
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(RMA.OpenNURBS.OnBrepEdge@,System.Boolean,System.Int32)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="edge">[in] 3d edge associated with this trim</param>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, c2i );
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, and ON_BrepTrim::m_li values. In general, you should try
to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim.
If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags 
ON_Brep::NewSingularTrim 
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(System.Boolean,RMA.OpenNURBS.OnBrepLoop@)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...; 
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type, ON_BrepTrim::m_iso,
and ON_BrepTrim::m_ei values. In general, you should try to use the
ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim. If you want to add a singular
trim, use ON_Brep::NewSingularTrim. If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(System.Boolean,RMA.OpenNURBS.OnBrepLoop@,System.Int32)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="bRev3d">[in] ON_BrepTrim::m_bRev3d value. true if the edge and trim have opposite directions.</param>
            <param name="loop">[in] trim is appended to this loop</param>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...; 
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type, ON_BrepTrim::m_iso,
and ON_BrepTrim::m_ei values. In general, you should try to use the
ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i ) version of NewTrim. If you want to add a singular
trim, use ON_Brep::NewSingularTrim. If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace.
If you want to add a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.
In general, you should try to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i )
version of NewTrim. If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace. If you want to add
a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewTrim(System.Int32)">
            <summary>
Add a new trim that will be part of an inner, outer, or slit loop to the brep.
</summary>
            <param name="c2i">[in] index of 2d trimming curve</param>
            <returns>new trim</returns>
            <example>
int c2i = brep-&gt;
AddTrimCurve( p2dCurve );
ON_BrepTrim&amp; trim = NewTrim( edge, bRev3d, loop, c2i );
trim.m_ei = ...;
trim.m_li = ...;
trim.m_tolerance[0] = ...;
trim.m_tolerance[1] = ...;
trim.m_type = ...;
trim.m_iso = ...;
</example>
            <remarks>
You should set the trim's ON_BrepTrim::m_tolerance, ON_BrepTrim::m_type,
ON_BrepTrim::m_iso, ON_BrepTrim::m_li, and ON_BrepTrim::m_ei values.
In general, you should try to use the ON_BrepTrim::NewTrim( edge, bRev3d, loop, c2i )
version of NewTrim. If you want to add a singular trim, use ON_Brep::NewSingularTrim.
If you want to add a crvonsrf trim, use ON_Brep::NewCurveOnFace. If you want to add
a ptonsrf trim, use ON_Brep::NewPointOnFace.
See Also:
ON_Brep::SetTrimTypeFlags
ON_Brep::SetTrimIsoFlags
ON_Brep::NewSingularTrim
ON_Brep::NewPointOnFace
ON_Brep::NewCurveOnFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewPlanarFaceLoop(System.Int32,RMA.OpenNURBS.IOnBrepLoop.TYPE,RMA.OpenNURBS.OnCurve[])">
            <summary>Add a planar trimming loop to a planar face.</summary>
            <param name="face_index">[in] index of planar face. The underlying suface must be an ON_PlaneSurface.</param>
            <param name="loop_type">
[in] type of loop to add. If loop_type is ON_BrepLoop::unknown, then the loop
direction is tested and the the new loops type will be set to ON_BrepLoop::outer
or ON_BrepLoop::inner. If the loop_type is ON_BrepLoop::outer, then the direction
of the new loop is tested and flipped if it is clockwise. If the loop_type is
ON_BrepLoop::inner, then the direction of the new loop is tested and flipped if
it is counter-clockwise.
</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections) closed curve.
These curves define the 3d edge geometry and should be near the planar surface.
</param>
            <returns>true if successful. The new loop will be brep.m_L.Last().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewPlanarFaceLoop(System.Int32,RMA.OpenNURBS.IOnBrepLoop.TYPE,RMA.OpenNURBS.OnCurve[],System.Boolean)">
            <summary>Add a planar trimming loop to a planar face.</summary>
            <param name="face_index">[in] index of planar face. The underlying suface must be an ON_PlaneSurface.</param>
            <param name="loop_type">
[in] type of loop to add. If loop_type is ON_BrepLoop::unknown, then the loop
direction is tested and the the new loops type will be set to ON_BrepLoop::outer
or ON_BrepLoop::inner. If the loop_type is ON_BrepLoop::outer, then the direction
of the new loop is tested and flipped if it is clockwise. If the loop_type is
ON_BrepLoop::inner, then the direction of the new loop is tested and flipped if
it is counter-clockwise.
</param>
            <param name="boundary">
[in] a list of 3d curves that form a simple (no self intersections) closed curve.
These curves define the 3d edge geometry and should be near the planar surface.
</param>
            <param name="bDuplicateCurves">
[in] If true, then duplicates of the curves in the boundary array are added to the brep.
If false, the curves in the boundary array are added to the brep and will be deleted
by ON_Brep::~ON_Brep.
</param>
            <returns>true if successful. The new loop will be brep.m_L.Last().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewOuterLoop(System.Int32,System.Int32[],System.Int32[],System.Int32[])">
            <summary>
Add a new face to brep. This version is for expert users.
</summary>
            <param name="face_index">
[in] index of face that will get a new outer loop running around the sides of the
face's underlying surface.
</param>
            <param name="vid">
[in/out] four vertex indices that specify the vertices at the (sw,se,nw,ne) corners.
If the input value of a vertex index is -1, then the vertex will be created.
</param>
            <param name="eid">
[in/out] four edge indices that specify the edges for the (south,east,north,west) sides.
If the input value of an edge index is -1, then the edge will be created.
</param>
            <param name="bRev3d">
[in/out] four values of the trim m_bRev3d flags of the (south,east,north,west) sides.
</param>
            <returns>Pointer to the new loop or NULL if input is not valid.</returns>
            <remarks>
Adding a new loop may grow the dynamic m_L array. When this happens pointers and
references to memory in the previous m_L[] array may become invalid. Use face
indices if this is an issue.
See Also: ON_Brep::NewFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewOuterLoop(System.Int32)">
            <summary>
Create a new outer boundary loop that runs along the sides of the face's surface.
All the necessary trims, edges, and vertices are created and added to the brep.
</summary>
            <param name="face_index">
[in] index of face that needs an outer boundary that runs along the sides of its surface.
</param>
            <returns>New outer boundary loop that is complete.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewLoop(RMA.OpenNURBS.IOnBrepLoop.TYPE,RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Create a new boundary loop on a face. After you get this ON_BrepLoop, you
still need to create the vertices, edges, and trims that define the loop.
</summary>
            <returns>New loop that needs to be filled in.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewLoop(RMA.OpenNURBS.IOnBrepLoop.TYPE)">
            <summary>
Create a new outer boundary loop that runs along the edges of the underlying surface.
</summary>
            <returns>New outer boundary loop.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewConeFace(RMA.OpenNURBS.IOnBrepVertex,RMA.OpenNURBS.IOnBrepEdge,System.Boolean)">
            <summary>
Add a new face to the brep whose surface geometry is a ruled cone with the edge as
the base and the vertex as the apex point.
</summary>
            <param name="vertex">
[in] The apex of the cone will be at this vertex. The north side of the surface's
parameter space will be a singular point at the vertex.
</param>
            <param name="edge">[in] The south side of the face's surface will run along this edge.</param>
            <param name="bRevEdge">
[in] true if the new face's outer boundary orientation along the edge is
opposite the orientation of edge.
</param>
            <returns>A pointer to the new face or a NULL if the new face could not be created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewRuledFace(RMA.OpenNURBS.IOnBrepEdge,System.Boolean,RMA.OpenNURBS.IOnBrepEdge,System.Boolean)">
            <summary>
Add a new face to the brep whose surface geometry is a ruled surface between two edges.
</summary>
            <param name="edgeA">[in] The south side of the face's surface will run along edgeA.</param>
            <param name="bRevEdgeA">
[in] true if the new face's outer boundary orientation along edgeA is opposite the orientation of edgeA.
</param>
            <param name="edgeB">[in] The north side of the face's surface will run along edgeA.</param>
            <param name="bRevEdgeB">
[in] true if the new face's outer boundary orientation along edgeB is opposite the orientation of edgeB.
</param>
            <returns>A pointer to the new face or a NULL if the new face could not be created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace(RMA.OpenNURBS.OnSurface,System.Int32[],System.Int32[],System.Boolean[])">
            <summary>Add a new face to brep. This version is for expert users.</summary>
            <param name="pSurface">
[in] the returned face will have an outer loop that goes around the edges of the surface.
</param>
            <param name="vid">
[in/out] four vertex indices that specify the vertices at the (sw,se,nw,ne) corners.
If the input value of a vertex index is -1, then the vertex will be created.
</param>
            <param name="eid">
[in/out] four edge indices that specify the edges for the (south,east,north,west) sides.
If the input value of an edge index is -1, then the edge will be created.
</param>
            <param name="bRev3d">
[in/out] four values of the trim m_bRev3d flags of the (south,east,north,west) sides.
</param>
            <returns>Pointer to the new face or NULL if input is not valid.</returns>
            <remarks>
Adding a new face may grow the dynamic m_F array. When this happens pointers
and references to memory in the previous m_F[] array may become invalid.
Use face indices if this is an issue.
Example: See ON_BrepBox and ON_BrepSphere source code.
See Also: ON_Brep::AddSurface ON_Brep::AddFace( int si ) ON_Brep::Create( ON_Surface*&amp; )
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace(RMA.OpenNURBS.IOnSurface)">
            <summary>
Add a new face to a brep. This creates a complete face with new vertices
at the surface corners, new edges along the surface boundary, etc. The
loop of the returned face has four trims that correspond to the south,
east, north, and west side of the surface in that order. If you use this 
version of NewFace to add an exiting brep, then you are responsible for
using a tool like ON_Brep::JoinEdges() to hook the new face to its neighbors.
</summary>
            <param name="surface">[in] surface is copied.</param>
            <returns>Pointer to new face.</returns>
            <remarks>
Adding a new face may grow the dynamic arrays used to store vertices, edges,
faces, loops, and trims. When these dyamic arrays are grown, any pointers
and references to memory in the previous arrays may become invalid.
Use indices if this is an issue.
See Also: ON_Brep::JoinEdges ON_Brep::AddSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace">
            <summary>
Add a new face to a brep. An incomplete face is added. 
The caller must create and fill in the loops used by the face.
</summary>
            <returns>Reference to new face.</returns>
            <remarks>
Adding a new face may grow the dynamic m_F array. When this happens
pointers and references to memory in the previous m_F[] array may
become invalid. Use face indices if this is an issue.
Example: See ON_BrepBox and ON_BrepSphere source code.
See Also: ON_Brep::AddSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewFace(System.Int32)">
            <summary>
Add a new face to a brep. An incomplete face is added. 
The caller must create and fill in the loops used by the face.
</summary>
            <param name="si">[in] index of surface in brep's m_S[] array</param>
            <returns>Reference to new face.</returns>
            <remarks>
Adding a new face may grow the dynamic m_F array. When this happens
pointers and references to memory in the previous m_F[] array may
become invalid. Use face indices if this is an issue.
Example: See ON_BrepBox and ON_BrepSphere source code.
See Also: ON_Brep::AddSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@,System.Int32)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
            <param name="index">3d curve index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@,System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
            <param name="index">3d curve index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(RMA.OpenNURBS.OnBrepVertex@,RMA.OpenNURBS.OnBrepVertex@,System.Int32,RMA.OpenNURBS.IOnInterval,System.Double)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
            <param name="index">3d curve index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewEdge(System.Int32)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
            <param name="index">3d curve index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewVertex(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewVertex(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.NewVertex">
            <summary>
These add a new topology piece to the b-rep and return a 
reference that is intended to be used for initialization.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimCurve(RMA.OpenNURBS.OnBrepTrim@,System.Int32)">
            <summary>Set 2d curve geometry used by a b-rep trim.</summary>
            <param name="trim">[in]</param>
            <param name="c2_index">[in] index of 2d curve in m_C2[] array</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetTrimCurve(RMA.OpenNURBS.OnBrepTrim@,System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Set 2d curve geometry used by a b-rep trim.</summary>
            <param name="trim">[in]</param>
            <param name="c2_index">[in] index of 2d curve in m_C2[] array</param>
            <param name="sub_domain">
[in] if not NULL, sub_domain is an increasing
sub interval of m_C2[c2_index]-&gt;Domain().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeCurve(RMA.OpenNURBS.OnBrepEdge@,System.Int32)">
            <summary>Set 3d curve geometry used by a b-rep edge.</summary>
            <param name="edge">[in]</param>
            <param name="c3_index">[in] index of 3d curve in m_C3[] array</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SetEdgeCurve(RMA.OpenNURBS.OnBrepEdge@,System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Set 3d curve geometry used by a b-rep edge.</summary>
            <param name="edge">[in]</param>
            <param name="c3_index">[in] index of 3d curve in m_C3[] array</param>
            <param name="sub_domain">
[in] if not NULL, sub_domain is an increasing
sub interval of m_C3[c3_index]-&gt;Domain().
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AddSurface(RMA.OpenNURBS.OnSurface)">
            <summary>
These add a new geometry piece to the b-rep and return the
index that should be used to reference the geometry.
-1 is returned if the input is not acceptable.
~ON_Brep() will delete the geometry.
</summary>
            <param name="surface">3d surface used by ON_BrepFace</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AddEdgeCurve(RMA.OpenNURBS.OnCurve)">
            <summary>
These add a new geometry piece to the b-rep and return the
index that should be used to reference the geometry.
-1 is returned if the input is not acceptable.
~ON_Brep() will delete the geometry.
</summary>
            <param name="curve">3d curve used by ON_BrepEdge</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AddTrimCurve(RMA.OpenNURBS.OnCurve)">
            <summary>
These add a new geometry piece to the b-rep and return the
index that should be used to reference the geometry.
-1 is returned if the input is not acceptable.
~ON_Brep() will delete the geometry.
</summary>
            <param name="curve">2d curve used by ON_BrepTrim</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyEdge(System.Int32)">
            <summary>Split the edge into G1 pieces.</summary>
            <param name="edge_index">[in] Index of the edge to test and split.</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyEdge(System.Int32,System.Double)">
            <summary>Split the edge into G1 pieces.</summary>
            <param name="edge_index">[in] Index of the edge to test and split.</param>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFace(System.Int32)">
            <summary>Split the face into G1 pieces.</summary>
            <param name="face_index">[in] Index of the face to test and split.</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFace(System.Int32,System.Double)">
            <summary>Split the face into G1 pieces.</summary>
            <param name="face_index">[in] Index of the face to test and split.</param>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <returns>True if successful.</returns>
            <remarks>
This function leaves deleted stuff in the brep. Call ON_Brep::Compact() to remove deleted stuff.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFaces">
            <summary>Split any faces with creases into G1 pieces.</summary>
            <returns>True if successful.</returns>
            <remarks>
If you need to detect when splitting occured, comare the before and after values of m_F.Count().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFaces(System.Double)">
            <summary>Split any faces with creases into G1 pieces.</summary>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <returns>True if successful.</returns>
            <remarks>
If you need to detect when splitting occured, comare the before and after values of m_F.Count().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.SplitKinkyFaces(System.Double,System.Boolean)">
            <summary>Split any faces with creases into G1 pieces.</summary>
            <param name="kink_tol_radians">[in] kink tolerance</param>
            <param name="bCompactIfNeeded">
[in] If true and splitting is performed,
ON_Brep::Compact() will be called to clean up the unsued parts.
</param>
            <returns>True if successful.</returns>
            <remarks>
If you need to detect when splitting occured, comare the before and after values of m_F.Count().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.RebuildTrimsForV2(RMA.OpenNURBS.OnBrepFace@,RMA.OpenNURBS.IOnNurbsSurface)">
            <summary>
No support is available for this function. Expert user function
used by MakeValidForV2 to convert trim curves from one surface
to its NURBS form. After calling this function, you need to change
the face's surface to nurbs_surface.
</summary>
            <param name="face">
[in] face whose underlying surface has a parameterization that
is different from its NURBS form.
</param>
            <param name="nurbs_surface">[in] NURBS form of the face's underlying surface</param>
            <remarks>
Don't call this function unless you know exactly what you are doing. No support is available.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.MakeValidForV2">
            <summary>
Change brep so it is valid for saving in V2 3DM archives.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidForV2">
            <summary>
Tests brep to see if it is valid for 
saving in V2 3DM archives.
</summary>
            <returns>true if brep is valid for V2 3DM archives.</returns>
            <remarks>V2 breps could not have dangling curves.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTolerancesAndFlags">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTolerancesAndFlags(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <param name="text_log">
[in] if the brep tolerance or flags are not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidGeometry">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidGeometry(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <param name="text_log">
[in] if the brep geometry is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTopology">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsValidTopology(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <param name="text_log">
[in] if the brep topology is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful
as a high level user interface tool.
</param>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Create(RMA.OpenNURBS.OnSurface)">
            <summary>
Create a brep from a surface. The resulting surface has an outer boundary made
from four trims. The trims are ordered so that they run along the south, east,
north, and then west side of the surface's parameter space.
</summary>
            <param name="pSurface">
[in] pointer to a surface. The brep will manage this pointer and delete it in ~ON_Brep.
</param>
            <returns>
true successful
false brep cannot be created from this surface.
</returns>
            <remarks>
The surface class must be created with new so that the delete in ~ON_Brep will not cause a crash.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.GetMesh(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMesh[]@)">
            <summary>Get cached meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to get</param>
            <param name="meshes">
[out] meshes are appended to this array.
The ON_Brep owns these meshes so the cannot be modified.
</param>
            <returns>
Number of meshes added to array. (Same as m_F.Count())
See Also:
ON_Brep::DestroyMesh
ON_BrepFace::DestroyMesh
ON_BrepFace::Mesh
ON_BrepFace::SetMesh
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>Destroy meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <remarks>
See Also: ON_Brep::GetMesh ON_BrepFace::DestroyMesh ON_BrepFace::Mesh ON_BrepFace::SetMesh
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type,System.Boolean)">
            <summary>Destroy meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <param name="bDeleteMesh">
[in] if true, cached meshes are deleted.
If false, pointers to cached meshes are just set to NULL.
</param>
            <remarks>
See Also: ON_Brep::GetMesh ON_BrepFace::DestroyMesh ON_BrepFace::Mesh ON_BrepFace::SetMesh
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
Calculates polygon mesh approximation of the brep and appends
one mesh for each face to the mesh_list[] array
</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh_list">[out] meshes are appended to this array.</param>
            <returns>Number of meshes appended to mesh_list[] array.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.EmergencyDestroy">
            <summary>
call if memory pool used by b-rep members becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.Destroy">
            <summary>returns Brep to state it has after default construction</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_F">
            <summary>
faces
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_L">
            <summary>
loops
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_T">
            <summary>
trims
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_E">
            <summary>
edges
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_V">
            <summary>
vertices
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_S">
            <summary>
Pointers to parametric surfaces (used by faces)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_C3">
            <summary>
Pointers to 3d curves (used by edges).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrep.m_C2">
            <summary>
Pointers to parameter space trimming curves (used by trims)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Face(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Face(System.Int32)">
            <summary> Get face from face index or component index.</summary>
            <param name="face_index">[in] either an index into m_F[] or a component index of type brep_face.</param>
            <returns>
If the index is a valid face index or a valid face component index,
then a pointer to the ON_BrepFace is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepFace&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop(System.Int32)">
            <summary>Get loop from loop index or component index.</summary>
            <param name="loop_index">[in] either an index into m_L[] or a component index of type brep_loop.</param>
            <returns>
If the index is a valid loop index or a valid loop component index,
then a pointer to the ON_BrepLoop is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepLoop&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Trim(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Trim(System.Int32)">
            <summary>Get trim from trim index or component index.</summary>
            <param name="trim_index">[in] either an index into m_T[] or a component index of type brep_trim.</param>
            <returns>
If the index is a valid trim index or a valid trim component index,
then a pointer to the ON_BrepTrim is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepTrim&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Edge(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Edge(System.Int32)">
            <summary>Get trim from edge index or component index.</summary>
            <param name="edge_index">[in] either an index into m_E[] or a component index of type brep_edge.</param>
            <returns>
If the index is a valid edge index or a valid edge component index,
then a pointer to the ON_BrepEdge is returned.
Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepEdge&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Vertex(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Vertex(System.Int32)">
            <summary>Get vertex from trim index or component index</summary>
            <param name="vertex_index">[in] either an index into m_V[] or a component index of type brep_vertex.</param>
            <returns>
If the index is a valid vertex index or a valid vertex component index,
then a pointer to the ON_BrepVertex is returned. Otherwise NULL is returned.
See Also ON_Brep::Component( const ON_BrepVertex&amp; )
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.BrepComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a brep component from its index.</summary>
            <param name="component_index">[in]</param>
            <returns>
A const pointer to the component. Do not delete the returned object.
It points to an object managed by this brep.
</returns>
            <remarks>
See Also:
ON_Brep::Face
ON_Brep::Edge
ON_Brep::Loop
ON_Brep::Trim 
ON_Brep::Vertex
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.NextEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.NextEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="next_endi">
[out] 0 if next edge begins at the vertex, 1 if next edge ends at the vertex
</param>
            <returns>
edge index of the next edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.PrevEdge(System.Int32,System.Int32)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.PrevEdge(System.Int32,System.Int32,System.Int32@)">
            <summary>
This is a simple tool for getting running through the edges that begin and end at a vertex.
</summary>
            <param name="current_edge_index">[in]</param>
            <param name="endi">[in] 0 = use the edge start vertex, 1 = use the edge end vertex</param>
            <param name="prev_endi">
[out] 0 if previous edge begins at the vertex, 1 if previous edge ends at the vertex
</param>
            <returns>
edge index of the previous edge or -1 if there is only one edge that begins or ends at the vertex.
</returns>
            <remarks>
This is a tool that simplifies searching through the ON_BrepVertex.m_ei[] array.
The edges are in no particular order.
See Also: ON_Brep::NextEdge
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.NextTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of next trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.PrevTrim(System.Int32)">
            <summary>
for moving around loops - returns trim index of prev trim in loop
</summary>
            <param name="index">index of current trim (m_trim_index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.DuplicateFaces(System.Int32[],System.Boolean)">
            <summary>Duplicate a a subset of a brep</summary>
            <param name="face_index">[in] array of face indices</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>A brep made by duplicating the faces listed in the face_index[] array.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DuplicateFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.DuplicateFace(System.Int32,System.Boolean)">
            <summary>Duplicate a single brep face.</summary>
            <param name="face_index">[in] index of face to duplicate</param>
            <param name="bDuplicateMeshes">[in] if true, any attached meshes are duplicated</param>
            <returns>Single face brep.</returns>
            <remarks>
The m_vertex_user.i, m_edge_user.i, m_face_user.i, m_loop_user.i,
and m_trim_user.i values of the returned brep are are set to the 
indices of the objects they duplicate.
See Also:
ON_Brep::DeleteFace, ON_Brep::ExtractFace
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.RegionTopology">
            <summary>
Get region topology information:
In order to keep the ON_Brep class efficient, rarely used
region topology information is not maintained.  If you 
require this information, call RegionTopology().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SubBrep(System.Int32[],RMA.OpenNURBS.OnBrep)">
            <summary>Copy a subset of this brep.</summary>
            <param name="sub_fi">
[in] array of face indices in this brep to copy. (If any values in sub_fi[]
are out of range or if sub_fi[] contains duplicates, this function will return null.)
</param>
            <param name="sub_brep">
[in] if this pointer is not null, then the subbrep will be created in this class.
</param>
            <returns>
If the input is valid, a pointer to the subbrep is returned.
If the input is not valid, null is returned.  The faces in
in the subbrep's m_F array are in the same
order as they were specified in sub_fi[].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetConnectedComponents(RMA.OpenNURBS.OnBrep[]@,System.Boolean)">
            <summary>
If this brep has two or more connected components,
then duplicates of the connected components are appended to the components[] array.
</summary>
            <param name="components">[in] connected components are appended to this array.</param>
            <param name="bDuplicateMeshes">[in] if true, any meshes on this brep are copied to the output breps.</param>
            <returns>
Number of connected components appended to components[] or
zero if this brep has only one connected component.
See Also: ON_Brep::GetConnectedComponents
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetEdgeParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the 2d trim curve, get the corresponding parameter on the 3d edge curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="trim_t">[in] parameter on 2d trim curve</param>
            <param name="edge_t">[out] parameter on 3d edge</param>
            <returns>
TRUE successful
FALSE failure - edge_t not set
See Also: TL_Brep::GetTrimParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrimParameter(System.Int32,System.Double,System.Double@,System.Boolean)">
            <summary>
Given a trim and parameter on the corresponding 3d edge, get the corresponding parameter on the 2d trim curve.
</summary>
            <param name="trim_index">[in] index of trim in m_T array</param>
            <param name="edge_t">[in] parameter on 3d edge</param>
            <param name="trim_t">[out] parameter on 2d trim curve</param>
            <param name="bOkToBuildTrimPline">
[in] if TRUE and m_T[trim_index].m_pline[] does not have its edge parameters set,
then they are filled in. This is slow the first time, but greatly increases the
speed of GetTrimParameter and GetEdgeParameter on subsequent calls.
</param>
            <returns>
TRUE successful
FALSE failure - trim_t not set
See Also: TL_Brep::GetEdgeParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SortFaceLoops(RMA.OpenNURBS.OnBrepFace@)">
            <summary>
Sort the face.m_li[] array by loop type (outer, inner, slit, crvonsrf, ptonsrf)
</summary>
            <param name="face">[in/out] face whose m_li[] array should be sorted.</param>
            <returns>
true success
false failure - no loops or loops with unset loop.m_type
See Also: ON_Brep::ComputeLoopType ON_Brep::LoopDirection
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.LoopDirection(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
LoopDirection() examines the 2d trimming curve geometry that defines
the loop and returns
 +1    the loop is a counter-clockwise loop.
 -1    the loop is a clockwise loop.
  0    the loop is not a continuous closed loop.
Since LoopDirection() calculates its result based on the 2d trimming
curve geometry, it can be use to set ON_BrepLoop::m_type to outer/inner
when translating from data definition where this distinction is murky.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.LoopIsSurfaceBoundary(System.Int32)">
            <summary>
returns true if the loop's trims all run along the edge's of the underlying surface's
parameter space.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.FaceIsSurface(System.Int32)">
            <summary>
returns true if the face has a single outer boundary and that boundary runs
along the edges of the underlying surface. In this case the geometry of the surface
is the same as the geometry of the face. If FaceIsSurface() is true, then
m_S[m_F[face_index].m_si] is the surface. The flag m_F[face_index].m_bRev records
the correspondence between the surface's natural parametric orientation and the
orientation of face in the b-rep.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsSurface">
            <summary>
returns true if the b-rep has a single face
and that face is geometrically the same
as the underlying surface.  I.e., the face
has trivial trimming.  In this case, the
surface is m_S[0].
The flag m_F[0].m_bRev records
the correspondence between the surface's
natural parametric orientation and the
orientation of the b-rep.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsPointInside(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Boolean)">
            <summary>
Determine if P is inside Brep.  This question only makes sense
when the brep is a closed manifold.  This function does not
not check for closed or manifold, so result is not valid in
those cases.  Intersects a line through P with brep, finds
the intersection point Q closest to P, and looks at face 
normal at Q.  If the point Q is on an edge or the intersection
is not transverse at Q, then another line is used.
</summary>
            <param name="P">[in] 3d point</param>
            <param name="tolerance">
[in] 3d distance tolerance used for intersection and determining strict inclusion.
</param>
            <param name="bStrictlyInside">
[in] If bStrictlInside is true, then this function will return false
if the distance from P is within tolerance of a brep face.
</param>
            <returns>True if P is in, false if not. See parameter bStrictlyIn.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsManifold">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsManifold(System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsManifold(System.Boolean@,System.Boolean@)">
            <summary>Test brep to see if it is an oriented manifold.</summary>
            <param name="pbIsOriented">
[in] if not null, *pbIsOriented is set to true if b-rep is an oriented
manifold and false if brep is not an oriented manifold.
</param>
            <param name="pbHasBoundary">
[in] if not null, *pbHasBoundary is set to true if b-rep has a boundary edge
and false if brep does not have a boundary edge.
</param>
            <returns>
true brep is a manifold
false brep is not a manifold
</returns>
            <seealso>ON_Brep::IsSolid</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsSolid">
            <summary>
Test brep to see if it is a solid. (A "solid" is a closed oriented manifold.)
</summary>
            <returns>
true brep is a solid fals brep is not a solid
See Also: ON_Brep::SolidOrientation ON_Brep::IsManifold
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SolidOrientation">
            <summary>Determine orientation of a brep.</summary>
            <returns>
+2 brep is a solid but orientation cannot be computed
+1 brep is a solid with outward facing normals
-1 brep is a solid with inward facing normals
0 brep is not a solid
</returns>
            <remarks>
The base class implementation returns 2 or 0. This function is 
overridden in the Rhino SDK and returns +1, -1, or 0.
See Also: ON_Brep::IsSolid
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop2dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 2d curve should be duplicated</param>
            <returns>A pointer to a 2d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,RMA.OpenNURBS.OnCurve[]@,System.Boolean)">
            <summary>Get a list of 3d curves that trace the non-seam edge portions of an entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="curve_list">[out] 3d curves are appended to this list</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curves have an orientation compatible with
the 2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curves are reversed.
</param>
            <returns>Number of curves appended to curve_list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.Loop3dCurve(RMA.OpenNURBS.IOnBrepLoop,System.Boolean)">
            <summary>Get a single 3d curve that traces the entire loop</summary>
            <param name="loop">[in] loop whose 3d curve should be duplicated</param>
            <param name="bRevCurveIfFaceRevIsTrue">
[in] If false, the returned 3d curve has an orientation compatible with the
2d curve returned by Loop2dCurve().
If true and the m_bRev flag of the loop's face is true,
then the returned curve is reversed.
</param>
            <returns>A pointer to a 3d ON_Curve. The caller must delete this curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimCurveUseCount(System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep trims reference m_C2[c2_index].</summary>
            <param name="c2_index">[in] index of the 2d curve in m_C2[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count trims use the 2d curve.
</param>
            <returns>Number of brep trims that reference the 2d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.EdgeCurveUseCount(System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.EdgeCurveUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep edges reference m_C3[c3_index].</summary>
            <param name="c3_index">[in] index of the 3d curve in m_C3[] array</param>
            <param name="max_count">
[in] counting stops if max_count &gt; 0 and at least max_count edges use the 3d curve.
</param>
            <returns>Number of brep edges that reference the 3d curve.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SurfaceUseCount(System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SurfaceUseCount(System.Int32,System.Int32)">
            <summary>Determine how many brep faces reference m_S[surface_index].</summary>
            <param name="surface_index">[in] index of the surface in m_S[] array</param>
            <param name="max_count">[in] counting stops if max_count &gt; 0 and at least max_count faces use the surface.</param>
            <returns>Number of brep faces that reference the surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetEdgeTolerance(RMA.OpenNURBS.OnBrepEdge@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetTrimTolerance(RMA.OpenNURBS.OnBrepTrim@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.SetVertexTolerance(RMA.OpenNURBS.OnBrepVertex@,System.Boolean)">
            <summary>
These set the various tolerances.  The optional BOOL argument
is called bLazy.  If bLazy is false, the tolerance is recomputed
from its definition.  If bLazy is true, the tolerance is computed
only if its current value is negative.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.ComputeLoopType(RMA.OpenNURBS.IOnBrepLoop)">
            <summary>
This function examines the 2d parameter space curves and returns
the loop's type based on their orientation.  Use this function for
debugging loop orientation problems.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim3dEnd(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dEnd() evaluates the 3d surface at the end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim3dStart(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
GetTrim3dStart() evaluates the 3d surface at the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim2dEnd(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dEnd() evaluates end of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetTrim2dStart(System.Int32,RMA.OpenNURBS.On2dPoint@)">
            <summary>
GetTrim2dStart() evaluates the start of the
parameter space (2d) trim curve.
</summary>
            <param name="trim_index">index of ON_BrepTrim in m_T[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.TrimType(RMA.OpenNURBS.IOnBrepTrim,System.Boolean)">
            <summary>
Calculate the type (singular, mated, boundary, etc.) of an ON_BrepTrim object.
</summary>
            <param name="trim">[in]</param>
            <param name="bLazy">
[in] if true and trim.m_type is set to something other than ON_BrepTrim::unknown,
then no calculation is performed and the value of trim.m_type is returned.
If false, the value of trim.m_type is ignored and is caluculated.
</param>
            <returns>Type of trim.</returns>
            <remarks>
The trim must be connected to a valid loop. See Also: ON_Brep::SetTrimTypeFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidForV2">
            <summary>
Tests brep to see if it is valid for 
saving in V2 3DM archives.
</summary>
            <returns>true if brep is valid for V2 3DM archives.</returns>
            <remarks>V2 breps could not have dangling curves.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTolerancesAndFlags">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTolerancesAndFlags(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its tolerances and flags are valid.
The values of brep.IsValidTopology() and brep.IsValidGeometry() must be true before
brep.IsValidTolerancesAndFlags() can be safely called.
</summary>
            <param name="text_log">
[in] if the brep tolerance or flags are not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep tolerance and flags are valid
false brep tolerance and flags are not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology and ON_Brep::IsValidGeometry must be true before
you can safely call ON_Brep::IsValidTolerancesAndFlags.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidGeometry
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidGeometry">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidGeometry(RMA.OpenNURBS.OnTextLog)">
            <summary>
Expert user function that tests the brep to see if its geometry information is valid.
The value of brep.IsValidTopology() must be true before brep.IsValidGeometry() can
be safely called.
</summary>
            <param name="text_log">
[in] if the brep geometry is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level debugging
purposes by programmers and is not intended to be useful as a high level
user interface tool.
</param>
            <returns>
true brep geometry is valid
false brep geometry is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology must be true before you can safely
call ON_Brep::IsValidGeometry.
See Also: ON_Brep::IsValid ON_Brep::IsValidTopology ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTopology">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsValidTopology(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests the brep to see if its topology information is valid.</summary>
            <param name="text_log">
[in] if the brep topology is not valid and text_log is not NULL,
then a brief english description of the problem is appended to the log.
The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful
as a high level user interface tool.
</param>
            <returns>
true brep topology is valid
false brep topology is not valid
</returns>
            <remarks>
ON_Brep::IsValidTopology can be called at any time.
See Also:
ON_Brep::IsValid
ON_Brep::IsValidGeometry
ON_Brep::IsValidTolerancesAndFlags
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, volume, and volume centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.
This parameter is for expert users who are computing a volume whose
boundary is defined by several non-closed breps, surfaces, and meshes.
When computing the volume, volume centroid, or volume first moments
of a volume whose boundary is defined by several breps, surfaces, and
meshes, pass the same base_point to each call to VolumeMassProperties.
When computing the volume second moments or volume product moments of
a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the
input mp parameter must contain the results of a previous call to
VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first
set to calculate the volume centroid and the second set calculate the second
moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">
[in] true to calculate area first moments, area and area centroid.
</param>
            <param name="bSecondMoments">
[in] true to calculate area second moments.
</param>
            <param name="bProductMoments">
[in] true to calculate area product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.GetMesh(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.IOnMesh[]@)">
            <summary>Get cached meshes used to render and analyze brep.</summary>
            <param name="mesh_type">[in] type of mesh to get</param>
            <param name="meshes">
[out] meshes are appended to this array.
The ON_Brep owns these meshes so the cannot be modified.
</param>
            <returns>
Number of meshes added to array. (Same as m_F.Count())
See Also:
ON_Brep::DestroyMesh
ON_BrepFace::DestroyMesh
ON_BrepFace::Mesh
ON_BrepFace::SetMesh
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh[]@)">
            <summary>
Calculates polygon mesh approximation of the brep and appends
one mesh for each face to the mesh_list[] array
</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh_list">[out] meshes are appended to this array.</param>
            <returns>Number of meshes appended to mesh_list[] array.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrep.IsDuplicate(RMA.OpenNURBS.IOnBrep,System.Double)">
            <summary>See if this and other are same brep geometry.</summary>
            <param name="other">[in] other brep</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if breps are the same</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_F">
            <summary>
faces
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_L">
            <summary>
loops
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_T">
            <summary>
trims
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_E">
            <summary>
edges
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_V">
            <summary>
vertices
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_S">
            <summary>
Pointers to parametric surfaces (used by faces)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_C3">
            <summary>
Pointers to 3d curves (used by edges).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrep.m_C2">
            <summary>
Pointers to parameter space trimming curves (used by trims)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.On3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the region.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.

This parameter is for expert users who are computing a volume whose boundary is
defined by several non-closed breps, surfaces, and meshes.

When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same 
base_point to each call to VolumeMassProperties.  

When computing the volume second moments or volume product moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, you MUST pass
the entire volume's centroid as the base_point and the input mp parameter must
contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set
to calculate the volume centroid and the second set calculate the second moments
and product moments.
</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.RegionBoundaryBrep(RMA.OpenNURBS.OnBrep)">
            <summary>
Get the boundary of a region as a brep object.  
If the region is finite, the boundary will be a closed manifold brep.
The boundary may have more than one connected component.
</summary>
            <param name="brep">[in] if not NULL, the brep form is put into this brep.</param>
            <returns>the region boundary as a brep or NULL if the calculation fails</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepRegion.m_type">
            <summary>0 = infinte, 1 = bounded</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepRegion.m_fsi">
            <summary>indices of face sides</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.BoundingBox">
            <returns>Region bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.IsFinite">
            <returns>True if the region is finite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.FaceSide(System.Int32)">
            <param name="fsi">[in] index into the region's m_fsi[] array.</param>
            <returns>
The face side in rtop.m_FS[m_fsi[rsi]], where rtop is the ON_BrepRegionTopology
class this region belongs to.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.RegionTopology">
            <returns>Region topology this region belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepRegion.Brep">
            <returns>Brep this region belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepRegion.m_region_index">
            <summary>index of region in ON_BrepRegionTopology.m_R[] array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.On3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the region.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the brep is closed, then pass ON_UNSET_VALUE.

This parameter is for expert users who are computing a volume whose boundary is
defined by several non-closed breps, surfaces, and meshes.

When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same 
base_point to each call to VolumeMassProperties.  

When computing the volume second moments or volume product moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, you MUST pass
the entire volume's centroid as the base_point and the input mp parameter must
contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set
to calculate the volume centroid and the second set calculate the second moments
and product moments.
</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the brep.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <param name="rel_tol">default = 1.0e-6</param>
            <param name="abs_tol">default = 1.0e-6</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.RegionBoundaryBrep(RMA.OpenNURBS.OnBrep)">
            <summary>
Get the boundary of a region as a brep object.  
If the region is finite, the boundary will be a closed manifold brep.
The boundary may have more than one connected component.
</summary>
            <param name="brep">[in] if not NULL, the brep form is put into this brep.</param>
            <returns>the region boundary as a brep or NULL if the calculation fails</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepRegion.m_type">
            <summary>0 = infinte, 1 = bounded</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepRegion.m_fsi">
            <summary>indices of face sides</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.BoundingBox">
            <returns>Region bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.IsFinite">
            <returns>True if the region is finite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.FaceSide(System.Int32)">
            <param name="rfsi">[in] index into the region's m_fsi[] array.</param>
            <returns>
The face side in rtop.m_FS[m_fsi[rsi]], where rtop is the ON_BrepRegionTopology
class this region belongs to.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.RegionTopology">
            <returns>Region topology this region belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepRegion.Brep">
            <returns>Brep this region belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepRegion.m_region_index">
            <summary>index of region in ON_BrepRegionTopology.m_R[] array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_srf_dir">
            <summary>
 1 ON_BrepFace's surface normal points into region
-1 ON_BrepFace's surface normal points out of region
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_fi">
            <summary>face index</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_ri">
            <summary>
region index
m_ri = -1 indicates this faceside overlaps another faceside.
Generally this is a flaw in an ON_Brep
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.SurfaceNormalDirection">
            <returns>
+1: underlying geometric surface normal points into region.
-1: underlying geometric surface normal points out of region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.Face">
            <returns>Faces this side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.Region">
            <returns>Region the face side belongs to</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.RegionTopology">
            <returns>Region topology this face side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFaceSide.Brep">
            <returns>Brep this face side belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFaceSide.m_faceside_index">
            <summary>index of face side in ON_BrepRegionTopology.m_FS[] array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_srf_dir">
            <summary>
 1 ON_BrepFace's surface normal points into region
-1 ON_BrepFace's surface normal points out of region
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_fi">
            <summary>face index</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_ri">
            <summary>
region index
m_ri = -1 indicates this faceside overlaps another faceside.
Generally this is a flaw in an ON_Brep
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.SurfaceNormalDirection">
            <returns>
+1: underlying geometric surface normal points into region.
-1: underlying geometric surface normal points out of region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.Face">
            <returns>Faces this side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.Region">
            <returns>Region the face side belongs to</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.RegionTopology">
            <returns>Region topology this face side belongs to.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFaceSide.Brep">
            <returns>Brep this face side belongs to.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFaceSide.m_faceside_index">
            <summary>index of face side in ON_BrepRegionTopology.m_FS[] array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the face.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this face or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.ChangeSurface(System.Int32)">
            <summary>
Expert user tool that replaces the 3d surface geometry use by the face.
</summary>
            <param name="si">[in] brep surface index of new surface</param>
            <returns>True if successful.</returns>
            <example>
ON_Surface* pSurface = ...;
int si = brep.AddSurface(pSurface);
face.ChangeSurface(si);
</example>
            <remarks>
If the face had a surface and new surface has a different shape,
then you probably want to call something like ON_Brep::RebuildEdges()
to move the 3d edge curves so they will lie on the new surface.
This doesn't delete the old surface; call ON_Brep::CullUnusedSurfaces()
or ON_Brep::Compact to remove unused surfaces.
See Also: ON_Brep::RebuildEdges ON_Brep::CullUnusedSurfaces
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.TransformTrim(RMA.OpenNURBS.IOnXform)">
            <summary>
Expert user tool that tranforms all the parameter space (2d) trimming curves on this face.
Only 2d curve geometry is changed. The caller is responsible for reversing loops,
toggle m_bRev, flags, etc.
</summary>
            <param name="xform">[in] Transformation applied to 2d curve geometry.</param>
            <returns>True if successful. If false is returned, the brep may be invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type)">
            <summary>
Destroy meshes used to render and analyze surface and polysrf objects.
</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <remarks>
See Also:
CRhinoObject::GetMeshes
CRhinoObject::MeshCount
CRhinoObject::IsMeshable
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.DestroyMesh(RMA.OpenNURBS.IOn.mesh_type,System.Boolean)">
            <summary>
Destroy meshes used to render and analyze surface and polysrf objects.
</summary>
            <param name="mesh_type">[in] type of mesh to destroy</param>
            <param name="bDeleteMesh">
[in] if true, cached mesh is deleted.
If false, pointer to cached mesh is just set to NULL.
</param>
            <remarks>
See Also:
CRhinoObject::GetMeshes
CRhinoObject::MeshCount
CRhinoObject::IsMeshable
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SetMesh(RMA.OpenNURBS.IOn.mesh_type,RMA.OpenNURBS.OnMesh)">
            <summary>If true is returne, then ~ON_BrepFace will delete mesh.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SetDomain(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Change the domain of a face
This changes the parameterization of the face's surface and transforms
the u and v coordinates of all the face's parameter space trimming
curves.  The locus of the face is not changed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.SetDomain(System.Int32,System.Double,System.Double)">
            <summary>
This is an override of the virtual ON_Surface::SetDomain function.
</summary>
            <param name="dir">[in] 0 = set "u" domain, 1 = set "v" domain.</param>
            <param name="t0">[in]</param>
            <param name="t1">[in] t0 &lt; t1 The new domain is the interval (t0,t1)</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.ClearBoundingBox">
            <summary>
virtual ON_Geometry::ClearBoundingBox() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.FaceSide(System.Int32)">
            <param name="dir">
1: side with underlying surface normal pointing into the topology region
-1: side with underlying surface normal pointing out of the topology region
</param>
            <returns>
Brep region topology face side. If the region topology has not be created by calling
ON_Brep::RegionToplogy(), then NULL is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.OuterLoop">
            <returns>Outer boundary loop for this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.LoopCount">
            <returns>Number of loops in this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.Loop(System.Int32)">
            <param name="fli">[in] index into the face's m_li[] array.</param>
            <returns>The loop brep.m_L[face.m_li[fli]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepFace.Brep">
            <summary>
Returns: Brep that the face belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_face_uuid">
            <summary>
Persistent id for this face.  Default is ON_nil_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_face_material_channel">
            <summary>
m_face_material_channel provides a way to have individual
brep faces use a rendering material that is different
from the rendering material used by the parent brep.
If m_face_material_channel is zero 
channel and m_face_material_channel.m_j is the back face
materal. The default is (0,0) which indicates the face
should use the parent brep's material.
If "mat" is the brep's rendering material and
0 &lt; m_material_channel.m_i &lt; mat.m_material_channel.Count(),
then this face should use the material with id
mat.m_material_channel[face.m_material_channel.m_i-1].m_id.
If m_material_channel.m_i or the id is invalid in any way,
then the default should be used.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_bRev">
            <summary>
true if face orientation is opposite of natural surface orientation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_si">
            <summary>
index of surface in b-rep m_S[] array
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_li">
            <summary>
loop indices (outer loop is m_li[0])
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepFace.m_face_index">
            <summary>
index of face in ON_Brep.m_F[] array
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the face.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this face or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.FaceSide(System.Int32)">
            <param name="dir">
1: side with underlying surface normal pointing into the topology region
-1: side with underlying surface normal pointing out of the topology region
</param>
            <returns>
Brep region topology face side. If the region topology has not be created by calling
ON_Brep::RegionToplogy(), then NULL is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.OuterLoop">
            <returns>Outer boundary loop for this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.LoopCount">
            <returns>Number of loops in this face.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.Loop(System.Int32)">
            <param name="fli">[in] index into the face's m_li[] array.</param>
            <returns>The loop brep.m_L[face.m_li[fli]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepFace.Brep">
            <summary>Brep that the face belongs to.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_face_uuid">
            <summary>
Persistent id for this face.  Default is ON_nil_uuid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_face_material_channel">
            <summary>
m_face_material_channel provides a way to have individual
brep faces use a rendering material that is different
from the rendering material used by the parent brep.
If m_face_material_channel is zero 
channel and m_face_material_channel.m_j is the back face
materal. The default is (0,0) which indicates the face
should use the parent brep's material.
If "mat" is the brep's rendering material and
0 &lt; m_material_channel.m_i &lt; mat.m_material_channel.Count(),
then this face should use the material with id
mat.m_material_channel[face.m_material_channel.m_i-1].m_id.
If m_material_channel.m_i or the id is invalid in any way,
then the default should be used.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_bRev">
            <summary>
true if face orientation is opposite of natural surface orientation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_si">
            <summary>
index of surface in b-rep m_S[] array
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_li">
            <summary>
loop indices (outer loop is m_li[0])
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepFace.m_face_index">
            <summary>
index of face in ON_Brep.m_F[] array
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.TransformTrim(RMA.OpenNURBS.IOnXform)">
            <summary>
Expert user tool that tranforms all the parameter space (2d) trimming curves in this loop.
Only 2d curve geometry is changed. The caller is responsible for reversing loops, toggle m_bRev, flags, etc.
</summary>
            <param name="xform">[in] Transformation applied to 2d curve geometry.</param>
            <returns>True if successful. If false is returned, the brep may be invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this loop or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.IndexOfTrim(RMA.OpenNURBS.IOnBrepTrim)">
            <returns>
Returns the index i such that loop.m_ti[i] = trim.m_trim_index.
Returns -1 if the trim is not in this loop
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.#ctor(System.Int32)">
            <summary>
loop index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.TrimCount">
            <summary>
Returns: Number of trims in this loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.Trim(System.Int32)">
            <param name="lti">[in] index into the loop's m_ti[] array.</param>
            <returns>The trim brep.m_T[loop.m_ti[lti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.Face">
            <summary>
Brep face this loop belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepLoop.Brep">
            <summary>
Brep that the loop belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_pbox">
            <summary>
parameter space trimming loop bounding box
runtime information - not saved
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_fi">
            <summary>
index of face that uses this loop
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_ti">
            <summary>
trim indices
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepLoop.m_loop_index">
            <summary>
index of loop in ON_Brep.m_L[] array
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.SurfaceOf">
            <summary>
Returns: Pointer to the surface geometry used by the loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this loop or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.IndexOfTrim(RMA.OpenNURBS.IOnBrepTrim)">
            <returns>
Returns the index i such that loop.m_ti[i] = trim.m_trim_index.
Returns -1 if the trim is not in this loop
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.TrimCount">
            <summary>
Returns: Number of trims in this loop.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.Trim(System.Int32)">
            <param name="lti">[in] index into the loop's m_ti[] array.</param>
            <returns>The trim brep.m_T[loop.m_ti[lti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.Face">
            <summary>
Brep face this loop belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepLoop.Brep">
            <summary>
Brep that the loop belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_pbox">
            <summary>
parameter space trimming loop bounding box
runtime information - not saved
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_fi">
            <summary>
index of face that uses this loop
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_ti">
            <summary>
trim indices
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepLoop.m_loop_index">
            <summary>
index of loop in ON_Brep.m_L[] array
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.TransformTrim(RMA.OpenNURBS.IOnXform)">
            <summary>
Expert user tool that tranforms all the parameter space (2d) trimming curves in this loop.
Only 2d curve geometry is changed. The caller is responsible for reversing loops, toggle
m_bRev, flags, etc.
</summary>
            <param name="xform">[in] Transformation applied to 2d curve geometry.</param>
            <returns>True if successful. If false is returned, the brep may be invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.IsSeam">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) the 2d trim curve for this trim lies along the side of 
  the face's parameter space and the 2d curve for the other
  trim lies on the opposite side of the face's parameter space.
</summary>
            <remarks>
In order for IsSeam() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.IsSlit">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) The 2d trim curve for the other trim is the reverse of the 2d trim curve for this trim.
</summary>
            <remarks>
In order for IsSlit() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.FaceIndexOf">
            <summary>
Returns: brep.m_F[] face index of the face used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] 3d curve index of the 3d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.TrimCurveIndexOf">
            <summary>
Returns: brep.m_C2[] 2d curve index of the 2d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SurfaceOf">
            <summary>
Returns: 3d surface geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this trim or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.TrimCurveOf">
            <summary>
Returns: 2d curve geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.AttachToEdge(System.Int32,System.Boolean)">
            <summary>Expert user function. Attaches a trim to an edge.</summary>
            <param name="edge_index">[in] index of an edge.</param>
            <param name="bRev3d">[in] value for trim's m_bRev3d field.</param>
            <remarks>
If the trim is attached to an edge (m_ei&gt;=0), then the trim is
removed from the edge and the edge's m_ti[] list.
The trim's tolerance values are not changed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.RemoveFromEdge(System.Boolean,System.Boolean)">
            <summary>
Expert user function. Removes a trim from an edge.
</summary>
            <param name="bRemoveFromStartVertex">
[in] if true, the trim is removed from its start vertex by setting m_vi[0] to -1.
</param>
            <param name="bRemoveFromEndVertex">
[in] if true, the trim is removed from its start vertex by setting m_vi[1] to -1.
</param>
            <remarks>
If the trim is attached to an edge (m_ei&gt;=0),
then the trim is removed from the edge and the edge's m_ti[] list.
The trim's m_bRev3d and tolerance values are not changed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.ChangeTrimCurve(System.Int32)">
            <summary>
Expert user tool that replaces the 2d curve geometry of a trim
</summary>
            <param name="c2i">[in] brep 2d curve index of new curve</param>
            <returns>True if successful.</returns>
            <example>
ON_Curve* pCurve = ...;
int c2i = brep.AddTrimCurve(pCurve);
trim.ChangeTrimCurve(c2i);
</example>
            <remarks>Sets m_c2i, calls SetProxyCurve, cleans runtime caches, and updates m_pbox.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SetEndPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to end at a specified point.</summary>
            <param name="end_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also:
ON_Curve::SetStartPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.SetStartPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to start at a specified point.</summary>
            <param name="start_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also:
ON_Curve::SetEndPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Vertex(System.Int32)">
            <param name="tvi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the trim.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Edge">
            <summary>
Brep edge this trim uses for belongs to. This will be NULL for singular trims.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Face">
            <summary>
Brep face this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Loop">
            <summary>
Brep loop that this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.Brep">
            <summary>
Brep that this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.#ctor(System.Int32)">
            <summary>
In general, you should not directly create ON_BrepTrim classes.
Use ON_Brep::NewTrim instead.
</summary>
            <param name="trim_index">trim index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepTrim.#ctor">
            <summary>
In general, you should not directly create ON_BrepTrim classes.
Use ON_Brep::NewTrim instead.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_pbox">
            <summary>
Runtime parameter space trimming curve bounding box.
This information is not saved in 3DM archives.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_pline">
            <summary>
Runtime polyline approximation of trimming curve.
This information is not saved in 3DM archives.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_tolerance(System.Int32)">
            <summary>
The values in m_tolerance[] record the accuracy of
the parameter space trimming curves.
</summary>
            <remarks>
m_tolerance[0] = accuracy of parameter space curve in first ( "u" ) parameter

m_tolerance[1] = accuracy of parameter space curve in second ( "v" ) parameter

A value of ON_UNSET_VALUE indicates that the tolerance should be computed.
If the value &gt;= 0.0, then the tolerance is set. If the value is 
ON_UNSET_VALUE, then the tolerance needs to be computed.

If the trim is not singular, then the trim must have an edge. If P is a
3d point on the edge curve and surface(u,v) = Q is the point on the 
surface that is closest to P, then there must be a parameter t in
the interval [m_t[0], m_t[1]] such that

|u - curve2d(t)[0]| &lt;= m_tolerance[0]
and 
|v - curve2d(t)[1]| &lt;= m_tolerance[1]

If P is the 3d point for the vertex brep.m_V[m_vi[k]] and (uk,vk) is the
corresponding end of the trim's parameter space curve, then there must be a surface
parameter (u,v) such that:
  *  the distance from the 3d point surface(u,v) to P
     is &lt;= brep.m_V[m_vi[k]].m_tolerance,
  *  |u-uk| &lt;= m_tolerance[0].
  *  |v-vk| &lt;= m_tolerance[1].
</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_li">
            <summary>
index of loop that uses this trim
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_bRev3d">
            <summary>
true if the 2d trim and 3d edge have opposite orientations.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_vi(System.Int32)">
            <summary>
Indices of start/end vertices.  Trims along singular
sides and trims that correspond to closed 3d edges
have m_vi[0] = m_vi[1].  Note that singular trims
and trims on the closed edge of a closed surface can
have an open 2d trimming curve and still have 
m_vi[0] = m_vi[1].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_ei">
            <summary>
index of 3d edge (-1 if ON_BrepTrim is singular)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_c2i">
            <summary>
index of the 2d parameter space trimming curve
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrim.m_trim_index">
            <summary>
index of trim in ON_Brep.m_T[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnBrepTrim">
            <summary>
Brep trim information is stored in ON_BrepTrim classes.
ON_Brep.m_T[] is an array of all the trim in the brep.

An ON_BrepTrim is derived from ON_CurveProxy so the the
trim can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C2[trim.m_c2i] and the trin as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.IsSeam">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) the 2d trim curve for this trim lies along the side of 
  the face's parameter space and the 2d curve for the other
  trim lies on the opposite side of the face's parameter space.
</summary>
            <remarks>
In order for IsSeam() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.IsSlit">
            <summary>
Returns: True if the trim satisfies these four criteria.
1) is part of a loop
2) is connected to a 3d edge
3) one other trim from the same loop is connected to the edge
4) The 2d trim curve for the other trim is the reverse of the 2d trim curve for this trim.
</summary>
            <remarks>
In order for IsSlit() to work correctly, the m_type and m_iso
fields must be set correctly.  In V4 SR1, this function will
be removed and ON_BrepTrim::slit will be added as a type.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.FaceIndexOf">
            <summary>
Returns: brep.m_F[] face index of the face used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.SurfaceIndexOf">
            <summary>
Returns: brep.m_S[] surface index of the 3d surface geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] 3d curve index of the 3d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.TrimCurveIndexOf">
            <summary>
Returns: brep.m_C2[] 2d curve index of the 2d curve geometry used by this trim or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.SurfaceOf">
            <summary>
Returns: 3d surface geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this trim or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.TrimCurveOf">
            <summary>
Returns: 2d curve geometry used by this trim or NULL
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Vertex(System.Int32)">
            <param name="tvi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the trim.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Edge">
            <summary>
Brep edge this trim uses or belongs to. This will be NULL for singular trims.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Face">
            <summary>
Brep face this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Loop">
            <summary>
Brep loop that this trim belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepTrim.Brep">
            <summary>
Brep that this trim belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_pbox">
            <summary>
Runtime parameter space trimming curve bounding box.
This information is not saved in 3DM archives.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_pline">
            <summary>
Runtime polyline approximation of trimming curve.
This information is not saved in 3DM archives.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_tolerance(System.Int32)">
            <summary>
The values in m_tolerance[] record the accuracy of
the parameter space trimming curves.
</summary>
            <remarks>
m_tolerance[0] = accuracy of parameter space curve in first ( "u" ) parameter

m_tolerance[1] = accuracy of parameter space curve in second ( "v" ) parameter

A value of ON_UNSET_VALUE indicates that the tolerance should be computed.
If the value &gt;= 0.0, then the tolerance is set. If the value is 
ON_UNSET_VALUE, then the tolerance needs to be computed.

If the trim is not singular, then the trim must have an edge. If P is a
3d point on the edge curve and surface(u,v) = Q is the point on the 
surface that is closest to P, then there must be a parameter t in
the interval [m_t[0], m_t[1]] such that

|u - curve2d(t)[0]| &lt;= m_tolerance[0]
and 
|v - curve2d(t)[1]| &lt;= m_tolerance[1]

If P is the 3d point for the vertex brep.m_V[m_vi[k]] and (uk,vk) is the
corresponding end of the trim's parameter space curve, then there must be a surface
parameter (u,v) such that:
  *  the distance from the 3d point surface(u,v) to P
     is &lt;= brep.m_V[m_vi[k]].m_tolerance,
  *  |u-uk| &lt;= m_tolerance[0].
  *  |v-vk| &lt;= m_tolerance[1].
</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_li">
            <summary>
index of loop that uses this trim
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_bRev3d">
            <summary>
true if the 2d trim and 3d edge have opposite orientations.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_vi(System.Int32)">
            <summary>
Indices of start/end vertices.  Trims along singular
sides and trims that correspond to closed 3d edges
have m_vi[0] = m_vi[1].  Note that singular trims
and trims on the closed edge of a closed surface can
have an open 2d trimming curve and still have 
m_vi[0] = m_vi[1].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_ei">
            <summary>
index of 3d edge (-1 if ON_BrepTrim is singular)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_c2i">
            <summary>
index of the 2d parameter space trimming curve
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrim.m_trim_index">
            <summary>
index of trim in ON_Brep.m_T[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBrepTrim">
            <summary>
Brep trim information is stored in ON_BrepTrim classes.
ON_Brep.m_T[] is an array of all the trim in the brep.

An ON_BrepTrim is derived from ON_CurveProxy so the the
trim can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C2[trim.m_c2i] and the trin as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.ChangeEdgeCurve(System.Int32)">
            <summary>Expert user tool that replaces the 3d curve geometry of an edge</summary>
            <param name="c3i">[in] brep 3d curve index of new curve</param>
            <returns>True if successful.</returns>
            <example>
ON_Curve* pCurve = ...;
int c3i = brep.AddEdgeCurve(pCurve);
edge.ChangeEdgeCurve(c3i);
</example>
            <remarks>Sets m_c3i, calls SetProxyCurve, cleans runtime caches.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this edge or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] index of the 3d curve geometry used by this edge or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.IsSmoothManifoldEdge">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.IsSmoothManifoldEdge(System.Double)">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <param name="angle_tolerance">[in] used to decide if surface normals on either side are parallel.</param>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.SetEndPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to end at a specified point.</summary>
            <param name="end_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetStartPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.SetStartPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to start at a specified point.</summary>
            <param name="start_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetEndPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.Vertex(System.Int32)">
            <param name="evi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the edge.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.TrimCount">
            <summary>
Number of trims attached to this edge.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.Trim(System.Int32)">
            <param name="eti">[in] index into the edge's m_ti[] array.</param>
            <returns>The trim brep.m_T[edge.m_ti[eti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.Brep">
            <summary>
Brep this edge belongs to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.#ctor(System.Int32)">
            <summary>
In general, you should not directly create ON_BrepEdge classes.
Use ON_Brep::NewVertex instead.
</summary>
            <param name="edge_index">edge index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepEdge.#ctor">
            <summary>
In general, you should not directly create ON_BrepEdge classes.
Use ON_Brep::NewVertex instead.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_tolerance">
            <summary>
accuracy of edge curve (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
The maximum distance from the edge's 3d curve
to any surface of a face that has this edge as
a portion of its boundary must be &lt;= this
tolerance.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_ti">
            <summary>
indices of starting/ending vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_vi(System.Int32)">
            <summary>
indices of starting/ending vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepEdge.m_edge_index">
            <summary>
index of edge in ON_Brep.m_E[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnBrepEdge">
            <summary>
Brep edge information is stored in ON_BrepEdge classes.
ON_Brep.m_E[] is an array of all the edges in the brep.

An ON_BrepEdge is derived from ON_CurveProxy so the the
edge can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C3[edge.m_c3i] and the edge as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.EdgeCurveOf">
            <summary>
Returns: 3d curve geometry used by this edge or NULL.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.EdgeCurveIndexOf">
            <summary>
Returns: brep.m_C3[] index of the 3d curve geometry used by this edge or -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.IsSmoothManifoldEdge">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.IsSmoothManifoldEdge(System.Double)">
            <summary>
For a manifold, non-boundary edge, decides whether or not the two surfaces on either side meet smoothly.
</summary>
            <param name="angle_tolerance">[in] used to decide if surface normals on either side are parallel.</param>
            <returns>
true if edge is manifold, has exactly 2 trims, and surface normals on
either side agree to within angle_tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.Vertex(System.Int32)">
            <param name="evi">[in] 0 or 1</param>
            <returns>Brep vertex at specified end of the edge.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.TrimCount">
            <summary>
Number of trims attached to this edge.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.Trim(System.Int32)">
            <param name="eti">[in] index into the edge's m_ti[] array.</param>
            <returns>The trim brep.m_T[edge.m_ti[eti]];</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepEdge.Brep">
            <summary>
Brep this edge belongs to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_tolerance">
            <summary>
accuracy of edge curve (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
The maximum distance from the edge's 3d curve
to any surface of a face that has this edge as
a portion of its boundary must be &lt;= this
tolerance.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_ti">
            <summary>
indices of starting/ending vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_vi(System.Int32)">
            <summary>
indices of starting/ending vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepEdge.m_edge_index">
            <summary>
index of edge in ON_Brep.m_E[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBrepEdge">
            <summary>
Brep edge information is stored in ON_BrepEdge classes.
ON_Brep.m_E[] is an array of all the edges in the brep.

An ON_BrepEdge is derived from ON_CurveProxy so the the
edge can supply easy to use evaluation tools via 
the ON_Curve virtual member functions.

Note well that the domains and orientations of the curve
m_C3[edge.m_c3i] and the edge as a curve may not
agree.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.#ctor(System.Int32)">
            <summary>
In general, you should not directly create ON_BrepVertex classes.
Use ON_Brep::NewVertex instead.
</summary>
            <param name="vertex_index">vertex index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.EdgeCount">
            <summary>
number of edges that begin or end at this vertex.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.Tolerance">
            <returns>value of ON_BrepVertex::m_tolerance</returns>
            <remarks>Use ON_Brep::SetVertexTolerance( ON_BrepVertex&amp; ) to set tolerances.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.Point">
            <summary>
Vertex location.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.SetPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set vertex location.</summary>
            <param name="point">[in] 3d vertex location</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBrepVertex.#ctor">
            <summary>
In general, you should not directly create ON_BrepVertex classes.
Use ON_Brep::NewVertex instead.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepVertex.m_tolerance">
            <summary>
accuracy of vertex point (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
A value of 0.0 indicates that the distance
from the vertex to any applicable edge or trim
end is &lt;=  ON_ZERO_TOLERANCE
If an edge begins or ends at this vertex,
then the distance from the vertex's 
3d point to the appropriate end of the
edge's 3d curve must be &lt;= this tolerance.
If a trim begins or ends at this vertex,
then the distance from the vertex's 3d point
to the 3d point on the surface obtained by
evaluating the surface at the appropriate
end of the trimming curve must be &lt;= this
tolerance.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepVertex.m_ei">
            <summary>
indices of edges starting/ending at this vertex

For closed edges, edge.m_vi[0] = edge.m_vi[1] and 
edge.m_edge_index appears twice in the m_ei[] array.
The first occurance of edge.m_edge_index in m_ei[]
is for the closed edge starting the vertex.
The second occurance of edge,m_edge_index in m_ei[]
is for the closed edge ending at the vertex.
C.f. ON_Brep::Next/PrevEdge().
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepVertex.m_vertex_index">
            <summary>
index of the vertex in the ON_Brep.m_V[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnBrepVertex">
            <summary>
Brep vertex information is stored in ON_BrepVertex classes.
ON_Brep.m_V[] is an array of all the vertices in the brep.

If a vertex is a point on a face, then brep.m_E[m_ei]
will be an edge with no 3d curve.  This edge will have
a single trim with type ON_BrepTrim::ptonsrf.  There
will be a loop containing this single trim.
Use ON_Brep::NewPointOnFace() to create vertices that are
points on faces. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.EdgeCount">
            <summary>
number of edges that begin or end at this vertex.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.Tolerance">
            <returns>value of ON_BrepVertex::m_tolerance</returns>
            <remarks>Use ON_Brep::SetVertexTolerance( ON_BrepVertex&amp; ) to set tolerances.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.Point">
            <summary>
Vertex location.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBrepVertex.ComponentIndex">
            <summary>
virtual ON_Geometry::ComponentIndex() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepVertex.m_tolerance">
            <summary>
accuracy of vertex point (&gt;=0.0 or ON_UNSET_VALUE)
A value of ON_UNSET_VALUE indicates that the
tolerance should be computed.
A value of 0.0 indicates that the distance
from the vertex to any applicable edge or trim
end is &lt;=  ON_ZERO_TOLERANCE
If an edge begins or ends at this vertex,
then the distance from the vertex's 
3d point to the appropriate end of the
edge's 3d curve must be &lt;= this tolerance.
If a trim begins or ends at this vertex,
then the distance from the vertex's 3d point
to the 3d point on the surface obtained by
evaluating the surface at the appropriate
end of the trimming curve must be &lt;= this
tolerance.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepVertex.m_ei">
            <summary>
indices of edges starting/ending at this vertex

For closed edges, edge.m_vi[0] = edge.m_vi[1] and 
edge.m_edge_index appears twice in the m_ei[] array.
The first occurance of edge.m_edge_index in m_ei[]
is for the closed edge starting the vertex.
The second occurance of edge,m_edge_index in m_ei[]
is for the closed edge ending at the vertex.
C.f. ON_Brep::Next/PrevEdge().
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepVertex.m_vertex_index">
            <summary>
index of the vertex in the ON_Brep.m_V[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBrepVertex">
            <summary>
Brep vertex information is stored in ON_BrepVertex classes.
ON_Brep.m_V[] is an array of all the vertices in the brep.

If a vertex is a point on a face, then brep.m_E[m_ei]
will be an edge with no 3d curve.  This edge will have
a single trim with type ON_BrepTrim::ptonsrf.  There
will be a loop containing this single trim.
Use ON_Brep::NewPointOnFace() to create vertices that are
points on faces. 
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrimPoint.e">
            <summary>
corresponding edge curve parameter (ON_UNSET_VALUE if unknown)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrimPoint.t">
            <summary>
corresponding trim curve parameter
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBrepTrimPoint.p">
            <summary>
2d surface parameter space point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrimPoint.e">
            <summary>
corresponding edge curve parameter (ON_UNSET_VALUE if unknown)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrimPoint.t">
            <summary>
corresponding trim curve parameter
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBrepTrimPoint.p">
            <summary>
2d surface parameter space point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.OnCurve)">
            <summary>Extrude a curve to create a surface.</summary>
            <param name="pCurve">
[in] pointer to a curve. This pointer will be assigned to m_curve[0] and will be deleted by ~ON_SumSurface.
</param>
            <param name="pPathCurve">
[in] pointer to a path curve. This pointer will be assigned to m_curve[1] and will be deleted by ~ON_SumSurface.
</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Extrude a curve along a path to create a surface.</summary>
            <param name="curve">[in] curve is copied.</param>
            <param name="path_curve">[in] path_curve is copied.</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.OnCurve,RMA.OpenNURBS.IOn3dVector)">
            <summary>Extrude a curve to create a surface.</summary>
            <param name="pCurve">
[in] pointer to a curve. This pointer will be assigned to m_curve[0] and
will be deleted by ~ON_SumSurface.
</param>
            <param name="extrusion_vector">[in] extrusion vector (must be nonzero)</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSumSurface.Create(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOn3dVector)">
            <summary>Extrude a curve to create a surface.</summary>
            <param name="curve">[in] curve is copied.</param>
            <param name="extrusion_vector">[in] extrusion vector (must be nonzero)</param>
            <returns>TRUE if a valid surface is created.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnSumSurface.m_bbox">
            <summary>
lazy evaluation used in ON_SumSurface::BoundingBox()
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSumSurface.m_curve(System.Int32)">
            <summary>
for expert users
surface-PointAt(s,t) 
= m_curve[0]-&gt;PointAt(s) + m_curve[1]-&gt;PointAt(t) + m_basepoint;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSumSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSumSurface.m_bbox">
            <summary>
lazy evaluation used in ON_SumSurface::BoundingBox()
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSumSurface.m_curve(System.Int32)">
            <summary>
for expert users
surface-PointAt(s,t) 
= m_curve[0]-&gt;PointAt(s) + m_curve[1]-&gt;PointAt(t) + m_basepoint;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsConical">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsConical(RMA.OpenNURBS.OnCone)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsConical(RMA.OpenNURBS.OnCone,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsCylindrical">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsSpherical">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere)">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_bbox">
            <summary>
Bounding box of the surface of revolution.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_bTransposed">
            <summary>
If FALSE, the "u" parameter is the angle parameter
and the "v" parameter is the curve parameter.  
If TRUE,  the "u" parameter is the curve parameter
and the "v" parameter is the angle parameter.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_t">
            <summary>
The interval m_t specifies the parameterization for the
angular parameter; m_t must be an increasing interval.
The parameter m_t[0] corresonds to angle m_angle[0] and 
the parameter m_t[1] corresponds to angle m_angle[1].
Changing m_t and leaving m_angle unchanged will change the
parameterization but not change the locus of the surface.
Changing m_angle and leaving m_t unchanged, will change the
locus of the surface but not change the evaluation domain.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_angle">
            <summary>
Start and end angles of revolution in radians. 
The interval m_angle must be increasing and satisfiy 
ON_ZERO_TOLERANCE &lt; m_angle.Length() &lt;= 2.0*ON_PI
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_axis">
            <summary>
Axis of revolution.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnRevSurface.m_curve">
            <summary>
Revolute curve.
If m_curve is not NULL, then ~ON_RevSurface() deletes m_curve.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnRevSurface">
            <summary>surface of revolution</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsConical">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsConical(RMA.OpenNURBS.OnCone)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsConical(RMA.OpenNURBS.OnCone,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cone.</summary>
            <param name="cone">[out] if not NULL and TRUE is returned, the cone parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cone.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsCylindrical">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsCylindrical(RMA.OpenNURBS.OnCylinder,System.Double)">
            <summary>Test a surface of revolution to see if it is a portion of a cylinder.</summary>
            <param name="cylinder">[out] if not NULL and TRUE is returned, the cylinder parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a cylinder.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsSpherical">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere)">
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnRevSurface.IsSpherical(RMA.OpenNURBS.OnSphere,System.Double)">
            <summary>
returns TRUE if successful
</summary>
            <summary>
returns TRUE if successful
</summary>
            <summary>Test a surface of revolution to see if it is a portion of a sphere.</summary>
            <param name="sphere">
[out] if not NULL and TRUE is returned, the sphere parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>TRUE if the surface of revolution is a portion of a sphere.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_bbox">
            <summary>
Bounding box of the surface of revolution.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_bTransposed">
            <summary>
If FALSE, the "u" parameter is the angle parameter
and the "v" parameter is the curve parameter.  
If TRUE,  the "u" parameter is the curve parameter
and the "v" parameter is the angle parameter.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_t">
            <summary>
The interval m_t specifies the parameterization for the
angular parameter; m_t must be an increasing interval.
The parameter m_t[0] corresonds to angle m_angle[0] and 
the parameter m_t[1] corresponds to angle m_angle[1].
Changing m_t and leaving m_angle unchanged will change the
parameterization but not change the locus of the surface.
Changing m_angle and leaving m_t unchanged, will change the
locus of the surface but not change the evaluation domain.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_angle">
            <summary>
Start and end angles of revolution in radians. 
The interval m_angle must be increasing and satisfiy 
ON_ZERO_TOLERANCE &lt; m_angle.Length() &lt;= 2.0*ON_PI
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_axis">
            <summary>
Axis of revolution.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnRevSurface.m_curve">
            <summary>
Revolute curve.
If m_curve is not NULL, then ~ON_RevSurface() deletes m_curve.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnRevSurface">
            <summary>surface of revolution</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneSurface.Extents(System.Int32)">
            <summary>Gets the extents of the rectangle.</summary>
            <param name="dir">
0 gets plane's x coordinate extents
1 gets plane's y coordinate extents
</param>
            <returns>
Increasing interval
See Also: ON_PlaneSurface::Domain
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneSurface.SetExtents(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Sets the extents of then rectangle. Does not change the evaluation domain.</summary>
            <param name="dir">
0 sets plane's x coordinate extents
1 sets plane's y coordinate extents
</param>
            <param name="extents">[in] increasing interval</param>
            <returns>
True if successful.
See Also: ON_PlaneSurface::SetDomain
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneSurface.SetExtents(System.Int32,RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Sets the extents of then rectangle. Does not change the evaluation domain.</summary>
            <param name="dir">
0 sets plane's x coordinate extents
1 sets plane's y coordinate extents
</param>
            <param name="extents">[in] increasing interval</param>
            <param name="bSynchDomain">
[in] if true, the corresponding evaluation interval domain is set
so that it matches the extents interval
</param>
            <returns>
True if successful.
See Also: ON_PlaneSurface::SetDomain
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlaneSurface.m_plane">
            <summary>
An ON_PlaneSurface is really a finite rectangle.
m_plane defines the plane and m_extents[] stores
the x and y intervals of the plane that define the
rectangle.  The m_domain[] intervals specify the
evaluation domain.  Changing the extents are domain
are INDEPENDENT of each other.  Use Domain() and
SetDomain() to control the evluation domain.  Use
Extents() and SetExtents() to control the rectangle
extents.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneSurface.Extents(System.Int32)">
            <summary>Gets the extents of the rectangle.</summary>
            <param name="dir">
0 gets plane's x coordinate extents
1 gets plane's y coordinate extents
</param>
            <returns>
Increasing interval
See Also: ON_PlaneSurface::Domain
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlaneSurface.m_plane">
            <summary>
An ON_PlaneSurface is really a finite rectangle.
m_plane defines the plane and m_extents[] stores
the x and y intervals of the plane that define the
rectangle.  The m_domain[] intervals specify the
evaluation domain.  Changing the extents are domain
are INDEPENDENT of each other.  Use Domain() and
SetDomain() to control the evluation domain.  Use
Extents() and SetExtents() to control the rectangle
extents.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates the deformation. Used by ON_CageMorph::MorphPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.AddControlLocalizer(System.Double,System.Double)">
            <summary>Adds localizer with support near the controling NURBS object.</summary>
            <param name="support_distance">
[in] &gt;= 0
If the distance a point to the controls NURBS curve/surface/cage is less than
or equal to support_distance, then MorphPoint() deformation has 100% effect.
</param>
            <param name="falloff_distance">
[in] &gt; 0 
If the distance a point to the controls NURBS curve/surface/cage is more than
support_distance+falloff_distance, then MorphPoint() deformation does not move
the point. As the distance varies from support_distance to support_distance+falloff_distance
the deformation attenuates from 100% to 0%.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.CVCount">
            <summary>
Returns: Number of control points in the target NURBS object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.MakeNonRational">
            <summary>
Description: Makes the target NURBS object non-rational.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.MakeRational">
            <summary>
Description: Makes the target NURBS object rational.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMorphControl.IsRational">
            <summary>
Returns: True if the target NURBS object is rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMorphControl.m_sporh_tolerance">
            <summary>
ON_SpaceMorphOptions
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMorphControl.m_nurbs_curve0">
            <summary>
The value of m_varient determines which nurbs object
controls the cage
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMorphControl.m_varient">
            <summary>
1= curve, 2 = surface, 3 = cage
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMorphControl.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates the deformation. Used by ON_CageMorph::MorphPoint().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMorphControl.CVCount">
            <summary>
Returns: Number of control points in the target NURBS object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMorphControl.IsRational">
            <summary>
Returns: True if the target NURBS object is rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMorphControl.m_sporh_tolerance">
            <summary>
Rhino captive object ids
</summary>
            <summary>
Use ON_GetCageXform to set m_cage_xform.
Used to localize the deformation
</summary>
            <summary>
ON_SpaceMorphOptions
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMorphControl.m_nurbs_curve0">
            <summary>
The value of m_varient determines which nurbs object
controls the cage
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMorphControl.m_varient">
            <summary>
1= curve, 2 = surface, 3 = cage
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.ReserveCVCapacity(System.Int32)">
            <summary>
Description: cv_capacity - [in] number of doubles to reserve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsSingular(System.Int32)">
            <summary>TRUE if surface side is collapsed to a point</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsPeriodic(System.Int32)">
            <summary>
TRUE if NURBS surface is periodic (degree &gt; 1,
periodic knot vector, last degree many CVs
are duplicates of first degree many CVs.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsClosed(System.Int32)">
            <summary>
TRUE if NURBS surface is closed (either surface has
clamped end knots and euclidean location of start
CV = euclidean location of end CV, or surface is
periodic.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Knot(System.Int32,System.Int32)">
            <summary>Get a knot value.</summary>
            <param name="dir">0 = "r", 1 = "s", 2 = "t"</param>
            <param name="knot_index">( 0 to KnotCount(dir) - 1 )</param>
            <returns>
Knot value or RMA.OpenNURBS.OnUtil.On_UNSET_VALUE if input is not valid.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetKnot(System.Int32,System.Int32,System.Double)">
            <summary>Set a knot value.</summary>
            <param name="dir">0 = "r", 1 = "s", 2 = "t"</param>
            <param name="knot_index">( 0 to KnotCount(dir) - 1 )</param>
            <param name="knot_value">value for knot</param>
            <returns>
True if knot value is set.  False if input is not valid.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
set a single control vertex
value of control vertex
If NURBS is not rational, euclidean
location of homogeneous point will
be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single control vertex
If NURBS is rational, weight
will be set to 1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.SetWeight(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
set value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCage::GetCV( ON_3dPoint&amp; ) or ON_NurbsCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Nurbs surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Nurbs surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCage::CVStyle ON_NurbsCage::GetCV ON_NurbsCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.CVCount(System.Int32)">
            <summary>
number of control vertices
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates bezer volume map. Parameters: rst - [in] Returns: Value of the nurbs volume map at (rst.x,rst.y,rst.z).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the nurbs volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Domain(System.Int32)">
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.EmergencyDestroy">
            <summary>
call if memory used by ON_NurbsCage becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.Create(RMA.OpenNURBS.IOnBoundingBox,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Nurbs volume with corners defined by a bounding box.</summary>
            <param name="box_corners">
[in] 8 points that define corners of the volume

     7______________6
     |\             |
     | \            | 
     |  \ _____________
     |   4          |   5
     |   |          |   |
     |   |          |   |
     3---|----------2   |
     \   |          \   |
      \  |z          \  |
     y \ |            \ |
        \0_____________\1
                x
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCage.IsParallelogram(System.Double)">
            <summary>
True if the cage is a parallelogram within the tolerance. This means
the cage can be used as a starting point for cage deformations.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCage.m_dim">
            <summary>
NOTE: These members are left "public" so that expert users may efficiently
     create nurbs curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.GrevilleAbcissa(System.Int32,System.Int32)">
            <param name="gindex">index (0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsSingular(System.Int32)">
            <summary>TRUE if surface side is collapsed to a point</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsPeriodic(System.Int32)">
            <summary>
TRUE if NURBS surface is periodic (degree &gt; 1,
periodic knot vector, last degree many CVs
are duplicates of first degree many CVs.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsClosed(System.Int32)">
            <summary>
TRUE if NURBS surface is closed (either surface has
clamped end knots and euclidean location of start
CV = euclidean location of end CV, or surface is
periodic.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.Knot(System.Int32,System.Int32)">
            <summary>get a knot vector value</summary>
            <param name="dir">0 = "r", 1 = "s", 2 = "t"</param>
            <param name="knot_index">( 0 to KnotCount(dir) - 1 )</param>
            <returns>
Knot value or RMA.OpenNURBS.OnUtil.On_UNSET_VALUE if input is not valid.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="arg4">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCage::GetCV( ON_3dPoint&amp; ) or ON_NurbsCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Nurbs surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Nurbs surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCage::CVStyle ON_NurbsCage::GetCV ON_NurbsCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.CVCount(System.Int32)">
            <summary>
number of control vertices
</summary>
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluates bezer volume map. Parameters: rst - [in] Returns: Value of the nurbs volume map at (rst.x,rst.y,rst.z).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the nurbs volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.Domain(System.Int32)">
            <param name="dir">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCage.IsParallelogram(System.Double)">
            <summary>
True if the cage is a parallelogram within the tolerance. This means
the cage can be used as a starting point for cage deformations.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCage.m_dim">
            <summary>
NOTE: These members are left "public" so that expert users may efficiently
     create nurbs curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <param name="dimension">(&gt;= 1)</param>
            <param name="bIsRational">TRUE to make a rational NURBS</param>
            <param name="order0">(&gt;= 2)</param>
            <param name="order1">(&gt;= 2)</param>
            <param name="cv_count0">cv count0 (&gt;= order0)</param>
            <param name="cv_count1">cv count1 (&gt;= order1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ConvertSpanToBezier(System.Int32,System.Int32,RMA.OpenNURBS.OnBezierSurface@)">
            <summary>Convert a NURBS surface bispan into a bezier surface.</summary>
            <param name="span_index0">
[in] Specifies the "u" span and must satisfy
0 &lt;= span_index0 &lt;= m_cv_count[0]-m_order[0]
m_knot[0][span_index0+m_order[0]-2] &lt; m_knot[0][span_index0+m_order[0]-1]
</param>
            <param name="span_index1">
[in] Specifies the "v" span and must satisfy
0 &lt;= span_index1 &lt;= m_cv_count[1]-m_order[1]
m_knot[1][span_index1+m_order[1]-2] &lt; m_knot[1][span_index1+m_order[1]-1]
</param>
            <param name="bezier_surface">[out] bezier surface returned here</param>
            <returns>
TRUE if successful
FALSE if input is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ReserveCVCapacity(System.Int32)">
            <summary>
returns FALSE if allocation fails
does not change m_order or m_cv_count
</summary>
            <param name="cv_array_capacity">minimum capacity of m_cv[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ReserveKnotCapacity(System.Int32,System.Int32)">
            <summary>
returns FALSE if allocation fails
does not change m_order or m_cv_count
</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="knot_array_capacity">minimum capacity of m_knot[] array</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.TensorProduct(RMA.OpenNURBS.IOnNurbsCurve,RMA.OpenNURBS.IOnNurbsCurve,RMA.OpenNURBS.OnTensorProduct@)">
            <summary>
Creates a tensor product nurbs surface with srf(s,t) = T(A(s),B(t));
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ChangeSurfaceSeam(System.Int32,System.Double)">
            <summary>
If the surface is closed in direction dir, then modify it so that
the seam is at parameter t in the dir direction.
</summary>
            <param name="dir">[in] must be 0 or 1</param>
            <param name="t">
[in] dir parameter of seam, must have Domain(dir).Includes(t).
The resulting surface domain in the dir direction will start at t.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IncreaseDegree(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.InsertKnot(System.Int32,System.Double)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="knot_value">value of knot</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.InsertKnot(System.Int32,System.Double,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="knot_value">value of knot</param>
            <param name="knot_multiplicity">multiplicity of knot ( &gt;= 1 and &lt;= degree )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ClampEnd(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">0 = clamp start, 1 = clamp end, 2 = clamp start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ZeroCVs">
            <summary>
zeros all CVs (any weights set to 1);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GetGrevilleAbcissae(System.Int32,System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissa() for details</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GrevilleAbcissa(System.Int32,System.Int32)">
            <param name="cv_index">0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SuperfluousKnot(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsClamped(System.Int32,System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakePeriodicUniformKnotVector(System.Int32)">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakePeriodicUniformKnotVector(System.Int32,System.Double)">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakeClampedUniformKnotVector(System.Int32)">
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakeClampedUniformKnotVector(System.Int32,System.Double)">
            <summary>
knot[] array
</summary>
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="dir">[in] 0 = u knots, 1 = v knots</param>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also:
ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.KnotMultiplicity(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Knot(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetKnot(System.Int32,System.Int32,System.Double)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
            <param name="knot_value">value for knot</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCVColumn(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Sets CV( col_index, * )</summary>
            <param name="col_index">col_index &gt;= 0 and &lt; m_cv_count[0]</param>
            <param name="cv">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCVRow(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Sets CV( *, row_index )</summary>
            <param name="row_index">row_index &gt;= 0 and &lt; m_cv_count[1]</param>
            <param name="cv">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>set a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">value of control vertex</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>set a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.SetWeight(System.Int32,System.Int32,System.Double)">
            <summary>set value of control vertex weight</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Weight(System.Int32,System.Int32)">
            <summary>get value of control vertex weight</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsSurface::GetCV( ON_3dPoint&amp; ) or ON_NurbsSurface::GetCV( ON_4dPoint&amp; ). Parameters: i - [in] (0 &lt;= i &lt; m_cv_count[0]) j - [in] (0 &lt;= j &lt; m_cv_count[1]) Returns: Pointer to control vertex. Remarks: If the NURBS surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsSurface::CVStyle ON_NurbsSurface::GetCV ON_NurbsSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVCount(System.Int32)">
            <summary>number of control vertices</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Order(System.Int32)">
            <summary>order = degree + 1</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CVSize">
            <summary>
number of doubles per control vertex = IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsRational">
            <summary>
TRUE if NURBS surface is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.ControlPolygonLength(System.Int32)">
            <summary>Get the maximum length of a nurb surface's control polygon rows and/or columns</summary>
            <param name="dir">
[in] 0 to get "u" direction length, 1 to get "v" direction length
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.op_Implicit(RMA.OpenNURBS.IOnBezierSurface)~RMA.OpenNURBS.OnNurbsSurface">
            <summary>
Set NURBS surface equal to bezier surface with domain [0,1]x[0,1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.EmergencyDestroy">
            <summary>
call if memory used by this class becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CollapseSide(System.Int32)">
            <summary>Collapse the side of a NURBS surface to a single point.</summary>
            <param name="side">
0 = south west,
1 = south east,
2 = north east,
3 = north west
</param>
            <returns>True if successful.</returns>
            <remarks>
If the surface is rational, the weights of the side control points must be set before calling CollapseSide.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CollapseSide(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Collapse the side of a NURBS surface to a single point.</summary>
            <param name="side">
0 = south west,
1 = south east,
2 = north east,
3 = north west
</param>
            <param name="point">
[in] point to collapse to. If point is ON_unset_point, the current location of the start of the side is used.
</param>
            <returns>True if successful.</returns>
            <remarks>
If the surface is rational, the weights of the side control points must be set before calling CollapseSide.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateConeSurface(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve)">
            <summary>Create a cone surface from a curve to a point.</summary>
            <param name="apex_point">[in]</param>
            <param name="curve">[in]</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true cone surface has parameterization srf(s,t) = (1.0-t)*curve(s) + t*apex_point.
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curve(s) + t*apex_point,
where nurbs_curve is the NURBS form of curve. If the parameterization of nurbs_curve
does not match the parameterization of curve, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateConeSurface(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a cone surface from a curve to a point.</summary>
            <param name="apex_point">[in]</param>
            <param name="curve">[in]</param>
            <param name="curve_domain">[in] if not NULL, then this is a subdomain of curve to use for the ruled surface.</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true cone surface has parameterization srf(s,t) = (1.0-t)*curve(s) + t*apex_point.
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curve(s) + t*apex_point,
where nurbs_curve is the NURBS form of curve. If the parameterization of nurbs_curve
does not match the parameterization of curve, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateRuledSurface(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve)">
            <summary>Create a ruled surface from two curves.</summary>
            <param name="curveA">[in] (must have same NURBS form knots as curveB)</param>
            <param name="curveB">[in] (must have same NURBS form knots as curveA)</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true ruled surface has parameterization srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
where nurbs_curveX is the NURBS form of curveX. If the parameterization of nurbs_curveX
does not match the parameterization of curveX, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateRuledSurface(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a ruled surface from two curves.</summary>
            <param name="curveA">[in] (must have same NURBS form knots as curveB)</param>
            <param name="curveB">[in] (must have same NURBS form knots as curveA)</param>
            <param name="curveA_domain">[in] if not NULL, then this is a subdomain of curveA to use for the ruled surface.</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true ruled surface has parameterization srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
where nurbs_curveX is the NURBS form of curveX. If the parameterization of nurbs_curveX
does not match the parameterization of curveX, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.CreateRuledSurface(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a ruled surface from two curves.</summary>
            <param name="curveA">[in] (must have same NURBS form knots as curveB)</param>
            <param name="curveB">[in] (must have same NURBS form knots as curveA)</param>
            <param name="curveA_domain">[in] if not NULL, then this is a subdomain of curveA to use for the ruled surface.</param>
            <param name="curveB_domain">[in] if not NULL, then this is a subdomain of curveA to use for the ruled surface.</param>
            <returns>
0 failure
1 success - parameterization is exact
2 success - parameterization is not exact
</returns>
            <remarks>
The ruling parameter is the second surface parameter and it is in the interval [0,1].
The true ruled surface has parameterization srf(s,t) = (1.0-t)*curveA(s) + t*curveB(s).
The returned NURBS surface has parameterization srf(s,t) = (1.0-t)*nurbs_curveA(s) + t*nurbs_curveB(s),
where nurbs_curveX is the NURBS form of curveX. If the parameterization of nurbs_curveX
does not match the parameterization of curveX, then 2 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Create(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
            <param name="dim">dimension (&gt;= 1)</param>
            <param name="is_rat">TRUE to make a rational NURBS</param>
            <param name="order0">order0 (&gt;= 2)</param>
            <param name="order1">order1 (&gt;= 2)</param>
            <param name="cv_count0">cv count0 (&gt;= order0)</param>
            <param name="cv_count1">cv count0 (&gt;= order1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.Initialize">
            <summary>
zeros all fields
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_cv_capacity">
            <summary>
If m_cv_capacity &gt; 0, then m_cv[] is an array of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsSurface class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not deleted by the destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_cv_stride(System.Int32)">
            <summary>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_knot_capacity(System.Int32)">
            <summary>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsSurface class using rhmalloc(),
onrealloc(), and rhfree().
If m_knot_capacity is 0 and m_knot is not NULL, then  m_knot[] is assumed to
be big enough for any requested operation and m_knot[] is not deleted by the
destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_cv_count(System.Int32)">
            <summary>
number of control vertices ( &gt;= order )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_order(System.Int32)">
            <summary>
order = degree+1 (&gt;=2)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_is_rat">
            <summary>
1 for rational B-splines. (Control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsSurface.m_dim">
            <summary>
(&gt;=1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.ConvertSpanToBezier(System.Int32,System.Int32,RMA.OpenNURBS.OnBezierSurface@)">
            <summary>Convert a NURBS surface bispan into a bezier surface.</summary>
            <param name="span_index0">
[in] Specifies the "u" span and must satisfy
0 &lt;= span_index0 &lt;= m_cv_count[0]-m_order[0]
m_knot[0][span_index0+m_order[0]-2] &lt; m_knot[0][span_index0+m_order[0]-1]
</param>
            <param name="span_index1">
[in] Specifies the "v" span and must satisfy
0 &lt;= span_index1 &lt;= m_cv_count[1]-m_order[1]
m_knot[1][span_index1+m_order[1]-2] &lt; m_knot[1][span_index1+m_order[1]-1]
</param>
            <param name="bezier_surface">[out] bezier surface returned here</param>
            <returns>
TRUE if successful
FALSE if input is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GetGrevilleAbcissae(System.Int32,System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissa() for details</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GrevilleAbcissa(System.Int32,System.Int32)">
            <param name="cv_index">0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.SuperfluousKnot(System.Int32,System.Int32)">
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsClamped(System.Int32,System.Int32)">
            <summary>
knot[] array
</summary>
            <summary>determine if knot vector is clamped</summary>
            <param name="dir">dir 0 = "s", 1 = "t"</param>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.KnotMultiplicity(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.Knot(System.Int32,System.Int32)">
            <param name="dir">0 = "s", 1 = "t"</param>
            <param name="knot_index">( 0 to KnotCount - 1 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="cv">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.Weight(System.Int32,System.Int32)">
            <summary>get value of control vertex weight</summary>
            <param name="i">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
            <param name="j">CV index ( 0 &lt;= i &lt;= CVCount(0), 0 &lt;= j &lt;= CVCount(1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsSurface::GetCV( ON_3dPoint&amp; ) or ON_NurbsSurface::GetCV( ON_4dPoint&amp; ). Parameters: i - [in] (0 &lt;= i &lt; m_cv_count[0]) j - [in] (0 &lt;= j &lt; m_cv_count[1]) Returns: Pointer to control vertex. Remarks: If the NURBS surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsSurface::CVStyle ON_NurbsSurface::GetCV ON_NurbsSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational         m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.KnotCount(System.Int32)">
            <summary>
total number of knots in knot vector
</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVCount">
            <summary>
total number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVCount(System.Int32)">
            <summary>number of control vertices</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.Order(System.Int32)">
            <summary>order = degree + 1</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.CVSize">
            <summary>
number of doubles per control vertex = IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsRational">
            <summary>
TRUE if NURBS surface is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.ControlPolygonLength(System.Int32)">
            <summary>Get the maximum length of a nurb surface's control polygon rows and/or columns</summary>
            <param name="dir">
[in] 0 to get "u" direction length, 1 to get "v" direction length
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsSurface.IsDuplicate(RMA.OpenNURBS.IOnNurbsSurface,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS surface</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are tne same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_cv_capacity">
            <summary>
If m_cv_capacity &gt; 0, then m_cv[] is an array of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsSurface class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not deleted by the destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_cv_stride(System.Int32)">
            <summary>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_knot_capacity(System.Int32)">
            <summary>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsSurface class using rhmalloc(),
onrealloc(), and rhfree().
If m_knot_capacity is 0 and m_knot is not NULL, then  m_knot[] is assumed to
be big enough for any requested operation and m_knot[] is not deleted by the
destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_cv_count(System.Int32)">
            <summary>
number of control vertices ( &gt;= order )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_order(System.Int32)">
            <summary>
order = degree+1 (&gt;=2)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_is_rat">
            <summary>
1 for rational B-splines. (Control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsSurface.m_dim">
            <summary>
(&gt;=1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTensorProduct.DimensionC">
            <summary>dimension of range space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTensorProduct.DimensionB">
            <summary>dimension of B space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTensorProduct.DimensionA">
            <summary>dimension of A space</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnTensorProduct">
            <summary>Pure virtual tensor passed to ON_NurbsSurface::TensorProduct()</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTensorProduct.DimensionC">
            <summary>dimension of range space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTensorProduct.DimensionB">
            <summary>dimension of B space</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTensorProduct.DimensionA">
            <summary>dimension of A space</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTensorProduct">
            <summary>Pure virtual tensor passed to ON_NurbsSurface::TensorProduct()</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveOnSurface.SwapCoordinates(System.Int32,System.Int32)">
            <summary>
(optional - default uses Transform for 2d and 3d objects)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveOnSurface.op_Implicit(RMA.OpenNURBS.IOnCurveOnSurface)~RMA.OpenNURBS.OnCurveOnSurface">
            <summary>
Parameters: 
p2dCurve - [in] ~ON_CurveOnSurface() will delete this curve. Use an ON_CurveProxy if you don't want the original deleted. 
p3dCurve - [in] ~ON_CurveOnSurface() will delete this curve. Use an ON_CurveProxy if you don't want the original deleted.
pSurface - [in] ~ON_CurveOnSurface() will delete this surface. Use an ON_SurfaceProxy if you don't want the original deleted.
</summary>
            <summary>
no implementation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentParameters">
            <summary>
Returns: Reference to m_t.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentCurves">
            <summary>
Returns: Reference to m_segment.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if the function returns true then
t is equal to, or is within tolerance of m_t[index].
if function returns false then the value of index is
t&lt;m_t[0] or m_t is empty   -1
m_t[i] &lt; t &lt; m_t[i+1]    i for 0&lt;=i&lt;=m_t.Count()-2
t&gt;m_t[ m_t.Count()-1]       m_t.Count()-1
</param>
            <param name="bEnableSnap">[in] if true use tolerance when comparing to m_t values</param>
            <returns>true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveNestingEx">
            <summary>
Removes the nested of polycurves. The result will have not have
an ON_PolyCurve as a segment but will have identical locus and
parameterization.
</summary>
            <returns>True if a nested polycurve was removed. False if no nested polycurves were found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveNesting">
            <summary>Same as RemoveNestingEx().</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.HarvestSegment(System.Int32)">
            <summary>
Use the HarvestSegment() function when you want to prevent a
segment from being destroyed by ~ON_PolyCurve().  HarvestSegment()
replaces the polycurve segment with a NULL.  Count() and parameter
information remains unchanged.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Remove(System.Int32)">
            <summary>
delete specified segment and reduce count by 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Remove">
            <summary>
delete last segment and reduce count by 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.AppendAndMatch(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
PrependAndMatch() and AppendAndMatch() return FALSE if this-&gt;IsCLosed() or 
this-&gt;Count() &gt; 0 and curve is closed
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.PrependAndMatch(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
PrependAndMatch() and AppendAndMatch() return FALSE if this-&gt;IsCLosed() or 
this-&gt;Count() &gt; 0 and curve is closed
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Insert(System.Int32,RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Append(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Prepend(RMA.OpenNURBS.OnCurve)">
            <summary>
ON_Curve pointers added with Prepend(), Append(), PrependAndMatch(), AppendANdMatch(),and Insert()
are deleted by ~ON_PolyCurve(). Use ON_CurveProxy( ON_Curve*) if you want
the original curve segment to survive ~ON_PolyCurve().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Reserve(System.Int32)">
            <summary>
make sure capacity is at least the specified count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.HasGap">
            <summary>
This is a quick way to see if the curve has gaps between the sub curve segments.
The test is fairly severe (ON_ComparePoint).
</summary>
            <returns>
0: The ends adjacent polycuve segments are coincident.
i &gt; 0: The end of polycuve segment (i-1) is not coincident with the start of polycurve segment i.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.LastSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.FirstSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentIndex(System.Double)">
            <summary>Find the segment used for evaluation at polycurve_parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
index of the segment used for evaluation at polycurve_parameter.
If polycurve_parameter &lt; Domain.Min(), then 0 is returned.
If polycurve_parameter &gt; Domain.Max(), then Count()-1 is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentDomain(System.Int32)">
            <summary>Returns the polycurve subdomain assigned to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>
The polycurve subdomain assigned to a segment curve.
Returns ([ON_UNSET_VALUE,ON_UNSET_VALUE) if segment_index &lt; 0 or segment_index &gt;= Count().
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.PolyCurveParameter(System.Int32,System.Double)">
            <summary>Converts a segment curve parameter to a polycurve parameter.</summary>
            <param name="segment_index">[in]</param>
            <param name="segmentcurve_parameter">[in]</param>
            <returns>
Polycurve evaluation parameter or ON_UNSET_VALUE if the polycurve
curve parameter cannot be computed.
See Also: ON_PolyCurve::SegmentCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentCurveParameter(System.Double)">
            <summary>Converts a polycurve parameter to a segment curve parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
Segment curve evaluation parameter or ON_UNSET_VALUE if the
segment curve parameter cannot be computed.
See Also: ON_PolyCurve::PolyCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.SegmentCurve(System.Int32)">
            <summary>Returns a pointer to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>A pointer to the segment curve. Returns NULL if segment_index &lt; 0 or segment_index &gt;= Count().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Count">
            <summary>
number of segment curves
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <param name="bRemoveShortSegments">[in] If true, then short segments are removed.</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.EmergencyDestroy">
            <summary>
call if memory used by ON_PolyCurve becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyCurve.#ctor(System.Int32)">
            <param name="capacity">initial capacity - use when a good estimate of the number of segments is known.</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnPolyCurve">
            <summary>
An ON_PolyCurve is an ON_Curve represented by a sequence of 
contiguous ON_Curve segments. A valid polycurve is represented 
by an array m_segment of Count()&gt;=1 curve objects	and a strictly
increasing array m_t of Count()+1 parameter values.  The i-th 
curve segment,  when considered as part of the polycurve, is affinely 
reparamaterized from m_t[i] to m_t[i+1], i.e., m_segment[i].Domain()[0] 
is mapped to 	m_t[i] and m_segment[i].Domain()[1] is mapped to m_t[i+1]. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentParameters">
            <summary>
Returns: Reference to m_t.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentCurves">
            <summary>
Returns: Reference to m_segment.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if the function returns true then
t is equal to, or is within tolerance of m_t[index].
if function returns false then the value of index is
t&lt;m_t[0] or m_t is empty   -1
m_t[i] &lt; t &lt; m_t[i+1]    i for 0&lt;=i&lt;=m_t.Count()-2
t&gt;m_t[ m_t.Count()-1]       m_t.Count()-1
</param>
            <param name="bEnableSnap">[in] if true use tolerance when comparing to m_t values</param>
            <returns>true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.HasGap">
            <summary>
This is a quick way to see if the curve has gaps between the sub curve segments.
The test is fairly severe (ON_ComparePoint).
</summary>
            <returns>
0: The ends adjacent polycuve segments are coincident.
i &gt; 0: The end of polycuve segment (i-1) is not coincident with the start of polycurve segment i.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.LastSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.FirstSegmentCurve">
            <summary>
returns NULL if count = 0
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentIndex(System.Double)">
            <summary>Find the segment used for evaluation at polycurve_parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
index of the segment used for evaluation at polycurve_parameter.
If polycurve_parameter &lt; Domain.Min(), then 0 is returned.
If polycurve_parameter &gt; Domain.Max(), then Count()-1 is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentDomain(System.Int32)">
            <summary>Returns the polycurve subdomain assigned to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>
The polycurve subdomain assigned to a segment curve.
Returns ([ON_UNSET_VALUE,ON_UNSET_VALUE) if segment_index &lt; 0 or segment_index &gt;= Count().
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.PolyCurveParameter(System.Int32,System.Double)">
            <summary>Converts a segment curve parameter to a polycurve parameter.</summary>
            <param name="segment_index">[in]</param>
            <param name="segmentcurve_parameter">[in]</param>
            <returns>
Polycurve evaluation parameter or ON_UNSET_VALUE if the polycurve
curve parameter cannot be computed.
See Also: ON_PolyCurve::SegmentCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentCurveParameter(System.Double)">
            <summary>Converts a polycurve parameter to a segment curve parameter.</summary>
            <param name="polycurve_parameter">[in]</param>
            <returns>
Segment curve evaluation parameter or ON_UNSET_VALUE if the
segment curve parameter cannot be computed.
See Also: ON_PolyCurve::PolyCurveParameter
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.SegmentCurve(System.Int32)">
            <summary>Returns a pointer to a segment curve.</summary>
            <param name="segment_index">[in] 0 based index (0 &lt;= segment_index &lt; Count() )</param>
            <returns>A pointer to the segment curve. Returns NULL if segment_index &lt; 0 or segment_index &gt;= Count().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.Count">
            <summary>
number of segment curves
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPolyCurve">
            <summary>
An ON_PolyCurve is an ON_Curve represented by a sequence of 
contiguous ON_Curve segments. A valid polycurve is represented 
by an array m_segment of Count()&gt;=1 curve objects	and a strictly
increasing array m_t of Count()+1 parameter values.  The i-th 
curve segment,  when considered as part of the polycurve, is affinely 
reparamaterized from m_t[i] to m_t[i+1], i.e., m_segment[i].Domain()[0] 
is mapped to 	m_t[i] and m_segment[i].Domain()[1] is mapped to m_t[i+1]. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.#ctor(System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>Create a NURBS curve with knot a cv memory allocated.</summary>
            <param name="dimension">[in] (&gt;= 1)</param>
            <param name="bIsRational">[in] TRUE to make a rational NURBS</param>
            <param name="order">[in] (&gt;= 2) The order=degree+1</param>
            <param name="cv_count">[in] (&gt;= order) number of control vertices</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.#ctor(RMA.OpenNURBS.IOnBezierCurve)">
            <summary>Create a NURBS curve equal to bezier with domain [0,1].</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Reparameterize(System.Double)">
            <summary>
Use a linear fractional transformation to reparameterize the NURBS curve.  This does not change the curve's domain.
</summary>
            <param name="c">
[in] reparameterization constant (generally speaking, c should be &gt; 0). The control points and knots are adjusted so that 
output_nurbs(t) = input_nurbs(lambda(t)), where lambda(t) = c*t/( (c-1)*t + 1 ).
Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) &gt; 0, lambda'(0) = c and lambda'(1) = 1/c.
</param>
            <returns>true if successful.</returns>
            <remarks>
The cv and knot values are values are changed so that output_nurbs(t) = input_nurbs(lambda(t)).
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ChangeEndWeights(System.Double,System.Double)">
            <summary>
Use a combination of scaling and reparameterization to change the end weights to the specified values.
</summary>
            <param name="w0">[in] weight for first cv</param>
            <param name="w1">[in] weight for last cv</param>
            <returns>true if successful.</returns>
            <remarks>
The domain, eucleanean locations of the control points, and locus of the curve do not change, but the weights,
homogeneous cv values and internal knot values may change. If w0 and w1 are 1 and the curve is not rational,
the curve is not changed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePiecewiseBezier">
            <summary>
Clamps ends and adds knots so the NURBS curve has bezier spans (all distinct knots have multiplitity = degree).
</summary>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePiecewiseBezier(System.Boolean)">
            <summary>
Clamps ends and adds knots so the NURBS curve has bezier spans (all distinct knots have multiplitity = degree).
</summary>
            <param name="bSetEndWeightsToOne">
[in] If true and the first or last weight is not one, then the first and last spans
are reparameterized so that the end weights are one.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.HasBezierSpans">
            <summary>
Returns TRUE if the NURBS curve has bezier spans 
(all distinct knots have multiplitity = degree)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ConvertSpanToBezier(System.Int32,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Converts a span of the NURBS curve into a bezier.  If the span is empty 
(m_knot[span_index+m_order-2] == m_knot[span_index+m_order-1]),
then FALSE is returned.
</summary>
            <param name="span_index">(0 &lt;= span_index &lt;= m_cv_count-m_order)</param>
            <param name="bezier">bezier returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ReserveKnotCapacity(System.Int32)">
            <summary>Tools for managing CV and knot memory</summary>
            <param name="arg1">number of doubles to reserve</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ReserveCVCapacity(System.Int32)">
            <summary>Tools for managing CV and knot memory</summary>
            <param name="arg1">number of doubles to reserve</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.InsertKnot(System.Double,System.Int32)">
            <summary>Insert a knot and update cv locations.</summary>
            <param name="knot_value">[in] m_knot[order-2] &lt; knot_value &lt; m_knot[m_cv_count-1]</param>
            <param name="knot_multiplicity">[in] 1 to degree - includes multiplicity of existing knots.</param>
            <remarks>Does not change parameterization or locus of curve.</remarks>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ClampEnd(System.Int32)">
            <summary>
Clamp end knots.  Does not modify control points.
</summary>
            <param name="end">[in] 0 = clamp start, 1 = clamp end, 2 = clamp start and end</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetGrevilleAbcissae(System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissae() for details</summary>
            <param name="g">g[cv_count]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GrevilleAbcissa(System.Int32)">
            <param name="index">index (0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SuperfluousKnot(System.Int32)">
            <param name="end">0 = start, 1 = end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsClamped">
            <summary>determine if knot vector is clamped</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePeriodicUniformKnotVector">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakePeriodicUniformKnotVector(System.Double)">
            <summary>
Make knot vector a periodic uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakePeriodicUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakeClampedUniformKnotVector">
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakeClampedUniformKnotVector(System.Double)">
            <summary>
Description:
 Get pointer to knot vector array.
Returns:
 pointer to knot vector array (m_knot).
See Also:
 ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
 ON_NurbsCurve::InsertKnot
</summary>
            <summary>
Make knot vector a clamped uniform knot vector
based on the current values of m_order and m_cv_count.
Does not change values of control vertices.
</summary>
            <param name="delta">[in] (&gt;0.0) knot spacing.</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Allocates m_knot[] if it is not big enough.
See Also: ON_MakeClampedUniformKnotVector
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.KnotMultiplicity(System.Int32)">
            <summary>Get knot multiplicity.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot multiplicity = m_knot[knot_index]
See Also:
ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
ON_NurbsCurve::InsertKnot
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Knot(System.Int32)">
            <summary>Get knot value.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot value = m_knot[knot_index]
See Also: ON_NurbsCurve::SetKnot, ON_NurbsCurve::KnotMultiplicity
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetKnot(System.Int32,System.Double)">
            <summary>Set knot value.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <param name="knot_value">[in]</param>
            <remarks>m_knot[] must exist.  Use ReserveKnotCapacity to allocate m_knot[].</remarks>
            <returns>
TRUE if successful
See Also: ON_NurbsCurve::ReserveKnotCapacity
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.IOn.point_style,System.Double[]@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="style">style to use for output point</param>
            <param name="arg3">array of length CVSize()</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>set a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">
value of control vertex
If NURBS is not rational, euclidean location of
homogeneous point will be used.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>set a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">
value of control vertex
If NURBS is rational, weight will be set to 1.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SetWeight(System.Int32,System.Double)">
            <summary>
set value of control vertex weight
</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Weight(System.Int32)">
            <summary>
get value of control vertex weight
</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCurve::GetCV( ON_3dPoint&amp; ) or ON_NurbsCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] Returns: Pointer to control vertex. Remarks: If the NURBS curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCurve::CVStyle ON_NurbsCurve::GetCV ON_NurbsCurve::Weight
</summary>
            <summary>
Returns the style of control vertices in the m_cv array.
</summary>
            <returns>
ON::not_rational          m_is_rat is FALSE
ON::homogeneous_rational  m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.KnotCount">
            <summary>
total number of knots in knot vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CVCount">
            <summary>
number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Order">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RepairBadKnots">
            <summary>
Looks for problems caused by knots that are close together or
have mulitplicity &gt;= order. If bRepair is true, the problems
are fixed. Does not change the domain.
</summary>
            <returns>
True if bad knots were found and can be repaired.
See Also: ON_NurbsCurve::RemoveShortSegments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RepairBadKnots(System.Double)">
            <summary>
Looks for problems caused by knots that are close together or
have mulitplicity &gt;= order. If bRepair is true, the problems
are fixed. Does not change the domain.
</summary>
            <param name="knot_tolerance">[in] &gt;= 0 When in doubt, use zero.</param>
            <returns>
True if bad knots were found and can be repaired.
See Also: ON_NurbsCurve::RemoveShortSegments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RepairBadKnots(System.Double,System.Boolean)">
            <summary>
Looks for problems caused by knots that are close together or
have mulitplicity &gt;= order. If bRepair is true, the problems
are fixed. Does not change the domain.
</summary>
            <param name="knot_tolerance">[in] &gt;= 0 When in doubt, use zero.</param>
            <param name="bRepair">
[in] If true, then problems are repaired. Otherwise this function
looks for problems that can be repaired, but does not modify the curve.
</param>
            <returns>
True if bad knots were found and can be repaired.
See Also: ON_NurbsCurve::RemoveShortSegments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
See Also: ON_NurbsCurve::RepairBadKnots
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <param name="bRemoveShortSegments">[in] If true, then short segments are removed.</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
See Also: ON_NurbsCurve::RepairBadKnots
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.SwapCoordinates(System.Int32,System.Int32)">
            <summary>
virtual ON_Geometry::SwapCoordinates override.
Swaps control vertex coordinate values with indices i and j.
</summary>
            <param name="i">[in] coordinate index</param>
            <param name="j">[in] coordinate index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
virtual ON_Geometry::Transform override.
Transforms the NURBS curve.
</summary>
            <param name="xform">[in] transformation to apply to object.</param>
            <remarks>
When overriding this function, be sure to include a call
to ON_Object::TransformUserData() which takes care of 
transforming any ON_UserData that may be attached to 
the object.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.op_Implicit(RMA.OpenNURBS.IOnBezierCurve)~RMA.OpenNURBS.OnNurbsCurve">
            <summary>
Set NURBS curve equal to bezier with domain [0,1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.EmergencyDestroy">
            <summary>
Call if memory used by ON_NurbsCurve becomes invalid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Destroy">
            <summary>
Description:
 Deallocate knot and cv memory.  Zeros all fields.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreatePeriodicUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Create a periodic uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=max(3,order-1)) number of distinct control vertices
array of distinct control vertex locations.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreatePeriodicUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[],System.Double)">
            <summary>Create a periodic uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=max(3,order-1)) number of distinct control vertices
array of distinct control vertex locations.
</param>
            <param name="knot_delta">[in] (&gt;0.0) knot spacing</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreateClampedUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[])">
            <summary>Create a clamped uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=order) number of control vertices
array of control vertex locations.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.CreateClampedUniformNurbs(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint[],System.Double)">
            <summary>Create a clamped uniform NURBS curve from a list of control points</summary>
            <param name="dimension">[in] 1, 2 or 3</param>
            <param name="order">[in] (&gt;=2) order=degree+1</param>
            <param name="points">
[in] (&gt;=order) number of control vertices
array of control vertex locations.
</param>
            <param name="knot_delta">[in] (&gt;0.0) knot spacing</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Create(System.Int32,System.Boolean,System.Int32,System.Int32)">
            <summary>Create a NURBS curve with knot a cv memory allocated.</summary>
            <param name="dimension">[in] (&gt;= 1)</param>
            <param name="bIsRational">[in] TRUE to make a rational NURBS</param>
            <param name="order">[in] (&gt;= 2) The order=degree+1</param>
            <param name="cv_count">[in] (&gt;= order) number of control vertices</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.Initialize">
            <summary>
Zeros all fields.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_cv_capacity">
            <summary>
If m_cv_capacity &gt; 0, then m_cv[] is an array
of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsCurve
class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not
NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not
deleted by the destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_cv_stride">
            <summary>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_knot_capacity">
            <summary>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsCurve class using rhmalloc(),
onrealloc(), and rhfree(). If m_knot_capacity is 0 and m_knot is not NULL, then
m_knot[] is assumed to be big enough for any requested operation and
m_knot[] is not deleted by the destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_cv_count">
            <summary>
number of control vertices ( &gt;= order )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_order">
            <summary>
order = degree+1 (&gt;=2)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_is_rat">
            <summary>
1 for rational B-splines. (Rational control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnNurbsCurve.m_dim">
            <summary>
(&gt;=1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.HasBezierSpans">
            <summary>
Returns TRUE if the NURBS curve has bezier spans 
(all distinct knots have multiplitity = degree)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.ConvertSpanToBezier(System.Int32,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Converts a span of the NURBS curve into a bezier.  If the span is empty 
(m_knot[span_index+m_order-2] == m_knot[span_index+m_order-1]),
then FALSE is returned.
</summary>
            <param name="span_index">(0 &lt;= span_index &lt;= m_cv_count-m_order)</param>
            <param name="bezier">bezier returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetGrevilleAbcissae(System.Double[]@)">
            <summary>see ON_GetGrevilleAbcissae() for details</summary>
            <param name="g">g[cv_count]</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GrevilleAbcissa(System.Int32)">
            <param name="index">index (0 &lt;= index &lt; CVCount(dir)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.SuperfluousKnot(System.Int32)">
            <param name="end">0 = start, 1 = end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsClamped">
            <summary>determine if knot vector is clamped</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsClamped(System.Int32)">
            <summary>determine if knot vector is clamped</summary>
            <param name="end">end to check: 0 = start, 1 = end, 2 = start and end</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.KnotMultiplicity(System.Int32)">
            <summary>Get knot multiplicity.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot multiplicity = m_knot[knot_index]
See Also:
ON_NurbsCurve::SetKnot, ON_NurbsCurve::Knot, 
ON_NurbsCurve::InsertKnot
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.Knot(System.Int32)">
            <summary>Get knot value.</summary>
            <param name="knot_index">[in] 0 &lt;= knot_index &lt;= KnotCount()-1</param>
            <returns>
knot value = m_knot[knot_index]
See Also: ON_NurbsCurve::SetKnot, ON_NurbsCurve::KnotMultiplicity
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets homogeneous cv</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="vertex_value">gets euclidean cv when NURBS is rational</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.GetCV(System.Int32,RMA.OpenNURBS.IOn.point_style,System.Double[]@)">
            <summary>get a single control vertex</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
            <param name="style">style to use for output point</param>
            <param name="arg3">array of length CVSize()</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.Weight(System.Int32)">
            <summary>
get value of control vertex weight
</summary>
            <param name="cv_index">CV index ( &gt;= 0 and &lt; CVCount() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_NurbsCurve::GetCV( ON_3dPoint&amp; ) or ON_NurbsCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] Returns: Pointer to control vertex. Remarks: If the NURBS curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the NURBS curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_NurbsCurve::CVStyle ON_NurbsCurve::GetCV ON_NurbsCurve::Weight
</summary>
            <summary>
Returns the style of control vertices in the m_cv array.
</summary>
            <returns>
ON::not_rational          m_is_rat is FALSE
ON::homogeneous_rational  m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.KnotCount">
            <summary>
total number of knots in knot vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.CVCount">
            <summary>
number of control vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.Order">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnNurbsCurve.IsDuplicate(RMA.OpenNURBS.IOnNurbsCurve,System.Boolean,System.Double)">
            <summary>See if this and other are same NURBS geometry.</summary>
            <param name="other">[in] other NURBS curve</param>
            <param name="bIgnoreParameterization">[in] if true, parameterization and orientaion are ignored.</param>
            <param name="tolerance">[in] tolerance to use when comparing control points.</param>
            <returns>true if curves are the same.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_cv_capacity">
            <summary>
If m_cv_capacity &gt; 0, then m_cv[] is an array
of at least m_cv_capacity doubles whose
memory is managed by the ON_NurbsCurve
class using rhmalloc(), onrealloc(), and rhfree().
If m_cv_capacity is 0 and m_cv is not
NULL, then m_cv[] is assumed to be big enough
for any requested operation and m_cv[] is not
deleted by the destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_cv_stride">
            <summary>
The pointer to start of "CV[i]" is m_cv + i*m_cv_stride.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_knot_capacity">
            <summary>
If m_knot_capacity &gt; 0, then m_knot[] is an array of at least m_knot_capacity
doubles whose memory is managed by the ON_NurbsCurve class using rhmalloc(),
onrealloc(), and rhfree(). If m_knot_capacity is 0 and m_knot is not NULL, then
m_knot[] is assumed to be big enough for any requested operation and
m_knot[] is not deleted by the destructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_cv_count">
            <summary>
number of control vertices ( &gt;= order )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_order">
            <summary>
order = degree+1 (&gt;=2)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_is_rat">
            <summary>
1 for rational B-splines. (Rational control vertices use homogeneous form.)
0 for non-rational B-splines. (Control verticies do not have a weight coordinate.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnNurbsCurve.m_dim">
            <summary>
(&gt;=1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.PointCount">
            <summary>
number of points in polyline
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if function returns false then value of index is
-1                            t&lt;m_t[0] or m_t is empty
0&lt;=i&lt;=m_t.Count()-2     m_t[i] &lt; t &lt; m_t[i+1]
m_t.Count()-1                 t&gt;m_t[ m_t.Count()-1]
if the function returns true then t is equal to, or is closest to and within tolerance of m_t[index].
</param>
            <param name="bEnableSnap">[in] enable snapping</param>
            <returns>
true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Description: Looks for segments that are shorter than tolerance that can be removed. If bRemoveShortSegments is true, then the short segments are removed. Does not change the domain, but it will change the relative parameterization. Parameters: tolerance - [in] bRemoveShortSegments - [in] If true, then short segments are removed. Returns: True if removable short segments can were found. False if no removable short segments can were found.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the
intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.SwapCoordinates(System.Int32,System.Int32)">
            <summary>
virtual ON_Geometry::SwapCoordinates override.
Swaps control point coordinate values with indices i and j.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>virtual ON_Geometry::Transform override. Transforms the NURBS curve.</summary>
            <param name="xform">[in] transformation to apply to object.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolylineCurve.EmergencyDestroy">
            <summary>
Description:
 Call if memory used by ON_PolylineCurve becomes invalid.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolylineCurve.m_dim">
            <summary>
2 or 3 (2 so ON_PolylineCurve can be uses as a trimming curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolylineCurve.m_t">
            <summary>
parameters
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.PointCount">
            <summary>
number of points in polyline
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.ParameterSearch(System.Double,System.Int32@,System.Boolean)">
            <summary>
Lookup a parameter in the m_t array, optionally using a built in snap
tolerance to snap a parameter value to an element of m_t.
</summary>
            <param name="t">[in] parameter</param>
            <param name="index">
[out] index into m_t such that if function returns false then value of index is
-1                            t&lt;m_t[0] or m_t is empty
0&lt;=i&lt;=m_t.Count()-2     m_t[i] &lt; t &lt; m_t[i+1]
m_t.Count()-1                 t&gt;m_t[ m_t.Count()-1]
if the function returns true then t is equal to, or is closest to and within tolerance of m_t[index].
</param>
            <param name="bEnableSnap">[in] enable snapping</param>
            <returns>
true if the t is exactly equal to, or within tolerance of (only if bEnableSnap==true) m_t[index].
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the
intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolylineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolylineCurve.m_dim">
            <summary>
2 or 3 (2 so ON_PolylineCurve can be uses as a trimming curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolylineCurve.m_t">
            <summary>
parameters
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnArc)">
            <summary>Create an arc curve with domain (0,arc.Length()).</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnArc,System.Double,System.Double)">
            <summary>Create an arc curve with domain (t0,t1)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnCircle)">
            <summary>
Creates a curve that is a complete circle with 
domain (0,circle.Length()).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.#ctor(RMA.OpenNURBS.IOnCircle,System.Double,System.Double)">
            <summary>Creates a curve that is a complete circle with domain (t0,t1).</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.Radius">
            <summary>The arc's radius.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.IsCircle">
            <summary>
Returns true if this arc curve is a complete circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval
that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.op_Implicit(RMA.OpenNURBS.IOnCircle)~RMA.OpenNURBS.OnArcCurve">
            <summary />
        </member>
        <member name="M:RMA.OpenNURBS.OnArcCurve.op_Implicit(RMA.OpenNURBS.IOnArc)~RMA.OpenNURBS.OnArcCurve">
            <summary>
Create an arc curve with domain (0,arc.Length()).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnArcCurve.m_dim">
            <summary>
The dimension of a arc curve can be 2 or 3.
(2 so ON_ArcCurve can be used as a trimming curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnArcCurve.m_t">
            <summary>
evaluation domain (always increasing)
( m_t[i] corresponds to m_arc.m_angle[i] )
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnArcCurve">
            <summary>
ON_ArcCurve is used to represent arcs and circles.
ON_ArcCurve.IsCircle() returns true if the curve
is a complete circle.

Details:
ON_ArcCurve is a subcurve of a circle, with a 
constant speed parameterization. The parameterization is
an affine linear reparameterzation of the underlying arc
m_arc onto the domain m_t.

A valid ON_ArcCurve has Radius()&gt;0 and  0&lt;AngleRadians()&lt;=2*PI
and a strictly increasing Domain(). 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.Radius">
            <summary>The arc's radius.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.IsCircle">
            <summary>
Returns true if this arc curve is a complete circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArcCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval
that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="P:RMA.OpenNURBS.IOnArcCurve.m_dim">
            <summary>
The dimension of a arc curve can be 2 or 3.
(2 so ON_ArcCurve can be used as a trimming curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnArcCurve.m_t">
            <summary>
evaluation domain (always increasing)
(2 so ON_ArcCurve can be used as a trimming curve)
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnArcCurve">
            <summary>
ON_ArcCurve is used to represent arcs and circles.
ON_ArcCurve.IsCircle() returns true if the curve
is a complete circle.

Details:
ON_ArcCurve is a subcurve of a circle, with a 
constant speed parameterization. The parameterization is
an affine linear reparameterzation of the underlying arc
m_arc onto the domain m_t.

A valid ON_ArcCurve has Radius()&gt;0 and  0&lt;AngleRadians()&lt;=2*PI
and a strictly increasing Domain(). 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.SwapCoordinates(System.Int32,System.Int32)">
            <summary>arg1 and arg2 are indices of coords to swap</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.MakeDeformable">
            <summary>
virtual ON_Geometry::MakeDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.#ctor(RMA.OpenNURBS.IOnLine,System.Double,System.Double)">
            <summary>t0 and t1 are the line domain</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
creates a 3d line curve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLineCurve.#ctor(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
creates a 2d line curve
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLineCurve.m_dim">
            <summary>
2 or 3 (2 so ON_LineCurve can be uses as a trimming curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLineCurve.m_t">
            <summary>
domain
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsMorphable">
            <summary>
virtual ON_Geometry override
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLineCurve.IsDeformable">
            <summary>
virtual ON_Geometry::IsDeformable() override
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLineCurve.m_dim">
            <summary>
2 or 3 (2 so ON_LineCurve can be uses as a trimming curve)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLineCurve.m_t">
            <summary>
domain
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.#ctor(System.Int32,System.Int32)">
            <param name="point_count0">point count0 (&gt;=1)</param>
            <param name="point_count1">point count1 (&gt;=1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Transpose">
            <summary>
transpose grid points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Reverse(System.Int32)">
            <summary>reverse grid order</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.GetPoint(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.SetPoint(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.PointArrayStride(System.Int32)">
            <summary>
point stride in grid direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.PointCount">
            <summary>
total number of points in grid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.PointCount(System.Int32)">
            <summary>number of points in grid direction</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.EmergencyDestroy">
            <summary>
call if memory used by point grid becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Create(System.Int32,System.Int32)">
            <param name="point_count0">point count0 (&gt;=1)</param>
            <param name="point_count1">point count1 (&gt;=1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointGrid.Initialize">
            <summary>
zeros all fields
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.GetPoint(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.PointArrayStride(System.Int32)">
            <summary>
point stride in grid direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.PointCount">
            <summary>
total number of points in grid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointGrid.PointCount(System.Int32)">
            <summary>number of points in grid direction</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFaceRef.MeshTopologyFace">
            <summary>
Returns: The mesh topology face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFaceRef.MeshFace">
            <summary>
Returns: The mesh face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFaceRef.MeshTopology">
            <summary>
Returns: The mesh topology associated with this mesh face reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshFaceRef.m_mesh_fi">
            <summary>m_mesh-&gt;m_F[] and m_mesh-&gt;m_top.m_tope[] index.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshFaceRef.m_mesh">
            <summary>parent mesh</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFaceRef.MeshTopologyFace">
            <summary>
Returns: The mesh topology face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFaceRef.MeshFace">
            <summary>
Returns: The mesh face associated with this mesh face reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFaceRef.MeshTopology">
            <summary>
Returns: The mesh topology associated with this mesh face reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshFaceRef.m_mesh_fi">
            <summary>m_mesh-&gt;m_F[] and m_mesh-&gt;m_top.m_tope[] index.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshFaceRef.m_mesh">
            <summary>parent mesh</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshEdgeRef.MeshTopologyEdge">
            <summary>
Returns: The mesh topology edge associated with this mesh edge reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshEdgeRef.Line">
            <summary>
The 3d location of the mesh edge. Returns ON_UNSET_POINT,ON_UNSET_POINT, is this ON_MeshEdgeRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshEdgeRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh edge reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshEdgeRef.m_top_ei">
            <summary>m_mesh-&gt;m_top.m_tope[] index</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshEdgeRef.m_mesh">
            <summary>parent mesh</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshEdgeRef.MeshTopologyEdge">
            <summary>
Returns: The mesh topology edge associated with this mesh edge reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshEdgeRef.Line">
            <summary>
The 3d location of the mesh edge. Returns ON_UNSET_POINT,ON_UNSET_POINT, is this ON_MeshEdgeRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshEdgeRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh edge reference or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshEdgeRef.m_top_ei">
            <summary>m_mesh-&gt;m_top.m_tope[] index</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshEdgeRef.m_mesh">
            <summary>parent mesh</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshVertexRef.MeshTopologyVertex">
            <summary>
Returns: The mesh topology vertex associated with this mesh vertex reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshVertexRef.Point">
            <summary>
The 3d location of the mesh vertex.
Returns ON_UNSET_POINT is this ON_MeshVertexRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshVertexRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh vertex reference
or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshVertexRef.m_top_vi">
            <summary>
m_mesh-&gt;m_top.m_topv[] index
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshVertexRef.m_mesh_vi">
            <summary>
m_mesh-&gt;m_V[] index
(can be -1 when m_top_vi references a shared vertex location)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshVertexRef.m_mesh">
            <summary>parent mesh</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshVertexRef.MeshTopologyVertex">
            <summary>
Returns: The mesh topology vertex associated with this mesh vertex reference.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshVertexRef.Point">
            <summary>
The 3d location of the mesh vertex.
Returns ON_UNSET_POINT is this ON_MeshVertexRef is not valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshVertexRef.MeshTopology">
            <summary>
The mesh topology associated with this mesh vertex reference
or NULL if it doesn't exist.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshVertexRef.m_top_vi">
            <summary>
m_mesh-&gt;m_top.m_topv[] index
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshVertexRef.m_mesh_vi">
            <summary>
m_mesh-&gt;m_V[] index
(can be -1 when m_top_vi references a shared vertex location)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshVertexRef.m_mesh">
            <summary>parent mesh</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.HasPackedTextureRegion">
            <returns>
True if the m_srf_scale[] values are positive and
the m_packed_tex_domain[] intervals are set to values
that describe a proper subrectangle of (0,1)x(0,1).
True does not necessarily mean the current values in
m_T[] are packed texture coordinates.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CreatePartition(System.Int32,System.Int32)">
            <summary>
Some rendering engines work best when processing small batches of
triangles.  CreatePartition() sorts the vertices and faces 
so that they can be processed in small batches.
</summary>
            <param name="arg1">maximum number of vertices in a partition</param>
            <param name="arg2">maximum number of triangles in a partition</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DestroyTopology">
            <summary>
If you modify the mesh in any way that may change its topology,
then call DestroyTopology().  Specifically if you add or remove
vertices or face, change vertex locations, or change the face m_vi[]
values, then you must call DestroyTopology().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Topology">
            <summary>
In order to keep the mesh facet definition simple and make the mesh
definition easily used in common rendering application, if two facets
share a vertex location but have different normals, curvatures, 
textures, etc., at that common vertex location, then the vertex is
duplicated.  When the topology of the mesh needs to be known,
use Topology() to get a class that provides complete topological
information about the mesh.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FaceIsHidden(System.Int32)">
            <summary>
Returns true if the mesh face is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshfi">[in] mesh face index.</param>
            <returns>True if mesh face is hidden.</returns>
            <remarks>A face is hidden if, and only if, at least one of its vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VertexIsHidden(System.Int32)">
            <summary>
Returns true if the mesh vertex is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshvi">[in] mesh vertex index.</param>
            <returns>True if mesh vertex is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetVertexHiddenFlag(System.Int32,System.Boolean)">
            <summary>
Returns: If the mesh has some hidden vertices, then an array of length VertexCount() is returned and the i-th element is true if the i-th vertex is hidden. If no vertices are hidden, NULL is returned.
</summary>
            <summary>Set the runtime vertex hidden flag.</summary>
            <param name="meshvi">[in] mesh vertex index</param>
            <param name="bHidden">[in] true to hide vertex</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DestroyHiddenVertexArray">
            <summary>
Destroys the m_H[] array and sets m_hidden_count=0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DeleteFace(System.Int32)">
            <summary>Removes a face from a mesh and does not alter the geometry of the remaining mesh.</summary>
            <param name="meshfi">[in] index of face in ON_Mesh.m_F[] array</param>
            <remarks>
This function calls DestroyTopology() and DestroyPartition().
The caller is responsible for calling Compact() if that step is required.
</remarks>
            <returns>true if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SwapEdge(System.Int32)">
            <summary>If the edge is shared by two triangular face, then the edge is "swapped". </summary>
            <param name="topei">[in] index of edge in MeshTopology().m_tope[] array</param>
            <returns>
true if successful
See Also: ON_Mesh::IsSwappableEdge
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsSwappableEdge(System.Int32)">
            <summary>Tests a mesh edge to see if it is valid as input to ON_Mesh::SwapMeshEdge.</summary>
            <param name="topei">[in] index of edge in MeshTopology().m_tope[] array</param>
            <returns>
true if edge can be swapped by ON_Mesh::SwapMeshEdge.
See Also: ON_Mesh::SwapEdge
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CollapseEdge(System.Int32)">
            <summary>Replace a mesh edge with a vertex at its center and update adjacent faces as needed.</summary>
            <param name="topei">[in] index of edge in MeshTopology().m_tope[] array</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="base_point">
[in] When computing the volume mass properties of a solid volume defined by several meshes,
pass the same base_point to each call to VolumeMassProperties() and add the answers.
When computing the volume mass properties of a solid defined by a single mesh, the center
of the bounding box is a good choice for base_point. If the mesh is closed, you can pass
ON_UNSET_POINT and the center of the bounding box will be used.
</param>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for
expert users who are computing a volume whose boundary is defined by several
non-closed breps, surfaces, and meshes. When computing the volume, volume centroid,
or volume first moments of a volume whose boundary is defined by several breps, surfaces,
and meshes, pass the same base_point to each call to VolumeMassProperties. When
computing the volume second moments or volume product moments of a volume whose
boundary is defined by several breps, surfaces, and meshes, you MUST pass the entire
volume's centroid as the base_point and the input mp parameter must contain the
results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeCentroid">
            <summary>Compute volume centroid of the mesh.</summary>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <param name="volume">[out] it not NULL, Volume of the mesh</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Volume">
            <summary>Compute volume of the mesh.</summary>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Volume(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Volume(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the volume calculation is returned.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaCentroid">
            <summary>Compute area centroid of the mesh.</summary>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.AreaCentroid(System.Double@)">
            <summary>Compute area centroid of the mesh.</summary>
            <param name="area">[out] it not NULL, area of the mesh</param>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Area">
            <summary>Compute area of the mesh.</summary>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Area(System.Double@)">
            <summary>
Description: Appends a list of mesh edges that begin or end at the specified vertices to the edges[] array. Parameters: vcount - [in] number of vertices vertex_index - [in] array of vertex indices bNoDuplicates - [in] If true, then only one edges[] is added for each edge, the first vertex index will alwasy be less than the second, and the returned elements are sorted in dictionary order. If false and an edge is shared by multiple faces, then there will be an edges[] element added for each face and the order of the vertex indicies will indicate the orientation of the edge with respect to the face. No sorting is performed in this case. edges - [out] Edges that begin or end at one of the specified vertices are appended to this array. Each ON_2dex records the start and end vertex index. Returns: Number of ON_2dex values appended to the edges[] array.
</summary>
            <summary>
Description: Appends a list of mesh edges to the edges[] array. Parameters: edges - [out] Each edges[] element is a pair of vertex indices. There is at least one face in the mesh with an edge running between the indicies. Returns: Number of ON_2dex values appended to the edges[] array.
</summary>
            <summary>Compute area of the mesh.</summary>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the area calculation is returned.
</param>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsManifold(System.Boolean)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsManifold(System.Boolean,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsManifold(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <param name="pbHasBoundary">
[out] If the input pointer is not NULL, then the returned value of
pbHasBoundary will be true if the mesh is a manifold and there is
at least one "edge" with no adjacent faces have compatible
face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.IsClosed">
            <summary>
Returns: True if every mesh "edge" has two or more faces.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetClosed(System.Int32)">
            <summary>
indices of appended mesh parts
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Append(RMA.OpenNURBS.IOnMesh)">
            <summary>
appends a copy of mesh to this and updates indices of appended mesh parts
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineIdenticalVertices">
            <summary>Combines identical vertices.</summary>
            <returns>
True if the mesh is changed, in which case the returned
mesh will have fewer vertices than the input mesh.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineIdenticalVertices(System.Boolean)">
            <summary>Combines identical vertices.</summary>
            <param name="bIgnoreVertexNormals">
[in] If true, then vertex normals are ignored when comparing vertices.
</param>
            <returns>
True if the mesh is changed, in which case the returned
mesh will have fewer vertices than the input mesh.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineIdenticalVertices(System.Boolean,System.Boolean)">
            <summary>Combines identical vertices.</summary>
            <param name="bIgnoreVertexNormals">
[in] If true, then vertex normals are ignored when comparing vertices.
</param>
            <param name="bIgnoreTextureCoordinates">
[in] If true, then vertex texture coordinates, colors, and
principal curvatures are ignored when comparing vertices.
</param>
            <returns>
True if the mesh is changed, in which case the returned
mesh will have fewer vertices than the input mesh.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CombineCoincidentVertices(RMA.OpenNURBS.IOn3fVector,System.Double)">
            <summary>
finds all coincident vertices and merges them if break angle is small enough
</summary>
            <param name="tolerance">coordinate tols for considering vertices to be coincident</param>
            <param name="cos_normal_angle">
cosine normal angle tolerance in radians
if vertices are coincident, then they are combined
if NormalA o NormalB &gt;= this value
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.EvaluateMeshGeometry(RMA.OpenNURBS.IOnSurface)">
            <summary>
evaluate surface at tcoords to set mesh geometry
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping)">
            <summary>Use a texture mapping function to set the m_T[] values.</summary>
            <param name="mapping">[in]</param>
            <returns>
True if successful.
See Also: ON_TextureMapping::GetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform)">
            <summary>Use a texture mapping function to set the m_T[] values.</summary>
            <param name="mapping">[in]</param>
            <param name="mesh_xform">
[in] If not NULL, the mapping calculation is performed as if 
the mesh were transformed by mesh_xform; the location of the
mesh is not changed.
</param>
            <returns>
True if successful.
See Also: ON_TextureMapping::GetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.SetTextureCoordinates(RMA.OpenNURBS.IOnTextureMapping,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>Use a texture mapping function to set the m_T[] values.</summary>
            <param name="mapping">[in]</param>
            <param name="mesh_xform">
[in] If not NULL, the mapping calculation is performed as if 
the mesh were transformed by mesh_xform; the location of the
mesh is not changed.
</param>
            <param name="bLazy">
[in] If true and the m_T[] values were set using the same mapping
parameters, then no calculation is performed.
</param>
            <returns>
True if successful.
See Also: ON_TextureMapping::GetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ReverseTextureCoordinates(System.Int32)">
            <summary>
Reverse one coordinate direction of the texture coordinates, within texture domain m_tex_domain
</summary>
            <param name="dir">
[in]
dir=0  first texture coordinate is reversed
dir=1 second texture coordinate is reversed
</param>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.TransposeTextureCoordinates">
            <summary>Transposes the texture coordinates</summary>
            <returns>true on success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.NormalizeTextureCoordinates">
            <summary>
Scales textures so the texture domains are [0,1] and
eliminates any texture rotations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ComputeVertexNormals">
            <summary>
uses face normals to cook up a vertex normal
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Compact">
            <summary>
Removes any unreferenced objects from arrays, reindexes as needed,
and shrinks arrays to minimum required size.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CullUnusedVertices">
            <summary>
returns number of culled vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.CullDegenerateFaces">
            <summary>
returns number of degenerate faces
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ComputeFaceNormal(System.Int32)">
            <summary>
computes face normal of indexed face
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ComputeFaceNormals">
            <summary>
compute face normals for all faces
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ConvertTrianglesToQuads(System.Double,System.Double)">
            <summary>Joins adjacent triangles into quads if the resulting quad is nice.</summary>
            <param name="angle_tol_radians">
[in] Used to compare adjacent triangles' face normals.
For two triangles to be considered, the angle between their
face normals has to be &lt;= angle_tol_radians.
When in doubt use ON_PI/90.0 (2 degrees).
</param>
            <param name="min_diagonal_length_ratio">
[in] ( &lt;= 1.0) For two triangles to be considered the ratio
of the resulting quad's diagonals (length of the shortest
diagonal)/(length of longest diagonal). has to be &gt;= min_diagonal_length_ratio.
When in doubt us .875.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.ConvertQuadsToTriangles">
            <summary>
Splits all quads along the short diagonal.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FlipFaceOrientation">
            <summary>
reverses face orientation (does nothing to normals)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FlipFaceNormals">
            <summary>
reverses face normals
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FlipVertexNormals">
            <summary>
reverses vertex normals
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.Flip">
            <summary>
reverses face orientations and flips vertex and face normals
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateBoundingBoxes">
            <summary>
Invalidates all cached bounding box information.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateCurvatureStats">
            <summary>
Call if defining geometry is changed by directly manipulating the m_T[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateTextureCoordinateBoundingBox">
            <summary>
Call if defining geometry is changed by directly manipulating the m_T[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateVertexNormalBoundingBox">
            <summary>
Call if defining geometry is changed by directly manipulating the m_N[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.InvalidateVertexBoundingBox">
            <summary>
Call if defining geometry is changed by directly manipulating the m_V[] array.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.GetCurvatureStats(RMA.OpenNURBS.IOn.curvature_style,RMA.OpenNURBS.OnMeshCurvatureStats@)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.HiddenVertexCount">
            <summary>
Returns: Number of vertices that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.HasVertexNormals">
            <summary>
normals at vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.TriangleCount">
            <summary>
number of faces that are triangles
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.QuadCount">
            <summary>
number of faces that are quads
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.MeshComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <param name="ci">
[in] a component index with type mesh_vertex, meshtop_vertex, meshtop_edge, or mesh_face.
</param>
            <returns>
A pointer to an ON_MeshVertexRef, ON_MeshEdgeRef, or ON_MeshFaceRef.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference from a mesh topology edge index.</summary>
            <param name="ci">[in] component index with type meshtop_edge</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.DestroyTree">
            <summary>
members will soon become invalid for reasons 
beyond your control. EmergencyDestroy() zeros
anything that could possibly cause
~ON_Mesh() to crash.  Calling
EmergencyDestroy() under normal conditions 
will result in ~ON_Mesh() leaking
memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMesh.EmergencyDestroy">
            <summary>
Call only when memory used by this class's members will soon become invalid for reasons 
beyond your control. EmergencyDestroy() zeros anything that could possibly cause ~ON_Mesh()
to crash. Calling EmergencyDestroy() under normal conditions will result in ~ON_Mesh() leaking
memory.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_parent">
            <summary>
runtime parent geometry (use ...::Cast() to get it)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_hidden_count">
            <summary>
number of vertices that are hidden = number of true values in m_H[] array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_H">
            <summary>
OPTIONAL vertex visibility.
If m_H.Count() = m_V.Count(), then
m_H[vi] is true if the vertex m_V[vi] 
is hidden.  Otherwise, all vertices are visible.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_C">
            <summary>
OPTIONAL vertex color
Either m_C[] has zero count or it has the same
count as m_V[], in which case m_C[j] reports
the color assigned to m_V[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_Ctag">
            <summary>
OPTIONAL tag for values in m_C[]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_K">
            <summary>
OPTIONAL surface curvatures
Either m_K[] has zero count or it has the same
count as m_V[], in which case m_K[j] reports
the surface curvatures at m_V[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_TC">
            <summary>
RUNTIME ONLY
 This array is used to cache texture coordinates used by
 rendering applications that require 1d texture coordinates,
 3d texture coordinates, or multiple sets of texture 
 coordinates (e.g. blended textures with different mappings).
 Users are responsible for verifying
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_T">
            <summary>
OPTIONAL texture coordinates for each vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_Ttag">
            <summary>
OPTIONAL tag for values in m_T[]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_FN">
            <summary>
OPTIONAL face unit normals
Either m_FN[] has zero count or it has the same
count as m_F[], in which case m_FN[j] reports
the unit normal for the facet m_F[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_N">
            <summary>
OPTIONAL vertex unit normals
Either m_N[] has zero count or it has the same
count as m_V[], in which case m_N[j] reports
the unit normal at m_V[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_F">
            <summary>
facets (triangle or quad)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMesh.m_V">
            <summary>
vertex locations
In a case where adjacent facets share a vertex
location but have distinct normals or texture
coordinates at that location, the vertex must
be duplicated.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.HasPackedTextureRegion">
            <returns>
True if the m_srf_scale[] values are positive and
the m_packed_tex_domain[] intervals are set to values
that describe a proper subrectangle of (0,1)x(0,1).
True does not necessarily mean the current values in
m_T[] are packed texture coordinates.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Topology">
            <summary>
In order to keep the mesh facet definition simple and make the mesh
definition easily used in common rendering application, if two facets
share a vertex location but have different normals, curvatures, 
textures, etc., at that common vertex location, then the vertex is
duplicated.  When the topology of the mesh needs to be known,
use Topology() to get a class that provides complete topological
information about the mesh.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.FaceIsHidden(System.Int32)">
            <summary>
Returns true if the mesh face is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshfi">[in] mesh face index.</param>
            <returns>True if mesh face is hidden.</returns>
            <remarks>A face is hidden if, and only if, at least one of its vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VertexIsHidden(System.Int32)">
            <summary>
Returns: If the mesh has some hidden vertices, then an array of length VertexCount() is returned and the i-th element is true if the i-th vertex is hidden. If no vertices are hidden, NULL is returned.
</summary>
            <summary>
Returns true if the mesh vertex is hidden. This is a runtime setting
that is not saved in 3dm files.
</summary>
            <param name="meshvi">[in] mesh vertex index.</param>
            <returns>True if mesh vertex is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the mesh.</summary>
            <param name="base_point">
[in] When computing the volume mass properties of a solid volume defined by several meshes,
pass the same base_point to each call to VolumeMassProperties() and add the answers.
When computing the volume mass properties of a solid defined by a single mesh, the center
of the bounding box is a good choice for base_point. If the mesh is closed, you can pass
ON_UNSET_POINT and the center of the bounding box will be used.
</param>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for
expert users who are computing a volume whose boundary is defined by several
non-closed breps, surfaces, and meshes. When computing the volume, volume centroid,
or volume first moments of a volume whose boundary is defined by several breps, surfaces,
and meshes, pass the same base_point to each call to VolumeMassProperties. When
computing the volume second moments or volume product moments of a volume whose
boundary is defined by several breps, surfaces, and meshes, you MUST pass the entire
volume's centroid as the base_point and the input mp parameter must contain the
results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeCentroid">
            <summary>Compute volume centroid of the mesh.</summary>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VolumeCentroid(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume centroid of the mesh.</summary>
            <param name="base_point">
[in] When computing the centroid of a solid volume defined by several meshes,
pass the same base_point to each call to GetVolumeCentroid() and add the answers.
When computing the centroid of a solid defined by a single mesh, the center of
the bounding box is a good choice for base_point.
</param>
            <param name="volume">[out] it not NULL, Volume of the mesh</param>
            <returns>Location of the volume centroid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Volume">
            <summary>Compute volume of the mesh.</summary>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Volume(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Volume(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Compute volume of the mesh.</summary>
            <param name="base_point">
[in] optional base point When computing the volume of solid defined
by several meshes, pass the same base_point to each call to volume.
When computing the volume of a solid defined by a single mesh,
the center of the bounding box is a good choice for base_point.
</param>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the volume calculation is returned.
</param>
            <returns>volume of the mesh.</returns>
            <example>
Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3.
The volume of the solid can be computed as follows.
ON_Mesh mesh1=..., mesh2=..., mesh3=...;
use the center of the solid's bounding box as a common base point.
ON_BoundingBox bbox = mesh1.BoundingBox();
mesh2.GetBoundingBox(bbox,TRUE);
mesh3.GetBoundingBox(bbox,TRUE);
ON_3dPoint base_point = bbox.Center()
double vol1_err, vol2_err, vol3_err;
double vol1 = mesh1.Volume(base_point,&amp;vol1_err);
double vol2 = mesh2.Volume(base_point,&amp;vol2_err);
double vol3 = mesh3.Volume(base_point,&amp;vol3_err);
double volume = vol1 + vol2 + vol3;
double error_estimate = vol1_err + vol2_err + vol3_err;
printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the mesh.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaCentroid">
            <summary>Compute area centroid of the mesh.</summary>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.AreaCentroid(System.Double@)">
            <summary>Compute area centroid of the mesh.</summary>
            <param name="area">[out] it not NULL, area of the mesh</param>
            <returns>
Location of area centroid.
See Also: ON_Mesh::AreaMassProperties
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Area">
            <summary>Compute area of the mesh.</summary>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.Area(System.Double@)">
            <summary>
Description: Appends a list of mesh edges to the edges[] array. Parameters: edges - [out] Each edges[] element is a pair of vertex indices. There is at least one face in the mesh with an edge running between the indicies. Returns: Number of ON_2dex values appended to the edges[] array.
</summary>
            <summary>Compute area of the mesh.</summary>
            <param name="error_estimate">
[out] if not NULL, an upper bound on the error in the area calculation is returned.
</param>
            <example>
ON_Mesh mesh = ...;
double area, error_estimate;
area = mesh.Area(&amp;error_estimate);
printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</example>
            <returns>Area of the mesh.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsManifold(System.Boolean)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsManifold(System.Boolean,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsManifold(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>Determine if the mesh is a manifold.</summary>
            <param name="bTopologicalTest">[in] If true, the query treats coincident vertices as the same.</param>
            <param name="pbIsOriented">
[out] If the input pointer is not NULL, then the returned value of
pbIsOriented will be true if the mesh is a manifold and adjacent
faces have compatible face normals.
</param>
            <param name="pbHasBoundary">
[out] If the input pointer is not NULL, then the returned value of
pbHasBoundary will be true if the mesh is a manifold and there is
at least one "edge" with no adjacent faces have compatible
face normals.
</param>
            <returns>True if every mesh "edge" has at most two adjacent faces.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.IsClosed">
            <summary>
Returns: True if every mesh "edge" has two or more faces.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.GetCurvatureStats(RMA.OpenNURBS.IOn.curvature_style,RMA.OpenNURBS.OnMeshCurvatureStats@)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.HiddenVertexCount">
            <summary>
Returns: Number of vertices that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.HasVertexNormals">
            <summary>
normals at vertices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.TriangleCount">
            <summary>
number of faces that are triangles
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.QuadCount">
            <summary>
number of faces that are quads
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.MeshComponent(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <param name="ci">
[in] a component index with type mesh_vertex, meshtop_vertex, meshtop_edge, or mesh_face.
</param>
            <returns>
A pointer to an ON_MeshVertexRef, ON_MeshEdgeRef, or ON_MeshFaceRef.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference from a mesh topology edge index.</summary>
            <param name="ci">[in] component index with type meshtop_edge</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMesh.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>
members will soon become invalid for reasons 
beyond your control. EmergencyDestroy() zeros
anything that could possibly cause
~ON_Mesh() to crash.  Calling
EmergencyDestroy() under normal conditions 
will result in ~ON_Mesh() leaking
memory.
</summary>
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_parent">
            <summary>
runtime parent geometry (use ...::Cast() to get it)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_hidden_count">
            <summary>
number of vertices that are hidden = number of true values in m_H[] array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_H">
            <summary>
OPTIONAL vertex visibility.
If m_H.Count() = m_V.Count(), then
m_H[vi] is true if the vertex m_V[vi] 
is hidden.  Otherwise, all vertices are visible.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_C">
            <summary>
OPTIONAL vertex color
Either m_C[] has zero count or it has the same
count as m_V[], in which case m_C[j] reports
the color assigned to m_V[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_Ctag">
            <summary>
OPTIONAL tag for values in m_C[]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_K">
            <summary>
OPTIONAL surface curvatures
Either m_K[] has zero count or it has the same
count as m_V[], in which case m_K[j] reports
the surface curvatures at m_V[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_TC">
            <summary>
RUNTIME ONLY
 This array is used to cache texture coordinates used by
 rendering applications that require 1d texture coordinates,
 3d texture coordinates, or multiple sets of texture 
 coordinates (e.g. blended textures with different mappings).
 Users are responsible for verifying
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_T">
            <summary>
OPTIONAL texture coordinates for each vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_Ttag">
            <summary>
OPTIONAL tag for values in m_T[]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_FN">
            <summary>
OPTIONAL face unit normals
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_N">
            <summary>
OPTIONAL vertex unit normals
Either m_N[] has zero count or it has the same
count as m_V[], in which case m_N[j] reports
the unit normal at m_V[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_F">
            <summary>
facets (triangle or quad)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMesh.m_V">
            <summary>
vertex locations
In a case where adjacent facets share a vertex
location but have distinct normals or texture
coordinates at that location, the vertex must
be duplicated.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureCoordinates.m_T">
            <summary>
texture coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureCoordinates.m_dim">
            <summary>
1, 2, or 3
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureCoordinates.m_T">
            <summary>
texture coordinates
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureCoordinates.m_dim">
            <summary>
1, 2, or 3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingTag.IsDefaultSurfaceParameterMapping">
            <returns>
True if the mapping tag is for a mapping with type ON_TextureMapping::srfp_mapping
with m_uvw = identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingTag.IsSet">
            <returns>True if the mapping tag is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingTag.SetDefaultSurfaceParameterMappingTag">
            <summary>Sets the tag to the value the meshes have that come out of ON_Brep::CreateMesh().</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingTag.m_mapping_crc">
            <summary>
ON_TextureMapping::MappingCRC()
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingTag.m_mapping_id">
            <summary>
ON_TextureMapping::m_mapping_id
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMappingTag">
            <summary>
Identifies the mapping used to create the texture 
coordinates and records transformations applied 
to the mesh after the texture coordinates were
calculated.  If the texture mapping does not
change when the mesh is transformed, then set 
m_mesh_xform to zero so that compares will work right.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingTag.IsDefaultSurfaceParameterMapping">
            <returns>
True if the mapping tag is for a mapping with type ON_TextureMapping::srfp_mapping
with m_uvw = identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingTag.IsSet">
            <returns>True if the mapping tag is set.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingTag.m_mapping_crc">
            <summary>
ON_TextureMapping::MappingCRC()
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingTag.m_mapping_id">
            <summary>
ON_TextureMapping::m_mapping_id
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMappingTag">
            <summary>
Identifies the mapping used to create the texture 
coordinates and records transformations applied 
to the mesh after the texture coordinates were
calculated.  If the texture mapping does not
change when the mesh is transformed, then set 
m_mesh_xform to zero so that compares will work right.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPartition.m_part">
            <summary>
Partition i uses vertices m_V[j] where 
  m_part[i].vi[0] &lt;= j &lt; m_part[i].vi[1] 
and uses faces m_F[k] where
  m_part[i].fi[0] &lt;= k &lt; m_part[i].fi[1]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPartition.m_partition_max_triangle_count">
            <summary>
maximum number of triangles in a partition (quads count as 2 triangles)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPartition.m_partition_max_vertex_count">
            <summary>
maximum number of vertices in a partition
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPartition.m_part">
            <summary>
Partition i uses vertices m_V[j] where 
  m_part[i].vi[0] &lt;= j &lt; m_part[i].vi[1] 
and uses faces m_F[k] where
  m_part[i].fi[0] &lt;= k &lt; m_part[i].fi[1]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPartition.m_partition_max_triangle_count">
            <summary>
maximum number of triangles in a partition (quads count as 2 triangles)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPartition.m_partition_max_vertex_count">
            <summary>
maximum number of vertices in a partition
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopFaceIsHidden(System.Int32)">
            <summary>Returns true if the topological face is hidden.</summary>
            <param name="topfi">[in] mesh topology face index.</param>
            <returns>True if mesh topology face is hidden.</returns>
            <remarks>The mesh topology face is hidden if and only if any of its mesh topology edges are hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdgeIsHidden(System.Int32)">
            <summary>Returns true if the topological edge is hidden.</summary>
            <param name="topei">[in] mesh topology edge index.</param>
            <returns>True if mesh topology edge is hidden.</returns>
            <remarks>The mesh topology edge is hidden if and only if either of its mesh topology vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopVertexIsHidden(System.Int32)">
            <summary>Returns true if the topological vertex is hidden.</summary>
            <param name="topvi">[in] mesh topology vertex index.</param>
            <returns>True if mesh topology vertex is hidden.</returns>
            <remarks>
The mesh topology vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.SortVertexEdges">
            <summary>
Sort the m_topei[] list of every mesh topology vertex so that the edges
are in radial order. The "const" is a white lie to make this
function easier to call.
</summary>
            <remarks>
Same as for ( int topvi = 0; topvi &lt; m_topv.Count(); topvi++ ) SortVertexEdges(topvi);
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.SortVertexEdges(System.Int32)">
            <summary>
Sort the m_topei[] list of a mesh topology vertex so that the edges are
in radial order. The "const" is a white lie to make this function
easier to call.
</summary>
            <param name="topvi">[in] index of vertex in m_topv[] array.</param>
            <remarks>
A nonmanifold edge is treated as a boundary edge with respect to sorting.
If any boundary or nonmanifold edges end at the vertex, then the first edge
will be a boundary or nonmanifold edge.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.GetTopFaceVertices(System.Int32,System.Int32[])">
            <summary>
returns ON_MeshTopology vertex topology index of a face
corner.  The face is triangle iv TopFaceVertex(2) = TopFaceVertex(3)
</summary>
            <param name="arg1">ON_MeshTopology face topology index (= ON_Mesh face index)</param>
            <param name="arg2">ON_MeshTopology vertex indices returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdge(System.Int32,System.Int32)">
            <summary>
returns index of edge that connects topological vertices
returns -1 if no edge is found.
arg1 and arg2 are ON_MeshTopology vertex topology indices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdgeLine(System.Int32)">
            <summary>Get the 3d line along an edge.</summary>
            <param name="tope_index">[in]</param>
            <returns>Line along edge. If input is not valid, the line.from and to are ON_UNSET_POINT</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopVertexPoint(System.Int32)">
            <summary>Get the 3d point location of a vertex.</summary>
            <param name="topv_index">[in]</param>
            <returns>Location of vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face.</returns>
            <remarks>
The OM_Mesh.m_F[] and ON_MeshTopology.m_topf[] arrays are parallel arrays;
corresponding faces have identical indices.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference.</summary>
            <param name="ci">[in] component index with type meshtop_edge.</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopFaceCount">
            <summary>number of topoligical faces (same as m_mesh.FaceCount())</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopEdgeCount">
            <summary>number of topoligical edges</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.TopVertexCount">
            <summary>number of topoligical vertices (&lt;= m_mesh.VertexCount())</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopology.#ctor">
            <summary>
double ON_SurfaceCurvature::NormalCurvature(const ON_3dVector&amp; tangent) const
{
double c = tangent*e1;
double s = tangent*e2;
return k1*c*c + k2*s*s;
}
double ON_SurfaceCurvature::NormalSectionCurvature( const ON_3dVector&amp; section_normal, const ON_3dVector&amp; surface_normal ) const
{
ON_3dVector tangent = ON_CrossProduct( section_normal, surface_normal );
if ( fabs(tangent.x) &lt;= ON_SQRT_EPSILON &amp;&amp; fabs(tangent.y) &lt;= ON_SQRT_EPSILON &amp;&amp; fabs(tangent.z) &lt;= ON_SQRT_EPSILON )
  tangent.Zero();
else
  tangent.Unitize();
return NormalCurvature(tangent);
}
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_topf">
            <summary>
Array of topological mesh faces.  The topological face
m_topf[fi] corresponds to the mesh face ON_Mesh.m_F[fi].
See the comments in the definition of ON_MeshTopologyFace
for details. To get the indices of the mesh topology 
vertices at the face corners use 
topvi = m_topv_map[m_mesh.m_F[fi].vi[n]]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_tope">
            <summary>
Array of topological mesh edges.  See the comments in the definition
of ON_MeshTopologyEdge for details.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_topv">
            <summary>
Array of topological mesh vertices.  See the comments in the definition
of ON_MeshTopologyVertex for details.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_topv_map">
            <summary>
m_topv_map[] has length m_mesh.VertexCount() and 
m_topv[m_topv_map[vi]] is the topological mesh vertex that is assocated
the with the mesh vertex m_mesh.m_V[vi].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopology.m_mesh">
            <summary>The parent ON_Mesh geometry used to compute this mesh topology.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMeshTopology">
            <summary>
A mesh topology class is always associated with an ON_Mesh
and can be retrieved by calling ON_Mesh::Topology()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopFaceIsHidden(System.Int32)">
            <summary>Returns true if the topological face is hidden.</summary>
            <param name="topfi">[in] mesh topology face index.</param>
            <returns>True if mesh topology face is hidden.</returns>
            <remarks>The mesh topology face is hidden if and only if any of its mesh topology edges are hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdgeIsHidden(System.Int32)">
            <summary>Returns true if the topological edge is hidden.</summary>
            <param name="topei">[in] mesh topology edge index.</param>
            <returns>True if mesh topology edge is hidden.</returns>
            <remarks>The mesh topology edge is hidden if and only if either of its mesh topology vertices is hidden.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopVertexIsHidden(System.Int32)">
            <summary>Returns true if the topological vertex is hidden.</summary>
            <param name="topvi">[in] mesh topology vertex index.</param>
            <returns>True if mesh topology vertex is hidden.</returns>
            <remarks>
The mesh topology vertex is hidden if and only if all the ON_Mesh vertices it represents is hidden.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.SortVertexEdges">
            <summary>
Sort the m_topei[] list of every mesh topology vertex so that the edges
are in radial order. The "const" is a white lie to make this
function easier to call.
</summary>
            <remarks>
Same as for ( int topvi = 0; topvi &lt; m_topv.Count(); topvi++ ) SortVertexEdges(topvi);
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.SortVertexEdges(System.Int32)">
            <summary>
Sort the m_topei[] list of a mesh topology vertex so that the edges are
in radial order. The "const" is a white lie to make this function
easier to call.
</summary>
            <param name="topvi">[in] index of vertex in m_topv[] array.</param>
            <remarks>
A nonmanifold edge is treated as a boundary edge with respect to sorting.
If any boundary or nonmanifold edges end at the vertex, then the first edge
will be a boundary or nonmanifold edge.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.GetTopFaceVertices(System.Int32,System.Int32[])">
            <summary>
returns ON_MeshTopology vertex topology index of a face
corner.  The face is triangle iv TopFaceVertex(2) = TopFaceVertex(3)
</summary>
            <param name="arg1">ON_MeshTopology face topology index (= ON_Mesh face index)</param>
            <param name="arg2">ON_MeshTopology vertex indices returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdge(System.Int32,System.Int32)">
            <summary>
returns index of edge that connects topological vertices
returns -1 if no edge is found.
arg1 and arg2 are ON_MeshTopology vertex topology indices
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdgeLine(System.Int32)">
            <summary>Get the 3d line along an edge.</summary>
            <param name="tope_index">[in]</param>
            <returns>Line along edge. If input is not valid, the line.from and to are ON_UNSET_POINT</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopVertexPoint(System.Int32)">
            <summary>Get the 3d point location of a vertex.</summary>
            <param name="topv_index">[in]</param>
            <returns>Location of vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.FaceRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a face reference from a mesh face index.</summary>
            <param name="ci">[in] component index with type mesh_face.</param>
            <returns>a reference to the face.</returns>
            <remarks>
The OM_Mesh.m_F[] and ON_MeshTopology.m_topf[] arrays are parallel arrays;
corresponding faces have identical indices.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.EdgeRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get an edge reference.</summary>
            <param name="ci">[in] component index with type meshtop_edge.</param>
            <returns>a reference to the edge</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.VertexRef(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a vertex reference to a mesh vertex index.</summary>
            <param name="ci">[in] component index with type mesh_vertex or meshtop_vertex.</param>
            <returns>a reference to the vertex</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopFaceCount">
            <summary>number of topoligical faces (same as m_mesh.FaceCount())</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopEdgeCount">
            <summary>number of topoligical edges</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopology.TopVertexCount">
            <summary>number of topoligical vertices (&lt;= m_mesh.VertexCount())</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_topf">
            <summary>
Array of topological mesh faces.  The topological face
m_topf[fi] corresponds to the mesh face ON_Mesh.m_F[fi].
See the comments in the definition of ON_MeshTopologyFace
for details. To get the indices of the mesh topology 
vertices at the face corners use 
topvi = m_topv_map[m_mesh.m_F[fi].vi[n]]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_tope">
            <summary>
Array of topological mesh edges.  See the comments in the definition
of ON_MeshTopologyEdge for details.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_topv">
            <summary>
Array of topological mesh vertices.  See the comments in the definition
of ON_MeshTopologyVertex for details.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_topv_map">
            <summary>
m_topv_map[] has length m_mesh.VertexCount() and 
m_topv[m_topv_map[vi]] is the topological mesh vertex that is assocated
the with the mesh vertex m_mesh.m_V[vi].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopology.m_mesh">
            <summary>The parent ON_Mesh geometry used to compute this mesh topology.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMeshTopology">
            <summary>
A mesh topology class is always associated with an ON_Mesh
and can be retrieved by calling ON_Mesh::Topology()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshFace.IsValid(System.Int32)">
            <param name="arg1">number of vertices in mesh</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshFace.vi(System.Int32)">
            <summary>
vertex index - vi[2]==vi[3] for tirangles
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshFace.IsValid(System.Int32)">
            <param name="arg1">number of vertices in mesh</param>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshFace.vi(System.Int32)">
            <summary>
vertex index - vi[2]==vi[3] for tirangles
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_adev">
            <summary>
average deviation of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_average">
            <summary>
average of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_mode">
            <summary>
mode of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_count">
            <summary>
count of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_count_infinite">
            <summary>
number of "infinte" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshCurvatureStats.m_infinity">
            <summary>
curvature values &gt;= this are considered infinite
and not used to compute the m_average or m_adev
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_adev">
            <summary>
average deviation of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_average">
            <summary>
average of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_mode">
            <summary>
mode of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_count">
            <summary>
count of "finite" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_count_infinite">
            <summary>
number of "infinte" values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshCurvatureStats.m_infinity">
            <summary>
curvature values &gt;= this are considered infinite
and not used to compute the m_average or m_adev
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.Compare(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
Compare() ignores weld and curvature settings
Ignores m_min_tolerance setting.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.DefaultAnalysisMeshParameters">
            <summary>
Sets the meshing parameters to create the default analysis mesh.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.SmoothAndSlowerMeshParameters">
            <summary>
Sets the meshing parameters to create "smooth and slower" render meshes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.JaggedAndFasterMeshParameters">
            <summary>
Sets the meshing parameters to create "jagged and faster" render meshes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.Set(System.Double)">
            <summary>Tool for provding a simple slider interface.</summary>
            <param name="density">
[in] 0.0 &lt;= density &lt;= 1.0
0 quickly creates coarse meshes.
1 creates accurate meshes but takes lots of time.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.Set(System.Double,System.Double)">
            <summary>Tool for provding a simple slider interface.</summary>
            <param name="density">
[in] 0.0 &lt;= density &lt;= 1.0
0 quickly creates coarse meshes.
1 creates accurate meshes but takes lots of time.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshParameters.op_Equality(RMA.OpenNURBS.OnMeshParameters,RMA.OpenNURBS.IOnMesh)">
            <summary>
compares with mesh's mesh parameters
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_face_type">
            <summary>
0 = mixed triangle and quads
1 = all triangles
2 = all quads
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_refine_angle">
            <summary>
(in radians) maximum angle in radians between
surface normal evaluated at adjacent vertices.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_amplification">
            <summary>
If you want fewer quads, set m_grid_amplification
to a value &lt; 1.  If you want more quads,
set m_grid_amplification to a value &gt; 1.
default = 1 and values &lt;= 0 are treated as 1.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_angle">
            <summary>
(in radians) maximum angle between surface normal
evaluated at adjacent vertices. 0.0 is treated as pi.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_max_count">
            <summary>
desired masimum number of quads in initial grid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_min_count">
            <summary>
minimum number of quads in initial grid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_grid_aspect_ratio">
            <summary>
desired aspect ratio of quads in grid
0.0 = any aspect ratio is acceptable
values &gt;0 and &lt; sqrt(2) are treated as sqrt(2)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_max_edge_length">
            <summary>
edges longer than m_max_edge_length will be split even when
they meet all other meshing requirements
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_min_edge_length">
            <summary>
edges shorter than m_min_edge_length will not be split even
if the do not meet other meshing requirements
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_min_tolerance">
            <summary>
then the maximum distance from the center of an edge to the surface will
be &lt;= T, where T is the larger of (m_min_tolerance,d*m_relative_tolerance), 
where d is an esimate of the size of the object being meshed.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_relative_tolerance">
            <summary>
If 0 &lt; m_relative_tolerance &lt; 1,
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_tolerance">
            <summary>
maximum distance from center of edge to surface
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_texture_range">
            <summary>
1: normalized
  each face has a normalized texture range [0,1]x[0,1].
2: packed normalized (default)
  each face in a polysurface is assigned a texture range that is a subrectangle 
  of [0,1]x[0,1].  The subrectangles are mutually disjoint and packed into
  [0,1]x[0,1] in a way that minimizes distortion and maximizes the coverage
  of [0,1]x[0,1].  (This texture style is suitable for creating texture maps 
  with popular 3D painting programs.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bJaggedSeams">
            <summary>
FALSE - (default) edges of meshes of joined b-rep faces match with no gaps or
       "T" joints.
TRUE  - faces in b-reps are meshed independently. This is faster but results
       in gaps and "T" joints along seams between faces.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bRefine">
            <summary>
FALSE - skip stage 2
TRUE  - (default) do stage 2
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bSimplePlanes">
            <summary>
FALSE - (default) planar surfaces are meshed using the controls below.
TRUE  - planar surfaces are meshed using minimal number of triangles and
       aspect/edge controls are ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bComputeCurvature">
            <summary>
FALSE - (default) - ON_Mesh::m_K[] not computed
TRUE  - ON_Mesh::m_K[] computed
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshParameters.m_bCustomSettings">
            <summary>
FALSE - if these settings were used to create a mesh and the app settings don't match,
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMeshParameters">
            <summary>
surface meshing parameters
Meshing happens in two stages.  The first stage creates a
rectangular grid.  The second stage refines the grid until
the mesh meets all meshing requirements.  The third stage
combines coincident vertices if the resulting mesh is a composite.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshParameters.Compare(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>
Compare() ignores weld and curvature settings
Ignores m_min_tolerance setting.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_face_type">
            <summary>
0 = mixed triangle and quads
1 = all triangles
2 = all quads
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_refine_angle">
            <summary>
(in radians) maximum angle in radians between
surface normal evaluated at adjacent vertices.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_amplification">
            <summary>
If you want fewer quads, set m_grid_amplification
to a value &lt; 1.  If you want more quads,
set m_grid_amplification to a value &gt; 1.
default = 1 and values &lt;= 0 are treated as 1.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_angle">
            <summary>
(in radians) maximum angle between surface normal
evaluated at adjacent vertices. 0.0 is treated as pi.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_max_count">
            <summary>
desired masimum number of quads in initial grid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_min_count">
            <summary>
minimum number of quads in initial grid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_grid_aspect_ratio">
            <summary>
desired aspect ratio of quads in grid
0.0 = any aspect ratio is acceptable
values &gt;0 and &lt; sqrt(2) are treated as sqrt(2)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_max_edge_length">
            <summary>
edges longer than m_max_edge_length will be split even when
they meet all other meshing requirements
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_min_edge_length">
            <summary>
edges shorter than m_min_edge_length will not be split even
if the do not meet other meshing requirements
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_min_tolerance">
            <summary>
then the maximum distance from the center of an edge to the surface will
be &lt;= T, where T is the larger of (m_min_tolerance,d*m_relative_tolerance), 
where d is an esimate of the size of the object being meshed.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_relative_tolerance">
            <summary>
If 0 &lt; m_relative_tolerance &lt; 1,
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_tolerance">
            <summary>
maximum distance from center of edge to surface
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_texture_range">
            <summary>
1: normalized
  each face has a normalized texture range [0,1]x[0,1].
2: packed normalized (default)
  each face in a polysurface is assigned a texture range that is a subrectangle 
  of [0,1]x[0,1].  The subrectangles are mutually disjoint and packed into
  [0,1]x[0,1] in a way that minimizes distortion and maximizes the coverage
  of [0,1]x[0,1].  (This texture style is suitable for creating texture maps 
  with popular 3D painting programs.)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bJaggedSeams">
            <summary>
FALSE - (default) edges of meshes of joined b-rep faces match with no gaps or
       "T" joints.
TRUE  - faces in b-reps are meshed independently. This is faster but results
       in gaps and "T" joints along seams between faces.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bRefine">
            <summary>
FALSE - skip stage 2
TRUE  - (default) do stage 2
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bSimplePlanes">
            <summary>
FALSE - (default) planar surfaces are meshed using the controls below.
TRUE  - planar surfaces are meshed using minimal number of triangles and
       aspect/edge controls are ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bComputeCurvature">
            <summary>
FALSE - (default) - ON_Mesh::m_K[] not computed
TRUE  - ON_Mesh::m_K[] computed
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshParameters.m_bCustomSettings">
            <summary>
FALSE - if these settings were used to create a mesh and the app settings don't match,
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMeshParameters">
            <summary>
surface meshing parameters
Meshing happens in two stages.  The first stage creates a
rectangular grid.  The second stage refines the grid until
the mesh meets all meshing requirements.  The third stage
combines coincident vertices if the resulting mesh is a composite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.triangle_count">
            <summary>
tris + 2*quads &gt;= fi[1] - fi[0]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.vertex_count">
            <summary>
= vi[1] - vi[0];
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.fi(System.Int32)">
            <summary>
subinterval of mesh m_F[] array
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshPart.vi(System.Int32)">
            <summary>
subinterval of mesh m_V[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMeshPart">
            <summary>
Faces with indices fi[0] &lt;= i &lt; fi[1] only reference
vertices with indices vi[0] &lt;= j &lt;= vi[1].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.triangle_count">
            <summary>
tris + 2*quads &gt;= fi[1] - fi[0]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.vertex_count">
            <summary>
= vi[1] - vi[0];
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.fi(System.Int32)">
            <summary>
subinterval of mesh m_F[] array
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshPart.vi(System.Int32)">
            <summary>
subinterval of mesh m_V[] array
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMeshPart">
            <summary>
Faces with indices fi[0] &lt;= i &lt; fi[1] only reference
vertices with indices vi[0] &lt;= j &lt;= vi[1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopologyFace.IsValid">
            <summary>
A topological mesh face is valid if m_topei[0], m_topei[1],
and m_topei[2] are mutually distinct, and m_topei[3] is either
equal to m_topei[2] or mutually distinct from the first three
indices.
</summary>
            <returns>True if face is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopologyFace.IsQuad">
            <summary>
A topological mesh face is a valid quad if m_topei[0], m_topei[1],
m_topei[2], and m_topei[3] are distinct edges.
</summary>
            <returns>True if face is a quad.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMeshTopologyFace.IsTriangle">
            <summary>
A topological mesh face is a valid triangle if m_topei[0],
m_topei[1], m_topei[2] are distinct edges and m_topei[3]=m_topei[2].
</summary>
            <returns>True if face is a triangle.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyFace.m_reve(System.Int32)">
            <summary>
If m_reve[i] is 0, then the orientation of the edge matches the
orientation of the face. If m_reve[i] is 1, then the orientation
of the edge is opposite that of the face.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyFace.m_topei(System.Int32)">
            <summary>
m_topei[] = indices of the topological edges that bound the face.
If m_topei[2] = m_topei[3], then the face is a triangle, otherwise the face is a quad.
NOTE WELL:
The topological edge with index m_topei[k] ENDS at the vertex corresponding to ON_MeshFace.vi[k].
So, ...
If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2],
and the topological edge with index m_topei[3] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],

If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopologyFace.IsValid">
            <summary>
A topological mesh face is valid if m_topei[0], m_topei[1],
and m_topei[2] are mutually distinct, and m_topei[3] is either
equal to m_topei[2] or mutually distinct from the first three
indices.
</summary>
            <returns>True if face is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopologyFace.IsQuad">
            <summary>
A topological mesh face is a valid quad if m_topei[0], m_topei[1],
m_topei[2], and m_topei[3] are distinct edges.
</summary>
            <returns>True if face is a quad.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMeshTopologyFace.IsTriangle">
            <summary>
A topological mesh face is a valid triangle if m_topei[0],
m_topei[1], m_topei[2] are distinct edges and m_topei[3]=m_topei[2].
</summary>
            <returns>True if face is a triangle.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyFace.m_reve(System.Int32)">
            <summary>
If m_reve[i] is 0, then the orientation of the edge matches the
orientation of the face. If m_reve[i] is 1, then the orientation
of the edge is opposite that of the face.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyFace.m_topei(System.Int32)">
            <summary>
m_topei[] = indices of the topological edges that bound the face.
If m_topei[2] = m_topei[3], then the face is a triangle, otherwise the face is a quad.
NOTE WELL:
The topological edge with index m_topei[k] ENDS at the vertex corresponding to ON_MeshFace.vi[k].
So, ...
If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2],
and the topological edge with index m_topei[3] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],

If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),
the topological edge with index m_topei[0] STARTS at
ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],
the topological edge with index m_topei[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index m_topei[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyEdge.m_topfi">
            <summary>
indices of topological faces use this topological edge
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyEdge.m_topfi">
            <summary>
indices of topological face use this topological edge
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_vi">
            <summary>
indices of ON_Mesh vertices that correspond to this topological vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_v_count">
            <summary>
m_v_count = number of ON_Mesh vertices that correspond to 
this topological vertex.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_topei">
            <summary>
indices of topological edges that begin or end at this vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMeshTopologyVertex.m_tope_count">
            <summary>
m_tope_count = number of topological edges that begin or 
end at this topological vertex.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_vi">
            <summary>
indices of ON_Mesh vertices that correspond to this topological vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_v_count">
            <summary>
m_v_count = number of ON_Mesh vertices that correspond to 
this topological vertex.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_topei">
            <summary>
indices of topological edges that begin or end at this vertex
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMeshTopologyVertex.m_tope_count">
            <summary>
m_tope_count = number of topological edges that begin or 
end at this topological vertex.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ThisCurveParameter(System.Double)">
            <summary>
Parameters: real_curve_parameter - [in] m_real_curve parameter Returns: Corresponding parameter for "this" curve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.RealCurveParameter(System.Double)">
            <summary>
Parameters: t - [in] parameter for "this" curve Returns: Corresponding parameter in m_real_curve's domain.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ProxyCurveIsReversed">
            <summary>
Returns: True if "this" as a curve is reversed from the "real" curve geometry.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ProxyCurveDomain">
            <summary>
Returns: Sub interval of the "real" curve's domain that "this" uses. This interval is not necessarily the same as "this" curve's domain. Remarks: This function is poorly named. It does NOT get the proxy curve's domain. It does get the evaluation interval of the "real" curve for which "this" is a proxy.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.SetProxyCurveDomain(RMA.OpenNURBS.IOnInterval)">
            <summary>
Description: Sets portion of the "real" curve that this proxy represents. Does NOT change the domain of "this" curve. Parameters: proxy_curve_subdomain - [in] increasing sub interval of ProxyCurve()-&gt;Domain(). This interval defines the portion the curve geometry that "this" proxy uses. Remarks: This function is poorly named. It does NOT set the proxy curve's domain. It does set the interval of the "real" curve for which "this" is a proxy.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveProxy.ProxyCurve">
            <summary>
Returns: "Real" curve geometry that "this" is a proxy for.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ThisCurveParameter(System.Double)">
            <summary>
Parameters: real_curve_parameter - [in] m_real_curve parameter Returns: Corresponding parameter for "this" curve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.RealCurveParameter(System.Double)">
            <summary>
Parameters: t - [in] parameter for "this" curve Returns: Corresponding parameter in m_real_curve's domain.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ProxyCurveIsReversed">
            <summary>
Returns: True if "this" as a curve is reversed from the "real" curve geometry.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ProxyCurveDomain">
            <summary>
Returns: Sub interval of the "real" curve's domain that "this" uses. This interval is not necessarily the same as "this" curve's domain. Remarks: This function is poorly named. It does NOT get the proxy curve's domain. It does get the evaluation interval of the "real" curve for which "this" is a proxy.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurveProxy.ProxyCurve">
            <summary>
Returns: "Real" curve geometry that "this" is a proxy for.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.#ctor(System.Int32)">
            <param name="initial_capacity">initial point array capacity</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.PointIsHidden(System.Int32)">
            <summary>
Returns true if the point is hidden. This is a runtime setting that is not saved in 3dm files.
</summary>
            <param name="point_index">[in]</param>
            <returns>True if the point is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.SetHiddenPointFlag(System.Int32,System.Boolean)">
            <summary>
Returns: If the point cloud has some hidden points, then an array of length PointCount() is returned and the i-th element is true if the i-th vertex is hidden. If no ponts are hidden, NULL is returned.
</summary>
            <summary>Set the runtime hidden point flag.</summary>
            <param name="point_index">[in] point vertex index</param>
            <param name="bHidden">[in] true to hide vertex</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.DestroyHiddenPointArray">
            <summary>
Destroys the m_H[] array and sets m_hidden_count=0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HiddenPointCount">
            <summary>
Returns: Number of points that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HasPointColors">
            <summary>
Returns: True if m_C.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HasPointNormals">
            <summary>
Returns: True if m_N.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.HasPlane">
            <summary>
TRUE if set is height field above a plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.IsOrdered">
            <summary>
TRUE if set is ordered stream
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.SetOrdered(System.Boolean)">
            <summary>
TRUE if set is ordered stream
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.InvalidateBoundingBox">
            <summary>
call if you change values of points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only
points Q with |P-Q| &lt;= maximum_distance are tested.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.EmergencyDestroy">
            <summary>
Call when the memory pool used the point cloud's arrays is no longer in existence.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPointCloud.Point(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a point cloud point from an ON_COMPONENT_INDEX.</summary>
            <param name="ci">
[in] a component index with m_typ set to ON_COMPONENT_INDEX::pointcloud_point
and 0 &lt;= m_index and m_index &lt; m_P.Count().
</param>
            <returns>Point at [ci.m_index] or ON_UNSET_POINT if ci is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_flags">
            <summary>
bit 1 is set if ordered
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_hidden_count">
            <summary>
m_hidden_count = number of true values in the m_H[] array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_H">
            <summary>
Implementation - RUNTIME point visibility - not saved in 3dm files.
If m_H.Count() = m_P.Count(), then m_H[j] is true if the point m_P[j] 
is hidden.  Otherwise, all points are visible.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_C">
            <summary>
Implementation - OPTIONAL point color
Either m_C[] has zero count or it has the same count as m_P[], in which case m_P[j] reports
the color assigned to m_P[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPointCloud.m_N">
            <summary>
Implementation - OPTIONAL point normal
Either m_N[] has zero count or it has the same count as m_P[], in which case m_N[j] reports
the color assigned to m_P[j].
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnPointCloud">
            <summary>unordered set of points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.PointIsHidden(System.Int32)">
            <summary>
Returns: If the point cloud has some hidden points, then an array of length PointCount() is returned and the i-th element is true if the i-th vertex is hidden. If no ponts are hidden, NULL is returned.
</summary>
            <summary>
Returns true if the point is hidden. This is a runtime setting that is not saved in 3dm files.
</summary>
            <param name="point_index">[in]</param>
            <returns>True if the point is hidden.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HiddenPointCount">
            <summary>
Returns: Number of points that are hidden.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HasPointColors">
            <summary>
Returns: True if m_C.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HasPointNormals">
            <summary>
Returns: True if m_N.Count() == m_P.Count().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.HasPlane">
            <summary>
TRUE if set is height field above a plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.IsOrdered">
            <summary>
TRUE if set is ordered stream
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the point cloud that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only
points Q with |P-Q| &lt;= maximum_distance are tested.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPointCloud.Point(RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Get a point cloud point from an ON_COMPONENT_INDEX.</summary>
            <param name="ci">
[in] a component index with m_typ set to ON_COMPONENT_INDEX::pointcloud_point
and 0 &lt;= m_index and m_index &lt; m_P.Count().
</param>
            <returns>Point at [ci.m_index] or ON_UNSET_POINT if ci is not valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_flags">
            <summary>
bit 1 is set if ordered
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_hidden_count">
            <summary>
m_hidden_count = number of true values in the m_H[] array.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_H">
            <summary>
Implementation - RUNTIME point visibility - not saved in 3dm files.
If m_H.Count() = m_P.Count(), then m_H[j] is true if the point m_P[j] 
is hidden.  Otherwise, all points are visible.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_C">
            <summary>
Implementation - OPTIONAL point color
Either m_C[] has zero count or it has the same count as m_P[], in which case m_P[j] reports
the color assigned to m_P[j].
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPointCloud.m_N">
            <summary>
Implementation - OPTIONAL point normal
Either m_N[] has zero count or it has the same count as m_P[], in which case m_N[j] reports
the color assigned to m_P[j].
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPointCloud">
            <summary>unordered set of points</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnPoint">
            <summary>
NOTE:  ON_3dPoint is much more efficient than ON_Point.
      Use ON_Point when you need a polymorphic 3d point
      that is derived from ON_Geometry or ON_Object.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPoint">
            <summary>
NOTE:  ON_3dPoint is much more efficient than ON_Point.
      Use ON_Point when you need a polymorphic 3d point
      that is derived from ON_Geometry or ON_Object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.ShadowIntensity">
            <summary>
0.0 = does not cast any shadows
1.0 = casts black shadows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetShadowIntensity(System.Double)">
            <summary>
0.0 = does not cast any shadows
1.0 = casts black shadows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.GetSpotLightRadii(System.Double@,System.Double@)">
            <summary>The spotlight radii are useful for display UI.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.HotSpot">
            <summary>
The hot spot setting runs from 0.0 to 1.0 and is used to
provides a linear interface for controling the focus or 
concentration of a spotlight.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetHotSpot(System.Double)">
            <summary>
The hot spot setting runs from 0.0 to 1.0 and is used to
provides a linear interface for controling the focus or 
concentration of a spotlight.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SpotExponent">
            <summary>
The spot exponent varies from 0.0 to 128.0 and provides
an exponential interface for controling the focus or 
concentration of a spotlight (like the 
OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
and hot spot parameters are linked; changing one will
change the other.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetSpotExponent(System.Double)">
            <summary>
The spot exponent varies from 0.0 to 128.0 and provides
an exponential interface for controling the focus or 
concentration of a spotlight (like the 
OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
and hot spot parameters are linked; changing one will
change the other.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.SetSpotAngleDegrees(System.Double)">
            <summary>angle = 0 to 90 degrees</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Attenuation(System.Double)">
            <summary>
computes 1/(a[0] + d*a[1] + d^2*a[2]) where d = argument
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Intensity">
            <summary>
0.0 = 0%  1.0 = 100%
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.GetLightXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <summary>
A light's location and direction can be defined with respect to world,
camera, or view coordinates. GetLightXform gets the transformation from the
light's intrinsic coordinate system to the destination coordinate system 
specified by dest_cs.
</summary>
            <param name="vp">[in] viewport where light is being used</param>
            <param name="dest_cs">[in] destination coordinate system</param>
            <param name="xform">[out] transformation from the light's intrinsic coordinate system to cs.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.CoordinateSystem">
            <summary>
determined by style
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Enable">
            <summary>turn light on</summary>
            <returns>previous state</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Enable(System.Boolean)">
            <summary>turn light on/off</summary>
            <returns>previous state</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLight.Default">
            <summary>
make default light
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_shadow_intensity">
            <summary>
0.0 = no shadow casting, 1.0 = full shadow casting
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_attenuation">
            <summary>
each entry &gt;= 0.0
att = 1/(a[0] + d*a[1] + d^2*a[2])
where d = distance to light
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_hotspot">
            <summary>
0.0 to 1.0 (See SetHotSpot() for details)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_spot_exponent">
            <summary>
0.0 to 128.0
0.0 = uniform
128.0 = high focus
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_spot_angle">
            <summary>
0.0 to 90.0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_watts">
            <summary>
ignored if 0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_intensity">
            <summary>
0.0 = 0%, 1.0 = 100%
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_width">
            <summary>
only for rectangular lights
corners of rectangular lights are m_location, m_location+m_length,
m_location+m_width, m_location+m_width+m_length
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_length">
            <summary>
only for linear and rectangular lights
ends of linear lights are m_location and m_location+m_length
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_location">
            <summary>
ignored for "directional" and "ambient" lights
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_direction">
            <summary>
ignored for "point" and "ambient" lights
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_style">
            <summary>
style of light
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLight.m_bOn">
            <summary>
TRUE if light is on
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.ShadowIntensity">
            <summary>
0.0 = does not cast any shadows
1.0 = casts black shadows
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.GetSpotLightRadii(System.Double@,System.Double@)">
            <summary>The spotlight radii are useful for display UI.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.HotSpot">
            <summary>
The hot spot setting runs from 0.0 to 1.0 and is used to
provides a linear interface for controling the focus or 
concentration of a spotlight.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.SpotExponent">
            <summary>
The spot exponent varies from 0.0 to 128.0 and provides
an exponential interface for controling the focus or 
concentration of a spotlight (like the 
OpenGL GL_SPOT_EXPONENT parameter).  The spot exponent
and hot spot parameters are linked; changing one will
change the other.
A hot spot setting of 0.0 corresponds to a spot exponent of 128.
A hot spot setting of 1.0 corresponds to a spot exponent of 0.0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.Attenuation(System.Double)">
            <summary>
computes 1/(a[0] + d*a[1] + d^2*a[2]) where d = argument
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.Intensity">
            <summary>
0.0 = 0%  1.0 = 100%
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.GetLightXform(RMA.OpenNURBS.IOnViewport,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <summary>
A light's location and direction can be defined with respect to world,
camera, or view coordinates. GetLightXform gets the transformation from the
light's intrinsic coordinate system to the destination coordinate system 
specified by dest_cs.
</summary>
            <param name="vp">[in] viewport where light is being used</param>
            <param name="dest_cs">[in] destination coordinate system</param>
            <param name="xform">[out] transformation from the light's intrinsic coordinate system to cs.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLight.CoordinateSystem">
            <summary>
determined by style
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_shadow_intensity">
            <summary>
0.0 = no shadow casting, 1.0 = full shadow casting
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_attenuation">
            <summary>
each entry &gt;= 0.0
att = 1/(a[0] + d*a[1] + d^2*a[2])
where d = distance to light
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_hotspot">
            <summary>
0.0 to 1.0 (See SetHotSpot() for details)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_spot_exponent">
            <summary>
0.0 to 128.0
0.0 = uniform
128.0 = high focus
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_spot_angle">
            <summary>
0.0 to 90.0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_watts">
            <summary>
ignored if 0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_intensity">
            <summary>
0.0 = 0%, 1.0 = 100%
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_width">
            <summary>
only for rectangular lights
corners of rectangular lights are m_location, m_location+m_length,
m_location+m_width, m_location+m_width+m_length
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_length">
            <summary>
only for linear and rectangular lights
ends of linear lights are m_location and m_location+m_length
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_location">
            <summary>ignored for "directional" and "ambient" lights</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_direction">
            <summary>ignored for "point" and "ambient" lights</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_style">
            <summary>style of light</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLight.m_bOn">
            <summary>true if light is on</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.AscentRatio">
            <summary>
Returns the ratio of the height of a typical upper case letter to the height of a whole character cell.
</summary>
            <returns>ratio of Windows Font Height / m_HeightOfH</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.HeightOfLinefeed">
            <summary>
Height of a linefeed when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.HeightOfI">
            <summary>
Height of the 'I' character when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.LinefeedRatio">
            <summary>
Returns: The ratio (height of linefeed)/(height of I).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnFont.IsSymbolFontFaceName(System.String)">
            <summary>True if the font's character set should be SYMBOL_CHARSET</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_index">
            <summary>
font index in Rhino font table
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_linefeed_ratio">
            <summary>
defaults to static s_linefeed_ratio.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_italic">
            <summary>
Same as m_logfont.lfItalic
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_weight">
            <summary>
Same as m_logfont.lfWeight
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_font_name">
            <summary>
Name of this font in the Rhino UI
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_metrics_char">
            <summary>
ASCII code of character to used to get runtime "default" glyph
metrics. (Currently an "I").
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnFont.m_default_linefeed_ratio">
            <summary>Ratio of linefeed to character height (1.6)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.AscentRatio">
            <summary>
Returns the ratio of the height of a typical upper case letter to the height of a whole character cell.
</summary>
            <returns>ratio of Windows Font Height / m_HeightOfH</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.HeightOfLinefeed">
            <summary>
Height of a linefeed when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.HeightOfI">
            <summary>
Height of the 'I' character when the font is drawn with m_logfont.
lfHeight = ON_Font::normal_font_height.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnFont.LinefeedRatio">
            <summary>
Returns: The ratio (height of linefeed)/(height of I).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_index">
            <summary>
font index in Rhino font table
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_linefeed_ratio">
            <summary>
defaults to static s_linefeed_ratio.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_italic">
            <summary>
Same as m_logfont.lfItalic
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_weight">
            <summary>
Same as m_logfont.lfWeight
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnFont.m_font_name">
            <summary>
Name of this font in the Rhino UI
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.Segments">
            <summary>
Expert user function to get access to the segment array for rapid calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.Segment(System.Int32)">
            <summary>
Returns a copy of the segment at index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetSegment(System.Int32,System.Double,RMA.OpenNURBS.IOnLinetypeSegment.eSegType)">
            <summary>
Sets the length and type of the segment at index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetSegment(System.Int32,RMA.OpenNURBS.IOnLinetypeSegment)">
            <summary>
Sets the segment at index to match segment
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.RemoveSegment(System.Int32)">
            <summary>Removes a segment in the linetype.</summary>
            <param name="index">[in] Zero based index of the segment to remove.</param>
            <returns>True if the segment index was removed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.AppendSegment(RMA.OpenNURBS.IOnLinetypeSegment)">
            <summary>Adds a segment to the pattern</summary>
            <returns>Index of the added segment.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SegmentCount">
            <summary>
Returns the number of segments in the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.PatternLength">
            <summary>
Returns the total length of one repeat of the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetLinetypeIndex(System.Int32)">
            <summary>
Index of each linetype This index is used by geometry objects to reference a specific linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.SetLinetypeName(System.String)">
            <summary>
Unique name for each linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.Default">
            <summary>
Sets index = -1 and emptys name and segment list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLinetype.#ctor">
            <summary>
Sets index = -1.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLinetype.m_linetype_id">
            <summary>
Set by Rhino - unique id of this linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.Segments">
            <summary>
Expert user function to get access to the segment array for rapid calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.Segment(System.Int32)">
            <summary>
Returns a copy of the segment at index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.SegmentCount">
            <summary>
Returns the number of segments in the pattern
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLinetype.PatternLength">
            <summary>
Returns the total length of one repeat of the pattern
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLinetype.m_linetype_id">
            <summary>
Set by Rhino - unique id of this linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetPlotWeight(System.Double)">
            <summary>Set the weight of the plotting pen.</summary>
            <param name="plot_weight_mm">
[in] Set the thickness of the plotting pen in millimeters. Any value &lt;= 0.0 is treated as 0.0.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.PlotWeight">
            <summary>Get the weight of the plotting pen.</summary>
            <returns>
Thickness of the plotting pen in millimeters. A thickness of 0.0
indicates the "default" pen weight should be used.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetIgesLevel(System.Int32)">
            <summary>
IGES level for this layer
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetLayerIndex(System.Int32)">
            <summary>
index of this layer;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.RenderMaterialIndex">
            <summary>
Index of render material for objects on this layer that have
MaterialSource() == ON::material_from_layer.
A material index of -1 indicates no material has been assigned
and the material created by the default ON_Material constructor
should be used.
</summary>
            <returns>
index of layer's rendering material
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetRenderMaterialIndex(System.Int32)">
            <summary>
Index of render material for objects on this layer that have
MaterialSource() == ON::material_from_layer.
A material index of -1 indicates no material has been assigned
and the material created by the default ON_Material constructor
should be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsVisibleAndLocked">
            <returns>
Value of (IsVisible() &amp;&amp; !IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsVisibleAndNotLocked">
            <returns>
Value of (IsVisible() &amp;&amp; !IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetLocked(System.Boolean)">
            <summary>Controls layer locked</summary>
            <param name="bLocked">[in] True to lock layer False to unlock layer</param>
            <remarks>See Also: ON_Layer::IsLocked</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsLocked">
            <returns>
true if objects on layer are locked.
See Also: ON_Layer::SetLocked
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetVisible(System.Boolean)">
            <summary>Controls layer visibility</summary>
            <param name="bVisible">[in] true to make layer visible, false to make layer invisible</param>
            <remarks>See Also: ON_Layer::IsVisible</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.IsVisible">
            <returns>
true if objects on layer are visible.
See Also: ON_Layer::SetVisible
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetLinetypeIndex(System.Int32)">
            <summary>
layer linetype
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetPlotColor(RMA.OpenNURBS.IOnColor)">
            <summary>
plotting color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLayer.SetColor(RMA.OpenNURBS.IOnColor)">
            <summary>
layer display color
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_bExpanded">
            <summary>
If true, when the layer table is displayed in
a tree control then the list of child layers is
shown in the control.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_bLocked">
            <summary>
If true, objects on this layer cannot be modified.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_bVisible">
            <summary>
If true, objects on this layer are visible.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_plot_weight_mm">
            <summary>
thickness of plot pen in mm
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_plot_color">
            <summary>
plotting color
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_color">
            <summary>
layer color
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_linetype_index">
            <summary>
index of linetype
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_material_index">
            <summary>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of your rendering material 
 and ignore m_rendering_attributes.
 If you are developing a fancy plug-in renderer, and a user is
 assigning one of your fabulous rendering materials to this
 layer, then add rendering material information to the
Developers:
 As soon as m_rendering_attributes.m_materials[] is not empty,
 rendering material queries slow down.  Do not populate
 m_rendering_attributes.m_materials[] when setting 
 m_material_index will take care of your needs.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_iges_level">
            <summary>
IGES level number if this layer was made during IGES import
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_parent_layer_id">
            <summary>
Layers are origanized in a hierarchical structure (like file folders).
If a layer is in a parent layer, then m_parent_layer_id is the id of 
the parent layer.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLayer.m_layer_index">
            <summary>
index of this layer
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.PlotWeight">
            <summary>Get the weight of the plotting pen.</summary>
            <returns>
Thickness of the plotting pen in millimeters. A thickness of 0.0
indicates the "default" pen weight should be used.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.RenderMaterialIndex">
            <summary>
Index of render material for objects on this layer that have
MaterialSource() == ON::material_from_layer.
A material index of -1 indicates no material has been assigned
and the material created by the default ON_Material constructor
should be used.
</summary>
            <returns>
index of layer's rendering material
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsVisibleAndLocked">
            <returns>
Value of (IsVisible() &amp;&amp; IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsVisibleAndNotLocked">
            <returns>
Value of (IsVisible() &amp;&amp; !IsLocked()).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsLocked">
            <returns>
true if objects on layer are locked.
See Also: ON_Layer::SetLocked
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLayer.IsVisible">
            <returns>
true if objects on layer are visible.
See Also: ON_Layer::SetVisible
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_bExpanded">
            <summary>
If true, when the layer table is displayed in
a tree control then the list of child layers is
shown in the control.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_bLocked">
            <summary>
If true, objects on this layer cannot be modified.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_bVisible">
            <summary>
If true, objects on this layer are visible.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_plot_weight_mm">
            <summary>
thickness of plot pen in mm
 =0.0 means use the default width
 &lt;0.0 means don't plot (visible for screen display, but does not show on plot)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_plot_color">
            <summary>
plotting color
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_color">
            <summary>
layer color
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_linetype_index">
            <summary>
index of linetype
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_material_index">
            <summary>
Rendering material:
 If you want something simple and fast, set 
 m_material_index to the index of your rendering material 
 and ignore m_rendering_attributes.
 If you are developing a fancy plug-in renderer, and a user is
 assigning one of your fabulous rendering materials to this
 layer, then add rendering material information to the
Developers:
 As soon as m_rendering_attributes.m_materials[] is not empty,
 rendering material queries slow down.  Do not populate
 m_rendering_attributes.m_materials[] when setting 
 m_material_index will take care of your needs.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_iges_level">
            <summary>
IGES level number if this layer was made during IGES import
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_parent_layer_id">
            <summary>
Layers are origanized in a hierarchical structure (like file folders).
If a layer is in a parent layer, then m_parent_layer_id is the id of 
the parent layer.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLayer.m_layer_index">
            <summary>
index of this layer
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.DeleteTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>Deletes all texures with matching filenames and types.</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <returns>Number of textures deleted.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.AddTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>
If there is a texture with a matching type, that texture's filename
is modified, otherwise a new texture is added.
</summary>
            <param name="filename">[in] new filename</param>
            <param name="type">[in]</param>
            <returns>Index of the added texture in the m_textures[] array.</returns>
            <remarks>
This is intended to be a quick and simple way to add textures to the material.
If you need to do something different, then just work on the m_textures[] array.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.AddTexture(RMA.OpenNURBS.IOnTexture)">
            <summary>
If there is already a texture with the same file name and type,
then that texture is modified, otherwise a new texture is added.
If tx has user data, the user data is copied to the m_textures[] element.
</summary>
            <param name="tx">[in]</param>
            <returns>Index of the added texture in the m_textures[] array.</returns>
            <remarks>
This is intended to be a quick and simple way to add textures to the material.
If you need to do something different, then just work on the m_textures[] array.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE,System.Int32)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <param name="i0">
[in] If i0 is &lt; 0, the search begins at m_textures[0],
if i0 &gt;= m_textures.Count(), -1 is returnd,
otherwise, the search begins at m_textures[i0+1].
</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.FindTexture(System.Guid)">
            <summary>
Searches for a texure with matching texture_id. If more than one
texture matches, the first match is returned.
</summary>
            <param name="texture_id">[in]</param>
            <returns>
&gt;=0 m_textures[] index of matching texture 
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.SetTransparency(System.Double)">
            <summary>
0.0 = opaque, 1.0 = transparent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.Transparency">
            <summary>
Transparency values are in range 0.0 = opaque to 1.0 = transparent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.SetShine(System.Double)">
            <summary>
0 to ON_Material::MaxShine()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.Shine">
            <summary>
Shine values are in range 0.0 to ON_Material::MaxShine()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.Compare(RMA.OpenNURBS.IOnMaterial)">
            <summary>ignores m_material_index</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.op_Inequality(RMA.OpenNURBS.OnMaterial,RMA.OpenNURBS.IOnMaterial)">
            <summary>
ignores m_material_index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.op_Equality(RMA.OpenNURBS.OnMaterial,RMA.OpenNURBS.IOnMaterial)">
            <summary>
ignores m_material_index
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.#ctor">
            <summary>
Default grey color
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterial.MaxShine">
            <summary>
maximum value of shine exponent
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_plugin_id">
            <summary>
ID of the last plug-in to modify this material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_channel">
            <summary>
Used to provide per face material support. The parent object reference a basic material. 
When a brep face or mesh facet wants to use a material besides the base material, it
specifies a channelSupports material channel. The default material channel is 0 and that
indicates the base material. A channel of n &gt; 0 means that face used the material
with id m_material_channel[n-1]. If (n-1) &gt;= m_material_channel.Count(), then the base
material is used. The value of m_material_channel[n].m_id is persistent. The value of
m_material_channel[n].m_i is a runtime index in the CRhinoDoc::m_material_table[]. If
CRhinoDoc::m_material_table[m_i].m_uuid != m_id, then m_id is assumed to be correct.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.im_material_channel">
            <summary>
Used to provide per face material support. The parent object reference a basic material. 
When a brep face or mesh facet wants to use a material besides the base material, it
specifies a channelSupports material channel. The default material channel is 0 and that
indicates the base material. A channel of n &gt; 0 means that face used the material
with id m_material_channel[n-1]. If (n-1) &gt;= m_material_channel.Count(), then the base
material is used. The value of m_material_channel[n].m_id is persistent. The value of
m_material_channel[n].m_i is a runtime index in the CRhinoDoc::m_material_table[]. If
CRhinoDoc::m_material_table[m_i].m_uuid != m_id, then m_id is assumed to be correct.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_bShared">
            <summary>
True means this material can be shared. When an object that uses this material is copied,
the new object will share the material. False means this material is not shared.
When an object that uses this material is duplicated.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_transparency">
            <summary>
0.0 = opaque to 1.0 = transparent (1.0-alpha)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_shine">
            <summary>
0.0 = none to GetMaxShine()=maximum
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_reflectivity">
            <summary>
0.0 = none, 1.0 = 100%
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_index_of_refraction">
            <summary>
generally &gt;= 1.0 (speed of light in vacum)/(speed of light in material)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_name">
            <summary>
For user comfort - duplicates permitted
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_index">
            <summary>
Runtime material table index. This value is constant
for each runtim instance of Rhino, but can change
each time a model is loaded or saved.  Once a material
is in the CRhinoDoc material table, its id and index
never change in that instance of Rhino.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterial.m_material_id">
            <summary>
The only reliable and persistent way to reference 
materials is by the material_id.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.FindTexture(System.String,RMA.OpenNURBS.IOnTexture.TYPE,System.Int32)">
            <summary>
Searches for a texure with matching filename and type. If more than one
texture matches, the first match is returned.
</summary>
            <param name="filename">[in] If NULL, then any filename matches.</param>
            <param name="type">[in] If ON_Texture::no_texture_type, then any texture type matches.</param>
            <param name="i0">
[in] If i0 is &lt; 0, the search begins at m_textures[0],
if i0 &gt;= m_textures.Count(), -1 is returnd,
otherwise, the search begins at m_textures[i0+1].
</param>
            <example>
Iterate through all the the bitmap textures on a material.
ON_Material&amp; mat = ...;
int ti = -1;
int bitmap_texture_count = 0;
for(;;) {
 ti = mat.FindTexture( NULL, ON_Texture::bitmap_texture, ti );
 if ( ti &lt; 0 ) {
   // no more bitmap textures
   break;
 }
 // we have a bitmap texture
 bitmap_texture_count++;
 const ON_Texture&amp; bitmap_texture = mat.m_textures[ti];
 ...
}
</example>
            <returns>
&gt;=0 m_textures[] index of matching texture
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.FindTexture(System.Guid)">
            <summary>
Searches for a texure with matching texture_id. If more than one
texture matches, the first match is returned.
</summary>
            <param name="texture_id">[in]</param>
            <returns>
&gt;=0 m_textures[] index of matching texture 
-1 if no match is found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.Transparency">
            <summary>
Transparency values are in range 0.0 = opaque to 1.0 = transparent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.Shine">
            <summary>
Shine values are in range 0.0 to ON_Material::MaxShine()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMaterial.Compare(RMA.OpenNURBS.IOnMaterial)">
            <summary>ignores m_material_index</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_plugin_id">
            <summary>
ID of the last plug-in to modify this material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_channel">
            <summary>
Used to provide per face material support. The parent object reference a basic material. 
When a brep face or mesh facet wants to use a material besides the base material, it
specifies a channelSupports material channel. The default material channel is 0 and that
indicates the base material. A channel of n &gt; 0 means that face used the material
with id m_material_channel[n-1]. If (n-1) &gt;= m_material_channel.Count(), then the base
material is used. The value of m_material_channel[n].m_id is persistent. The value of
m_material_channel[n].m_i is a runtime index in the CRhinoDoc::m_material_table[]. If
CRhinoDoc::m_material_table[m_i].m_uuid != m_id, then m_id is assumed to be correct.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_bShared">
            <summary>
True means this material can be shared. When an object that uses this material is copied,
the new object will share the material. False means this material is not shared.
When an object that uses this material is duplicated.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_transparency">
            <summary>
0.0 = opaque to 1.0 = transparent (1.0-alpha)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_shine">
            <summary>
0.0 = none to GetMaxShine()=maximum
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_reflectivity">
            <summary>
0.0 = none, 1.0 = 100%
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_index_of_refraction">
            <summary>
generally &gt;= 1.0 (speed of light in vacum)/(speed of light in material)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_name">
            <summary>
For user comfort - duplicates permitted
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_index">
            <summary>
Runtime material table index. This value is constant
for each runtim instance of Rhino, but can change
each time a model is loaded or saved.  Once a material
is in the CRhinoDoc material table, its id and index
never change in that instance of Rhino.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterial.m_material_id">
            <summary>
The only reliable and persistent way to reference 
materials is by the material_id.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.IsTiled(System.Int32,System.Double@,System.Double@)">
            <summary>Examines the m_uvw matrix and harvests tiling constants.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <param name="count">[out] number of tiles</param>
            <param name="offset">[out] offset of the tile</param>
            <returns>True if if the m_uvw matrix had entries that were compatible with tiling.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.TileTextureCoordinate(System.Int32,System.Double,System.Double)">
            <summary>Tiles the specified texture coordinates.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <param name="count">[in] number of tiles (can be negative)</param>
            <param name="offset">[in] offset of the tile (can be any number)</param>
            <remarks>Modifes m_uvw so that the specified texture coordinate is tiled.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.SwapTextureCoordinate(System.Int32,System.Int32)">
            <summary>Swaps the specified texture coordinates.</summary>
            <param name="i">[in]</param>
            <param name="j">[in] (0 &lt;= i, j &lt;= 3 and i != j)</param>
            <remarks>Modifes m_uvw so that the specified texture coordinates are swapped.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTexture.ReverseTextureCoordinate(System.Int32)">
            <summary>Reverses the texture in the specified direction.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <remarks>Modifes m_uvw so that the spedified direction transforms the texture coordinate t to 1-t.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_runtime_ptr_id">
            <summary>
Applications use the m_runtime_ptr_id and m_runtime_ptr fields
to cached runtime bitmaps. If either the id or the pointer
are non-zero, then you cannot use them.  If you hang something
on the pointer, then set the id to something unique to
prevent others from messing with it.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_blend_order">
            <summary>
If an ON_Material m_textures[] array has more than
one texture, the textures are blended, and the textures
have different m_blend_order values, the the texture 
with the smaller m_blend_order is first.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_blend_constant_A">
            <summary>
If the m_mode is blend_texture, then m_blend_A[]
and m_blend_RGB[] determine the blending function.
new alpha  = m_blend_constant_A 
           + m_blend_A[0]*(current alpha)
           + m_blend_A[1]*(texture alpha)
           + m_blend_A[2]*min(current alpha,texture alpha)
           + m_blend_A[3]*max(current alpha,texture alpha)
new rgb    = m_blend_constant_RGB 
           + m_blend_RGB[0]*(current RGB)
           + m_blend_RGB[1]*(texture RGB)
           + m_blend_RGB[2]*min(current RGB,texture RGB)
           + m_blend_RGB[3]*max(current RGB,texture RGB)
Results are clamped to handle underflow or overflow.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_bump_scale">
            <summary>
If the m_type is bump_texture, the height of the
bump is m_bump_scale.ParameterAt(value), where
value is in the HSV sense and normalized 
(black=0, white=1).  The interval can be 
decreasing.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_transparency_texture_id">
            <summary>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If m_transparency_id is not nil, it is the id of another
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_transparent_color">
            <summary>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If ON_UNSET_COLOR != m_transparent_color, then 
a pixel in the bitmap file with a matching RGB
value is assigned the alpha value (ON_Color::Alpha)
in m_transparent_color. The intended use is 
for non-rectangular decals defined by RGB bitmaps in
files that don't save an alpha channel.
For example if the decal is a red number 7 with a 
white background, then you would set m_transparent_color's
RGB to white and its A to zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_border_color">
            <summary>
If ON_UNSET_COLOR != m_border_color, then this color
is used when the texture coordinates are &lt;=0 or &gt;=1
and the m_wrap* value is clamp_wrap.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_bApply_uvw">
            <summary>
true if m_uvw is active.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_magfilter">
            <summary>
The magfilter setting controls how the color
of the image pixel is calculated when the image pixel
corresponds to a fraction of a texture bitmap pixel.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_minfilter">
            <summary>
The value of m_minfilter determines how the color
of the image pixel is calculated when the image pixel
corresponds to multiple texture bitmap pixels.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_bOn">
            <summary>
If false, texture is off and should be ignored.
The intended use is to allow people to turn textures
on and off without have to create/destroy or change 
other texture settings.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_filename">
            <summary>
Bitmap filename  
 During runtime, m_filename is the absolute path to the
 file in use.  If m_filename_bRelativePath is true, then
 the value saved in the 3dm archive will be a relative path.
 When m_filename_bRelativePath is true, user interface
 should display a relative path.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTexture.m_mapping_channel_id">
            <summary>
If this value is on of the built-in mappings list
in the MAPPING_CHANNEL enum, then that mapping
is used.  Otherwise, if an object has rendering
attributes with an ON_MappingChannel entry that
has a matching m_mapping_channel_id value, then
the mapping identified by
ON_MappingChannel::m_mapping_id is used.
A value of zero means no mapping is supplied
and the texture coordinates on the mesh are
used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTexture.IsTiled(System.Int32,System.Double@,System.Double@)">
            <summary>Examines the m_uvw matrix and harvests tiling constants.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <param name="count">[out] number of tiles</param>
            <param name="offset">[out] offset of the tile</param>
            <returns>True if if the m_uvw matrix had entries that were compatible with tiling.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_runtime_ptr_id">
            <summary>
Applications use the m_runtime_ptr_id and m_runtime_ptr fields
to cached runtime bitmaps. If either the id or the pointer
are non-zero, then you cannot use them.  If you hang something
on the pointer, then set the id to something unique to
prevent others from messing with it.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_blend_order">
            <summary>
If an ON_Material m_textures[] array has more than
one texture, the textures are blended, and the textures
have different m_blend_order values, the the texture 
with the smaller m_blend_order is first.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_blend_constant_A">
            <summary>
If the m_mode is blend_texture, then m_blend_A[]
and m_blend_RGB[] determine the blending function.
new alpha  = m_blend_constant_A 
           + m_blend_A[0]*(current alpha)
           + m_blend_A[1]*(texture alpha)
           + m_blend_A[2]*min(current alpha,texture alpha)
           + m_blend_A[3]*max(current alpha,texture alpha)
new rgb    = m_blend_constant_RGB 
           + m_blend_RGB[0]*(current RGB)
           + m_blend_RGB[1]*(texture RGB)
           + m_blend_RGB[2]*min(current RGB,texture RGB)
           + m_blend_RGB[3]*max(current RGB,texture RGB)
Results are clamped to handle underflow or overflow.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_bump_scale">
            <summary>
If the m_type is bump_texture, the height of the
bump is m_bump_scale.ParameterAt(value), where
value is in the HSV sense and normalized 
(black=0, white=1).  The interval can be 
decreasing.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_transparency_texture_id">
            <summary>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If m_transparency_id is not nil, it is the id of another
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_transparent_color">
            <summary>
This field is used for textures with type
bitmap_texture that reference bitmap files that do
not have an alpha channel and is used to set
runtime alpha values.  It needs to be parsed when the
texture is loaded and can be ignored at runtime.
If ON_UNSET_COLOR != m_transparent_color, then 
a pixel in the bitmap file with a matching RGB
value is assigned the alpha value (ON_Color::Alpha)
in m_transparent_color. The intended use is 
for non-rectangular decals defined by RGB bitmaps in
files that don't save an alpha channel.
For example if the decal is a red number 7 with a 
white background, then you would set m_transparent_color's
RGB to white and its A to zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_border_color">
            <summary>
If ON_UNSET_COLOR != m_border_color, then this color
is used when the texture coordinates are &lt;=0 or &gt;=1
and the m_wrap* value is clamp_wrap.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_bApply_uvw">
            <summary>
true if m_uvw is active.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_magfilter">
            <summary>
The magfilter setting controls how the color
of the image pixel is calculated when the image pixel
corresponds to a fraction of a texture bitmap pixel.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_minfilter">
            <summary>
The value of m_minfilter determines how the color
of the image pixel is calculated when the image pixel
corresponds to multiple texture bitmap pixels.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_bOn">
            <summary>
If false, texture is off and should be ignored.
The intended use is to allow people to turn textures
on and off without have to create/destroy or change 
other texture settings.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_filename">
            <summary>
Bitmap filename  
 During runtime, m_filename is the absolute path to the
 file in use.  If m_filename_bRelativePath is true, then
 the value saved in the 3dm archive will be a relative path.
 When m_filename_bRelativePath is true, user interface
 should display a relative path.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTexture.m_mapping_channel_id">
            <summary>
If this value is on of the built-in mappings list
in the MAPPING_CHANNEL enum, then that mapping
is used.  Otherwise, if an object has rendering
attributes with an ON_MappingChannel entry that
has a matching m_mapping_channel_id value, then
the mapping identified by
ON_MappingChannel::m_mapping_id is used.
A value of zero means no mapping is supplied
and the texture coordinates on the mesh are
used.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTexture.MODE">
            <summary>
m_mode determines how the texture is
do not change MODE enum values - they are saved in 3dm files.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTexture.TYPE">
            <summary>
do not change TYPE enum values - they are saved in 3dm files.
The "TYPE" setting controls how the pixels in the bitmap
are interpreted.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTexture.MAPPING_CHANNEL">
            <summary>list of pre-defined channel ids</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateBoxMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateCylinderMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluateSphereMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.EvaluatePlaneMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnXform)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <param name="P_xform">[in] Transformation to be applied to P before performing the mapping calculation.</param>
            <param name="N_xform">
[in] Transformation to be applied to N before performing the mapping calculation.
One way to calculate N_xform is to use the call P_xform::GetVectorTransform(N_xform).
</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.TileTextureCoordinate(System.Int32,System.Double,System.Double)">
            <summary>Tiles the specified texture coordinates.</summary>
            <param name="dir">[in] 0 = "u", 1 = "v", 2 = "w".</param>
            <param name="count">[in] number of tiles</param>
            <param name="offset">[in] offset of the tile</param>
            <remarks>Modies m_uvw so that the specified texture coordinate is tiled.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SwapTextureCoordinate(System.Int32,System.Int32)">
            <summary>Swaps the specified texture coordinates.</summary>
            <param name="i">[in]</param>
            <param name="j">[in]</param>
            <remarks>Modifies m_uvw so that the specified texture coordinates are swapped.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.ReverseTextureCoordinate(System.Int32)">
            <summary>Reverses the texture in the specified direction.</summary>
            <param name="dir">[in] 0 = reverse "u", 1 = reverse "v", 2 = reverse "w".</param>
            <remarks>Modies m_uvw so that the spedified direction transforms the texture coordinate t to 1-t.</remarks>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingBox(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get a box projection from the texture mapping.</summary>
            <param name="plane">
[out] The center of the box is at plane.origin and the sides of the box
are parallel to the plane's coordinate planes.
</param>
            <param name="dx">
[out] The "front" and "back" sides of the box are in spanned by the
vectors plane.yaxis and plane.zaxis. The back plane contains the point plane.PointAt(dx[0],0,0)
and the front plane contains the point plane.PointAt(dx[1],0,0).
</param>
            <param name="dy">
[out] The "left" and "right" sides of the box are in spanned by the
vectors plane.zaxis and plane.xaxis. The left plane contains the point plane.PointAt(0,dx[0],0)
and the back plane contains the point plane.PointAt(0,dy[1],0).
</param>
            <param name="dz">
[out] The "top" and "bottom" sides of the box are in spanned by the
vectors plane.xaxis and plane.yaxis. The bottom plane contains the point plane.PointAt(0,0,dz[0])
and the top plane contains the point plane.PointAt(0,0,dz[1]).
</param>
            <returns>True if a valid box is returned.</returns>
            <remarks>
Generally, GetMappingBox will not return the same parameters passed to SetBoxMapping.
However, the location of the box will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingSphere(RMA.OpenNURBS.OnSphere@)">
            <summary>Get a spherical projection parameters from this texture mapping.</summary>
            <param name="sphere">[out]</param>
            <returns>True if a valid sphere is returned.</returns>
            <remarks>
Generally, GetMappingShere will not return the same parameters passed to SetSphereMapping.
However, the location of the sphere will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingCylinder(RMA.OpenNURBS.OnCylinder@)">
            <summary>Get a cylindrical projection parameters from this texture mapping.</summary>
            <param name="cylinder">[out]</param>
            <returns>True if a valid cylinder is returned.</returns>
            <remarks>
Generally, GetMappingCylinder will not return the same parameters passed to SetCylinderMapping.
However, the location of the cylinder will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.GetMappingPlane(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get plane mapping parameters from this texture mapping.</summary>
            <param name="plane">[out]</param>
            <param name="dx">[out] Portion of the plane's x axis that is mapped to [0,1]</param>
            <param name="dy">[out] Portion of the plane's y axis that is mapped to [0,1]</param>
            <param name="dz">[out] Portion of the plane's z axis that is mapped to [0,1]</param>
            <returns>True if valid plane mapping parameters were returned.</returns>
            <remarks>
NOTE WELL:
Generally, GetMappingPlane will not return the same parameters passed to SetPlaneMapping.
However, the location of the plane will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetBoxMapping(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Create a box projection texture mapping.</summary>
            <param name="plane">
[in] The sides of the box the box are parallel to the plane's coordinate planes.
The dx, dy, dz intervals determine the location of the sides.
</param>
            <param name="dx">
[in] Determines the location of the front and back planes. The vector plane.xaxis is
perpindicular to these planes and they pass through plane.PointAt(dx[0],0,0) and
plane.PointAt(dx[1],0,0), respectivly.
</param>
            <param name="dy">
[in] Determines the location of the left and right planes. The vector plane.yaxis is
perpindicular to these planes and they pass through plane.PointAt(0,dy[0],0) and
plane.PointAt(0,dy[1],0), respectivly.
</param>
            <param name="dz">
[in] Determines the location of the top and bottom planes. The vector plane.zaxis is
perpindicular to these planes and they pass through plane.PointAt(0,0,dz[0]) and
plane.PointAt(0,0,dz[1]), respectivly.
</param>
            <param name="bIsCapped">[in] If true, the box is treated as a finite capped box.</param>
            <returns>True if input is valid.</returns>
            <remarks>
When m_texture_space = divided, the box is mapped to texture space as follows:

If the box is not capped, then each side maps to 1/4 of the texture map.
 v=1+---------+---------+---------+---------+
    | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] |
    | Front   | Right   | Back    | Left    |
    | --y-&gt; | &lt;-x-- | &lt;-y-- | --x-&gt; |
 v=0+---------+---------+---------+---------+
   0/4 &lt;=u&lt;= 1/4 &lt;=u&lt;= 2/4 &lt;=u&lt;= 3/4 &lt;=u&lt;= 4/4

If the box is capped, then each side and cap gets 1/6 of the texture map.
 v=1+---------+---------+---------+---------+---------+---------+
    | x=dx[1] | y=dy[1] | x=dx[0] | y=dy[0] | z=dx[1] | z=dz[0] |
    | Front   | Right   | Back    | Left    | Top     | Bottom  |
    | --y-&gt; | &lt;-x-- | &lt;-y-- | --x-&gt; | --x-&gt; | --x-&gt; |
 v=0+---------+---------+---------+---------+---------+---------+
   0/6 &lt;=u&lt;= 1/6 &lt;=u&lt;= 2/6 &lt;=u&lt;= 3/6 &lt;=u&lt;= 4/6 &lt;=u&lt;= 5/6 &lt;=u&lt;= 6/6
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetSphereMapping(RMA.OpenNURBS.IOnSphere)">
            <summary>Create a spherical projection texture mapping.</summary>
            <param name="sphere">
[in] sphere in world space used to define a spherical coordinate system.
The longitude parameter maps (0,2pi) to texture "u" (0,1).
The latitude paramter maps (-pi/2,+pi/2) to texture "v" (0,1).
The radial parameter maps (0,r) to texture "w" (0,1).
</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetCylinderMapping(RMA.OpenNURBS.IOnCylinder,System.Boolean)">
            <summary>Create a cylindrical projection texture mapping.</summary>
            <param name="cylinder">
[in] cylinder in world space used to define a cylindrical coordinate system. The
angular parameter maps (0,2pi) to texture "u" (0,1), The height parameter
maps (height[0],height[1]) to texture "v" (0,1), and the radial parameter
maps (0,r) to texture "w" (0,1).
</param>
            <param name="bIsCapped">[in] If true, the cylinder is treated as a finite capped cylinder.</param>
            <returns>True if input is valid.</returns>
            <remarks>
When the cylinder is capped and m_texture_space = divided,
the cylinder is mapped to texture space as follows:
 The side is mapped to 0 &lt;= "u" &lt;= 2/3.
 The bottom is mapped to 2/3 &lt;= "u" &lt;= 5/6.
 The top is mapped to 5/6 &lt;= "u" &lt;= 5/6.
This is the same convention box mapping uses.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetPlaneMapping(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Create a planar projection texture mapping.</summary>
            <param name="plane">[in]</param>
            <param name="dx">[in] portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)</param>
            <param name="dy">[in] portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)</param>
            <param name="dz">[in] portion of the plane's x axis that is mapped to [0,1] (can be a decreasing interval)</param>
            <example>
Create a mapping that maps the world axis aligned rectangle in the world yz plane
with corners at (0,3,5) and (0,7,19) to the texture coordinate unit square.
 ON_3dVector plane_xaxis(0.0,1.0,0.0);
 ON_3dVector plane_yaxis(0.0,0,0,1.0);
 ON_3dPoint plane_origin(0.0,2.0,4.0);
 ON_Plane plane(plane_origin,plane_xaxis,plane_yaxis);
 ON_Interval dx( 0.0, 7.0 - 3.0);
 ON_Interval dy( 0.0, 19.0 - 5.0);
 ON_Interval dz( 0.0, 1.0 );
 ON_TextureMapping mapping;
 mapping.CreatePlaneMapping(plane,dx,dy,dz);
</example>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.SetSurfaceParameterMapping">
            <summary>Create a mapping that will convert surface parameters into normalized (0,1)x(0,1) texture coordinates.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextureMapping.RequiresVertexNormals">
            <summary>
Determines whether the mapping, as currently set up, requires vertex normals to be
present on the mesh in order to evaluate the mapping correctly.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_uvw">
            <summary>
Transform applied to mapping coordinate (u,v,w) to 
convert it into a texture coordinate.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_Nxyz">
            <summary>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_Pxyz">
            <summary>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_bCapped">
            <summary>
The m_bCapped applies to cylinder and box mappings.  If
m_bCapped is false, the cylinder or box is "infinite".
If m_bCapped is true, they are finite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_mapping_name">
            <summary>
The texture mapping name is for UI and user comfort. 
Duplicates are permitted.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_mapping_index">
            <summary>
Runtime texture mapping table index. 
This value is NOT SAVED IN 3DM FILES.
This value is constant for each runtime instance of Rhino,
but can change each time a model is loaded or saved.  
Once a texture mapping is in the CRhinoDoc material table,
its id and index never change in that instance of Rhino.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTextureMapping.m_mapping_id">
            <summary>
The only reliable and persistent way to reference texture 
mappings is by the mapping_id.  If the mapping id is
set to m_srfp_mapping_id, then all other mapping settings
are ignored.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn2fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.ArrayOn3fPoint@,RMA.OpenNURBS.IOnXform,System.Boolean,RMA.OpenNURBS.Arrayint)">
            <summary>
Get texture coordinates. This calculation is expensive. When possible,
use a MappingMatch() query to avoid unnecessary calculations.
</summary>
            <param name="mesh">[in]</param>
            <param name="T">[out] Texture coordinates returned here.</param>
            <param name="mesh_xform">
[in] (optional) If the mesh has been transformed since the texture mapping was set up,
pass the transformation here. Typically this is the value of ON_Mesh::m_mapping_xform
or ON_MappingRef::m_object_xform
</param>
            <param name="bLazy">
[in] If true and the mesh.m_T[] values were calculated using this mapping,
they are simply copied to the T[] array and no calculations are performed.
If you are calling the 3d point version and you care about the z-coordinate,
then do not use the lazy option (meshes only store 2d texture coordinates).
</param>
            <param name="Tside">
[out] In the case of divided textures, side information is returned here if
a lazy mapping is not done. Otherwise Tside-&gt;Count() will be zero.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMappingTag,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="tag">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.HasMatchingTextureCoordinates(RMA.OpenNURBS.IOnMesh,RMA.OpenNURBS.IOnXform)">
            <summary>Quickly check to see if a mesh or tag has texture coordinates set by this mapping.</summary>
            <param name="mesh">[in]</param>
            <param name="object_xform">
[in] (optional) If this transform is not NULL, then true will be returned only if the
mapping function is the same and the tag's m_mesh_xform field is the same as mesh_xform.
This parameter is typically NULL or the value of ON_MappingRef::m_object_xform.
</param>
            <returns>True if the meshes texture coordinates were set by this mapping.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateBoxMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateCylinderMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluateSphereMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.EvaluatePlaneMapping(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOnXform,RMA.OpenNURBS.IOnXform)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <param name="P_xform">[in] Transformation to be applied to P before performing the mapping calculation.</param>
            <param name="N_xform">
[in] Transformation to be applied to N before performing the mapping calculation.
One way to calculate N_xform is to use the call P_xform::GetVectorTransform(N_xform).
</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.Evaluate(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.On3dPoint)">
            <summary>Evaluate the mapping to get a texture coordinate.</summary>
            <param name="P">[in] Vertex location</param>
            <param name="N">[in] If the mapping projection is ray_projection, then this is the vertex unit normal. Otherwise N is ignored.</param>
            <param name="T">[out] Texture coordinate (u,v,w)</param>
            <returns>
Nonzero if evaluation is successful. When the mapping is a box or capped cylinder mapping,
the value indicates which side was evaluated.
 Cylinder mapping:
   1 = cylinder wall, 2 = bottom cap, 3 = top cap
 Box mapping:
   1 = front 2 = right 3 = back 4 = left 5 = bottom 6 = top
See Also: ON_TextureMapping::GetTextureCoordinates ON_Mesh::SetTextureCoordinates
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingBox(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get a box projection from the texture mapping.</summary>
            <param name="plane">
[out] The center of the box is at plane.origin and the sides of the box
are parallel to the plane's coordinate planes.
</param>
            <param name="dx">
[out] The "front" and "back" sides of the box are in spanned by the
vectors plane.yaxis and plane.zaxis. The back plane contains the point plane.PointAt(dx[0],0,0)
and the front plane contains the point plane.PointAt(dx[1],0,0).
</param>
            <param name="dy">
[out] The "left" and "right" sides of the box are in spanned by the
vectors plane.zaxis and plane.xaxis. The left plane contains the point plane.PointAt(0,dx[0],0)
and the back plane contains the point plane.PointAt(0,dy[1],0).
</param>
            <param name="dz">
[out] The "top" and "bottom" sides of the box are in spanned by the
vectors plane.xaxis and plane.yaxis. The bottom plane contains the point plane.PointAt(0,0,dz[0])
and the top plane contains the point plane.PointAt(0,0,dz[1]).
</param>
            <returns>True if a valid box is returned.</returns>
            <remarks>
Generally, GetMappingBox will not return the same parameters passed to SetBoxMapping.
However, the location of the box will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingSphere(RMA.OpenNURBS.OnSphere@)">
            <summary>Get a spherical projection parameters from this texture mapping.</summary>
            <param name="sphere">[out]</param>
            <returns>True if a valid sphere is returned.</returns>
            <remarks>
Generally, GetMappingShere will not return the same parameters passed to SetSphereMapping.
However, the location of the sphere will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingCylinder(RMA.OpenNURBS.OnCylinder@)">
            <summary>Get a cylindrical projection parameters from this texture mapping.</summary>
            <param name="cylinder">[out]</param>
            <returns>True if a valid cylinder is returned.</returns>
            <remarks>
Generally, GetMappingCylinder will not return the same parameters passed to SetCylinderMapping.
However, the location of the cylinder will be the same. If this mapping is not cylindrical,
the cylinder will approximate the actual mapping primitive.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.GetMappingPlane(RMA.OpenNURBS.OnPlane@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@,RMA.OpenNURBS.OnInterval@)">
            <summary>Get plane mapping parameters from this texture mapping.</summary>
            <param name="plane">[out]</param>
            <param name="dx">[out] Portion of the plane's x axis that is mapped to [0,1]</param>
            <param name="dy">[out] Portion of the plane's y axis that is mapped to [0,1]</param>
            <param name="dz">[out] Portion of the plane's z axis that is mapped to [0,1]</param>
            <returns>True if valid plane mapping parameters were returned.</returns>
            <remarks>
NOTE WELL:
Generally, GetMappingPlane will not return the same parameters passed to SetPlaneMapping.
However, the location of the plane will be the same.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextureMapping.RequiresVertexNormals">
            <summary>
Determines whether the mapping, as currently set up, requires vertex normals to be present on the mesh in order to evaluate the mapping correctly.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_uvw">
            <summary>
Transform applied to mapping coordinate (u,v,w) to 
convert it into a texture coordinate.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_Nxyz">
            <summary>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_Pxyz">
            <summary>
For primitive based mappings, these transformations are
used to map the world coordinate (x,y,z) point P and 
surface normal N before it is projected to the normalized 
mapping primitive. The surface normal transformation,
m_Nxyz, is always calculated from m_Pxyz.  It is a 
runtime setting that is not saved in 3dm files. 
If m_type is srfp_mapping, then m_Pxyz and m_Nxyz are
ignored.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_bCapped">
            <summary>
The m_bCapped applies to cylinder and box mappings.  If
m_bCapped is false, the cylinder or box is "infinite".
If m_bCapped is true, they are finite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_mapping_name">
            <summary>
The texture mapping name is for UI and user comfort. 
Duplicates are permitted.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_mapping_index">
            <summary>
Runtime texture mapping table index. 
This value is NOT SAVED IN 3DM FILES.
This value is constant for each runtime instance of Rhino,
but can change each time a model is loaded or saved.  
Once a texture mapping is in the CRhinoDoc material table,
its id and index never change in that instance of Rhino.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTextureMapping.m_mapping_id">
            <summary>
The only reliable and persistent way to reference texture 
mappings is by the mapping_id.  If the mapping id is
set to m_srfp_mapping_id, then all other mapping settings
are ignored.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextureMapping.TEXTURE_SPACE">
            <summary>
When a mapping primitive is a box or a capped cylinder,
there are two options for the mapping.  Either the sides
all map to (0,1)x(0,1) (so the either texture map appears 
on each side, or the sides map to distinct regions of the
texture space.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextureMapping.PROJECTION">
            <summary>
When a mapping primitive, like a plane, sphere, box,
or cylinder, is used, there are two projection options.

clspt_projection: world xyz maps to the point on the 
                 mapping primitive that is closest to xyz.
                 In this case, ON_TextureMapping::Evaluate
                 ignores the vector argument.

ray_projection:   world xyz + world vector defines a world line.
                 The world line is intersected with the mapping 
                 primitive and the intersection point that is
                 closest to the world xyz point is used to
                 calculate the mapping parameters.

The value of m_projection can be changed as needed.

If m_type = srfp_mapping, then m_projection is ignored.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTextureMapping.TYPE">
            <summary>
Mapping types:
 You can either calculate texture coordinates based on
 the parameterization of the surface used to create a mesh,
 or project the natural parameterization from a mapping
 primitive, like a plane, sphere, box, or cylinder.

Do not change TYPE enum values - they are saved in 3dm files.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ChangeViewportId(System.Guid@)">
            <summary>
EXPERT USER function to change the viewport's id.
If you change the id, you risk damaging display and visibility
relationships in the model.
</summary>
            <param name="viewport_id">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetViewportId(System.Guid@)">
            <summary>
Sets the viewport's id to the value used to uniquely identify this viewport.
</summary>
            <param name="viewport_id">[in]</param>
            <returns>
True if the viewport's id was successfully set and false
otherwise (ie. the viewport uuid has already been set).
</returns>
            <remarks>
There is no approved way to change the viewport id once it is set in
order to maintain consistency across multiple viewports and those
routines that manage them.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.PerspectiveMinNearDist">
            <summary>
Expert user function to get the minimum value of near when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetPerspectiveMinNearDist(System.Double)">
            <summary>
Expert user function to control the minimum value of near when
perspective projections are begin used.
</summary>
            <param name="min_near_dist">[in]</param>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.PerspectiveMinNearOverFar">
            <summary>
Expert user function to get the minimum runtime value of near/far
when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near/far when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetPerspectiveMinNearOverFar(System.Double)">
            <summary>
Expert user function to control the minimum ratio of near/far
when perspective projections are begin used.
</summary>
            <param name="min_near_over_far">[in]</param>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ClipModXformIsIdentity">
            <summary>
Returns: True if clip mod xform is identity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ClipModInverseXform">
            <summary>Gets the m_clip_mod_inverse transformation</summary>
            <returns>value of the m_clip_mod_inverse transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ClipModXform">
            <summary>Gets the m_clip_mod transformation</summary>
            <returns>value of the m_clip_mod transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetViewScale(System.Double,System.Double)">
            <summary>
Apply scaling factors to parallel projection clipping coordinates by
setting the m_clip_mod transformation.
</summary>
            <param name="x">[in] x &gt; 0</param>
            <param name="y">[in] y &gt; 0</param>
            <example>
If you want to compress the view projection across the viewing plane,
then set x = 0.5, y = 1.0, and z = 1.0.
</example>
            <returns>
True if successful.
False if input is invalid or the view is a perspective view.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.DollyFrustum(System.Double)">
            <summary>Moves frustum's clipping planes</summary>
            <param name="dolly_distance">distance to move in camera direction</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetDollyCameraVector(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>Gets a world coordinate dolly vector that can be passed to DollyCamera().</summary>
            <param name="screen_x0">(x,y) screen coords of start point</param>
            <param name="screen_y0">(x,y) screen coords of start point</param>
            <param name="screen_x1">(x,y) screen coords of end point</param>
            <param name="screen_y1">(x,y) screen coords of end point</param>
            <param name="proj_plane_dist">
distance of projection plane from camera.
When in doubt, use 0.5*(frus_near+frus_far).
</param>
            <param name="dolly_vector">world coordinate dolly vector returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.DollyCamera(RMA.OpenNURBS.IOn3dVector)">
            <summary>
DollyCamera() does not update the frustum's clipping planes.
To update the frustum's clipping planes call DollyFrustum(d)
with d = dollyVector o cameraFrameZ.  To convert screen locations
into a dolly vector, use GetDollyCameraVector().
</summary>
            <param name="dolly_vector">dolly vector in world coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.ZoomToScreenRect(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
View changing from screen input points.  Handy for
using a mouse to manipulate a view.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.Extents(System.Double,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Use Extents() as a quick way to set a viewport to so that bounding
volume is inside of a viewports frusmtrum.
The view angle is used to determine the position of the camera.
</summary>
            <param name="half_view_angle">
1/2 smallest subtended view angle
(0 &lt; angle &lt; pi/2)
</param>
            <param name="center">3d world coordinate bounding sphere center</param>
            <param name="radius">3d sphere radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.Extents(System.Double,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Use Extents() as a quick way to set a viewport to so that bounding
volume is inside of a viewports frusmtrum.
The view angle is used to determine the position of the camera.
</summary>
            <param name="half_view_angle">
1/2 smallest subtended view angle
(0 &lt; angle &lt; pi/2)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetWorldToScreenScale(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>display tools</summary>
            <param name="point_in_frustum">[in]  point in viewing frustum.</param>
            <param name="pixels_per_unit">[out] scale = number of pixels per world unit at the 3d point</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumLine(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Line@)">
            <summary>
Get the world coordinate line in the view frustum that projects to a point on the screen.
</summary>
            <param name="screenx">[in] (screenx,screeny) = screen location</param>
            <param name="screeny">[in] (screenx,screeny) = screen location</param>
            <param name="world_line">
[out] 3d world coordinate line segment starting on the near clipping plane
and ending on the far clipping plane.
</param>
            <returns>true if successful. false if view projection or frustum is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumLine(System.Double,System.Double,RMA.OpenNURBS.OnLine@)">
            <summary>
Get the world coordinate line in the view frustum that projects to a point on the screen.
</summary>
            <param name="screenx">[in] (screenx,screeny) = screen location</param>
            <param name="screeny">[in] (screenx,screeny) = screen location</param>
            <param name="world_line">
[out] 3d world coordinate line segment starting on the near clipping plane
and ending on the far clipping plane.
</param>
            <returns>true if successful. false if view projection or frustum is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetXform(RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <param name="matrix">4x4 transformation matrix (acts on the left)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCamera35mmLenseLength(System.Double)">
            <summary>
These functions assume the camera is horizontal and crop the
film rather than the image when the aspect of the frustum
is not 36/24.  (35mm film is 36mm wide and 24mm high.)
The SetCamera35mmLenseLength() preserves camera location,
changes the frustum, but maintains the frsutrum's aspect.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCamera35mmLenseLength(System.Double@)">
            <summary>
These functions assume the camera is horizontal and crop the
film rather than the image when the aspect of the frustum
is not 36/24.  (35mm film is 36mm wide and 24mm high.)
The SetCamera35mmLenseLength() preserves camera location,
changes the frustum, but maintains the frsutrum's aspect.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraAngle(System.Double)">
            <param name="half_smallest_angle">
1/2 of smallest subtended view angle
0 &lt; angle &lt; pi/2
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraAngle(System.Double@)">
            <param name="half_smallest_angle">1/2 of smallest subtended view angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraAngle(System.Double@,System.Double@,System.Double@)">
            <param name="half_diagonal_angle">1/2 of diagonal subtended angle</param>
            <param name="half_vertical_angle">1/2 of vertical subtended angle</param>
            <param name="half_horizontal_angle">1/2 of horizontal subtended angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetScreenPortAspect(System.Double@)">
            <summary>
port's |width/height|
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetScreenPort(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Location of viewport in pixels. These are provided so you can set the port you
are using and get the appropriate transformations to and from screen space.
</summary>
            <param name="port_left">[in]</param>
            <param name="port_right">[in] (port_left != port_right)</param>
            <param name="port_bottom">[in]</param>
            <param name="port_top">[in] (port_top != port_bottom)</param>
            <example>
For a Windows window
int width = width of window client area in pixels;
int height = height of window client area in pixels;
port_left = 0;
port_right = width;
port_top = 0;
port_bottom = height; 
port_near = 0;
port_far = 1;
SetScreenPort( port_left, port_right, port_bottom, port_top, port_near, port_far );
</example>
            <returns>
true if input is valid.
See Also: ON_Viewport::GetScreenPort
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetScreenPort(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Location of viewport in pixels. These are provided so you can set the port you
are using and get the appropriate transformations to and from screen space.
</summary>
            <param name="port_left">[in]</param>
            <param name="port_right">[in] (port_left != port_right)</param>
            <param name="port_bottom">[in]</param>
            <param name="port_top">[in] (port_top != port_bottom)</param>
            <param name="port_near">[in]</param>
            <example>
For a Windows window
int width = width of window client area in pixels;
int height = height of window client area in pixels;
port_left = 0;
port_right = width;
port_top = 0;
port_bottom = height; 
port_near = 0;
port_far = 1;
SetScreenPort( port_left, port_right, port_bottom, port_top, port_near, port_far );
</example>
            <returns>
true if input is valid.
See Also: ON_Viewport::GetScreenPort
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetScreenPort(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
Location of viewport in pixels. These are provided so you can set the port you
are using and get the appropriate transformations to and from screen space.
</summary>
            <param name="port_left">[in]</param>
            <param name="port_right">[in] (port_left != port_right)</param>
            <param name="port_bottom">[in]</param>
            <param name="port_top">[in] (port_top != port_bottom)</param>
            <param name="port_near">[in]</param>
            <param name="port_far">[in]</param>
            <example>
For a Windows window
int width = width of window client area in pixels;
int height = height of window client area in pixels;
port_left = 0;
port_right = width;
port_top = 0;
port_bottom = height; 
port_near = 0;
port_far = 1;
SetScreenPort( port_left, port_right, port_bottom, port_top, port_near, port_far );
</example>
            <returns>
true if input is valid.
See Also: ON_Viewport::GetScreenPort
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFarRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of far clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetNearRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of near clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumTopPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get top world frustum clipping plane.</summary>
            <param name="top_plane">
[out] frustum top side clipping plane. The normal points into the visible region
of the frustum. If the projection is perspective, the origin is at the camera location,
otherwise the origin isthe point on the plane that is closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumBottomPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get bottom world frustum clipping plane.</summary>
            <param name="bottom_plane">
[out] frustum bottom side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumRightPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get right world frustum clipping plane.</summary>
            <param name="right_plane">
[out] frustum right side clipping plane. The normal points out of the visible 
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumLeftPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get left world frustum clipping plane.</summary>
            <param name="left_plane">
[out] frustum left side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at
the camera location, otherwise the origin isthe point on the plane that is
closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFarPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get far clipping plane.</summary>
            <param name="far_plane">
[out] far clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the far clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetNearPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get near clipping plane.</summary>
            <param name="near_plane">
[out] near clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the near clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumNearFar(System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Set near and far clipping distance subject to constraints.</summary>
            <param name="near_dist">[in] (&gt;0) desired near clipping distance</param>
            <param name="far_dist">[in] (&gt;near_dist) desired near clipping distance</param>
            <param name="min_near_dist">
[in] If min_near_dist &lt;= 0.0, it is ignored.
If min_near_dist &gt; 0 and near_dist &lt; min_near_dist, then the frustum's near_dist
will be increased to min_near_dist.
</param>
            <param name="min_near_over_far">
[in] If min_near_over_far &lt;= 0.0, it is ignored.
If near_dist &lt; far_dist*min_near_over_far, then near_dist is increased and/or far_dist
is decreased so that near_dist = far_dist*min_near_over_far.
If near_dist &lt; target_dist &lt; far_dist, then near_dist near_dist is increased and
far_dist is decreased so that projection precision will be good at target_dist.
Otherwise, near_dist is simply set to far_dist*min_near_over_far.
</param>
            <param name="target_dist">
[in] If target_dist &lt;= 0.0, it is ignored.
If target_dist &gt; 0, it is used as described in the description of the min_near_over_far parameter.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumNearFar(System.Double,System.Double)">
            <param name="near_dist">&gt;0</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumNearFar(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <param name="center">3d bounding sphere center</param>
            <param name="radius">3d bounding sphere radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.FrustumLeft">
            <summary>
The near clipping plane stored in the Rhino 1.0 file is frequently very
small and useless for high quality z-buffer based rendering.  The far
clipping value is not stored in the file.  Use these functions to set
the frustum's near and far clipping planes to appropriate values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumCenter(RMA.OpenNURBS.On3dPoint@)">
            <summary>
Returns world coordinates of frustum's center
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetFrustumAspect(System.Double@)">
            <summary>
Returns frustum's width/height
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustumAspect(System.Double)">
            <summary>
SetFrustumAspect() changes the larger of the frustum's widht/height
so that the resulting value of width/height matches the requested
aspect.  The camera angle is not changed.  If you change the shape
of the view port with a call SetScreenPort(), then you generally 
want to call SetFrustumAspect() with the value returned by 
GetScreenPortAspect().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetFrustum(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
Rhino version 1.0 does not support skew frustums; i.e., the
viewing frustums used in Rhino have left = -right, bottom = -top.
If you specify a skew frustum, all the ON_Viewport functions
will work fine.  If you save it a file and read the file into Rhino 1.0,
then you will get a symmetric approximation.
</summary>
            <param name="right">left &lt; right</param>
            <param name="top">bottom &lt; top</param>
            <param name="far_dist">( 0 &lt; near_dist &lt; far_dist )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.IsCameraFrameWorldPlan(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
Returns true if the camera direction = some world axis.
The indices report which axes are used.  For a "twisted"
plan view it is possible to have zero x and y indices.
This function returns true if and only if the "z" index
is non-zero.

Indices are +/-1 = world +/-x, +/-2 = world +/-y, +/-3 = world +/-z,
</summary>
            <param name="arg1">if true and plan is axis aligned, view x index, else 0</param>
            <param name="arg2">if true and plan is axis aligned, view y index, else 0</param>
            <param name="arg3">if true, view z index, else 0</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.CameraZ">
            <summary>
unit vector in -CameraDirection
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.CameraY">
            <summary>
unit up vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.CameraX">
            <summary>
unit to right vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.GetCameraFrame(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns TRUE if current camera orientation is valid</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraUp(RMA.OpenNURBS.IOn3dVector)">
            <summary>
These return TRUE if the current direction and up are not zero and not
parallel so the camera position is well defined.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraDirection(RMA.OpenNURBS.IOn3dVector)">
            <summary>
These return TRUE if the current direction and up are not zero and not
parallel so the camera position is well defined.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.SetCameraLocation(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
These return TRUE if the current direction and up are not zero and not
parallel so the camera position is well defined.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.Initialize">
            <summary>
Interface /////////////////////////////////////////////////////////////////
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnViewport.#ctor">
            <summary>
Construction
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnViewport">
            <summary>This object represents a viewing frustum</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.PerspectiveMinNearDist">
            <summary>
Expert user function to get the minimum value of near when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.PerspectiveMinNearOverFar">
            <summary>
Expert user function to get the minimum runtime value of near/far
when perspective projections are begin used.
</summary>
            <returns>The minimum permitted value of near/far when perspective projections are begin used.</returns>
            <remarks>This is a runtime setting and is not saved in 3dm files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.ClipModXformIsIdentity">
            <summary>
Returns: True if clip mod xform is identity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.ClipModInverseXform">
            <summary>Gets the m_clip_mod_inverse transformation</summary>
            <returns>value of the m_clip_mod_inverse transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.ClipModXform">
            <summary>Gets the m_clip_mod transformation</summary>
            <returns>value of the m_clip_mod transformation.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetDollyCameraVector(System.Int32,System.Int32,System.Int32,System.Int32,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>Gets a world coordinate dolly vector that can be passed to DollyCamera().</summary>
            <param name="screen_x0">(x,y) screen coords of start point</param>
            <param name="screen_y0">(x,y) screen coords of start point</param>
            <param name="screen_x1">(x,y) screen coords of end point</param>
            <param name="screen_y1">(x,y) screen coords of end point</param>
            <param name="proj_plane_dist">
distance of projection plane from camera.
When in doubt, use 0.5*(frus_near+frus_far).
</param>
            <param name="dolly_vector">world coordinate dolly vector returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetWorldToScreenScale(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>display tools</summary>
            <param name="point_in_frustum">[in]  point in viewing frustum.</param>
            <param name="pixels_per_unit">[out] scale = number of pixels per world unit at the 3d point</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumLine(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Line@)">
            <summary>
Get the world coordinate line in the view frustum that projects to a point on the screen.
</summary>
            <param name="screenx">[in] (screenx,screeny) = screen location</param>
            <param name="screeny">[in] (screenx,screeny) = screen location</param>
            <param name="world_line">
[out] 3d world coordinate line segment starting on the near clipping plane
and ending on the far clipping plane.
</param>
            <returns>true if successful. false if view projection or frustum is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumLine(System.Double,System.Double,RMA.OpenNURBS.OnLine@)">
            <summary>
Get the world coordinate line in the view frustum that projects to a point on the screen.
</summary>
            <param name="screenx">[in] (screenx,screeny) = screen location</param>
            <param name="screeny">[in] (screenx,screeny) = screen location</param>
            <param name="world_line">
[out] 3d world coordinate line segment starting on the near clipping plane
and ending on the far clipping plane.
</param>
            <returns>true if successful. false if view projection or frustum is invalid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetXform(RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.IOn.coordinate_system,RMA.OpenNURBS.OnXform@)">
            <param name="matrix">4x4 transformation matrix (acts on the left)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCamera35mmLenseLength(System.Double@)">
            <summary>
These functions assume the camera is horizontal and crop the
film rather than the image when the aspect of the frustum
is not 36/24.  (35mm film is 36mm wide and 24mm high.)
The SetCamera35mmLenseLength() preserves camera location,
changes the frustum, but maintains the frsutrum's aspect.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraAngle(System.Double@)">
            <param name="half_smallest_angle"> 1/2 of smallest subtended view angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraAngle(System.Double@,System.Double@,System.Double@)">
            <param name="half_diagonal_angle">1/2 of diagonal subtended angle</param>
            <param name="half_vertical_angle">1/2 of vertical subtended angle</param>
            <param name="half_horizontal_angle">1/2 of horizontal subtended angle</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetScreenPortAspect(System.Double@)">
            <summary>
port's |width/height|
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFarRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of far clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetNearRect(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get corners of near clipping plane rectangle.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumTopPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get top world frustum clipping plane.</summary>
            <param name="top_plane">
[out] frustum top side clipping plane. The normal points into the visible region
of the frustum. If the projection is perspective, the origin is at the camera location,
otherwise the origin isthe point on the plane that is closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumBottomPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get bottom world frustum clipping plane.</summary>
            <param name="bottom_plane">
[out] frustum bottom side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumRightPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get right world frustum clipping plane.</summary>
            <param name="right_plane">
[out] frustum right side clipping plane. The normal points out of the visible 
region of the frustum. If the projection is perspective, the origin is at the
camera location, otherwise the origin isthe point on the plane that is closest
to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumLeftPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get left world frustum clipping plane.</summary>
            <param name="left_plane">
[out] frustum left side clipping plane. The normal points into the visible
region of the frustum. If the projection is perspective, the origin is at
the camera location, otherwise the origin isthe point on the plane that is
closest to the camera location.
</param>
            <returns>True if camera and frustum are valid and plane was set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFarPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get far clipping plane.</summary>
            <param name="far_plane">
[out] far clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the far clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetNearPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get near clipping plane.</summary>
            <param name="near_plane">
[out] near clipping plane if camera and frustum are valid. The plane's frame
is the same as the camera's frame.  The origin is located at the intersection
of the camera direction ray and the near clipping plane.
</param>
            <returns>TRUE if camera and frustum are valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetSphereDepth(RMA.OpenNURBS.IOnSphere,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding sphere.</summary>
            <param name="sphere">[in] bounding sphere</param>
            <param name="near_dist">[out] near distance of the sphere (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the sphere (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the sphere intersects the view frustum and near_dist/far_dist were set.
False if the sphere does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetBoundingBoxDepth(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a bounding box</summary>
            <param name="bbox">[in] bounding box</param>
            <param name="near_dist">[out] near distance of the box (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the box (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the bounding box intersects the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetPointDepth(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Boolean)">
            <summary>Get near and far clipping distances of a point</summary>
            <param name="point">[in]</param>
            <param name="near_dist">[out] near distance of the point (can be &lt; 0)</param>
            <param name="far_dist">[out] far distance of the point (can be equal to near_dist)</param>
            <param name="bGrowNearFar">
[in] If true and input values of near_dist and far_dist are not ON_UNSET_VALUE,
the near_dist and far_dist are enlarged to include bbox.
</param>
            <returns>
True if the point is ing the view frustum and near_dist/far_dist were set.
False if the bounding box does not intesect the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.FrustumLeft">
            <summary>
The near clipping plane stored in the Rhino 1.0 file is frequently very
small and useless for high quality z-buffer based rendering.  The far
clipping value is not stored in the file.  Use these functions to set
the frustum's near and far clipping planes to appropriate values.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumCenter(RMA.OpenNURBS.On3dPoint@)">
            <summary>
Returns world coordinates of frustum's center
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetFrustumAspect(System.Double@)">
            <summary>
Returns frustum's width/height
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.On3dPoint@,System.Double,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="center">world coordinate bounding sphere center</param>
            <param name="radius">world coordinate bounding sphere radius</param>
            <param name="cambox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraExtents(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns bounding box in camera coordinates - this is useful information
for setting view frustrums to include the point list
</summary>
            <param name="worldbbox">world coordinate bounding box</param>
            <param name="cambbox">bounding box in camera coordinates</param>
            <param name="bGrowBox">set to TRUE if you want to enlarge an existing camera coordinate box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.CameraZ">
            <summary>
unit vector in -CameraDirection
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.CameraY">
            <summary>
unit up vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.CameraX">
            <summary>
unit to right vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnViewport.GetCameraFrame(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns TRUE if current camera orientation is valid</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnViewport">
            <summary>This object represents a viewing frustum</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurfaceArray.Append(RMA.OpenNURBS.IOnSurface)">
            <summary>
Adds a copy of a surface to this list. DuplicateSurface is called on the input and the duplicate
is saved in the SurfaceArray
</summary>
            <param name="surface">the surface to copy and add to the array</param>
            <returns>the duplicated surface that has been added to the array</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.DestroySurfaceTree">
            <summary>
If the geometry surface is modified in any way, then
call DestroySurfaceTree().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <param name="t_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.HasNurbForm">
            <summary>Is there a NURBS surface representation of this surface.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the surface's
2 success - NURBS point locus matches the surface's and
           the domain of the NURBS surface is correct. However,
           This surface's parameterization and the NURBS
           surface parameterization may not match. This situation
           happens when getting NURBS representations of surfaces
           that have a transendental parameterization like spheres,
           cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Surface::GetNurbForm ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Offset(System.Double,System.Double)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Offset(System.Double,System.Double,System.Double@)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <param name="max_deviation">
[out] If this parameter is not NULL, the maximum deviation from the returned offset
to the TRUE offset is returned here. This deviation is zero except for cases where
an exact offset cannot be computed using the same class of surface definition.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <param name="tdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnSurface@,RMA.OpenNURBS.OnSurface@)">
            <summary>Splits (divides) the surface into two parts at the specified parameter.</summary>
            <param name="dir">
0 The surface is split vertically. The "west" side is returned in
 "west_or_south_side" and the "east" side is returned
 in "east_or_north_side".
1 The surface is split horizontally. The "south" side is returned in
 "west_or_south_side" and the "north" side is returned in
 "east_or_north_side".
</param>
            <param name="c">[in] value of constant parameter in interval returned by Domain(dir)</param>
            <param name="west_or_south_side">[out] west/south portion of surface returned here</param>
            <param name="east_or_north_side">[out] east/north portion of surface returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Extend(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>
Pure virtual function. Default returns false. Where possible, analytically extends surface to include domain.
</summary>
            <param name="dir">
0 new Domain(0) will include domain. (the first surface parameter).
1 new Domain(1) will include domain. (the second surface parameter).
</param>
            <param name="domain">
[in] if domain is not included in surface domain, surface will be extended so
that its domain includes domain. Will not work if surface is closed in direction dir.
Original surface is identical to the restriction of the resulting surface to the
original surface domain
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Trim(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <summary>Removes the portions of the surface outside of the specified interval.</summary>
            <param name="dir">
0 The domain specifies an sub-interval of Domain(0) (the first surface parameter).
1 The domain specifies an sub-interval of Domain(1) (the second surface parameter).
</param>
            <param name="domain">
[in] interval of the surface to keep. If dir is 0, then the portions of the surface
with parameters (s,t) satisfying s &lt; Domain(0).Min() or s &gt; Domain(0).Max() are trimmed away.
If dir is 1, then the portions of the surface with parameters (s,t) satisfying t &lt; Domain(1).Min()
or t &gt; Domain(1).Max() are trimmed away.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <param name="end_uv">[in] optional ending point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <param name="curve_2d_subdomain">[in] optional subdomain for curve_2d</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsoCurve(System.Int32,System.Double)">
            <summary>Get isoparametric curve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant e.g., point on
 IsoCurve(0,c) at t is srf(t,c) This is a horizontal line from left to right
1 first parameter is constant and second parameter varies e.g., point on
 IsoCurve(1,c) at t is srf(c,t This is a vertical line from bottom to top
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>Isoparametric curve.</returns>
            <remarks>
In this function "dir" indicates which direction
the resulting curve runs. 0: horizontal, 1: vertical
In the other ON_Surface functions that take a "dir" argument,
"dir" indicates if "c" is a "u" or "v" parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Evaluate3rdDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="duuu">third partial derivatives (Dsss)</param>
            <param name="duuv">third partial derivatives (Dsst)</param>
            <param name="duvv">third partial derivatives (Dstt)</param>
            <param name="dvvv">third partial derivatives (Dttt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Evaluate3rdDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnSurface.EvaluateQuadrant)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="duuu">third partial derivatives (Dsss)</param>
            <param name="duuv">third partial derivatives (Dsst)</param>
            <param name="duvv">third partial derivatives (Dstt)</param>
            <param name="dvvv">third partial derivatives (Dttt)</param>
            <param name="quadrant">
   determines which side to evaluate from
   EvaluateQuadrant::NE_quadrant = (Quadrant 1)
   EvaluateQuadrant::NW_quadrant = (Quadrant 2)
   EvaluateQuadrant::SW_quadrant = (Quadrant 3)
   EvaluateQuadrant::SE_quadrant = (Quadrant 4)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Evaluate2ndDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Evaluate2ndDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnSurface.EvaluateQuadrant)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="quadrant">
   determines which side to evaluate from
   EvaluateQuadrant::NE_quadrant = (Quadrant 1)
   EvaluateQuadrant::NW_quadrant = (Quadrant 2)
   EvaluateQuadrant::SW_quadrant = (Quadrant 3)
   EvaluateQuadrant::SE_quadrant = (Quadrant 4)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Evaluate1stDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Evaluate1stDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnSurface.EvaluateQuadrant)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
   determines which side to evaluate from
   EvaluateQuadrant::NE_quadrant = (Quadrant 1)
   EvaluateQuadrant::NW_quadrant = (Quadrant 2)
   EvaluateQuadrant::SW_quadrant = (Quadrant 3)
   EvaluateQuadrant::SE_quadrant = (Quadrant 4)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.FrameAt(System.Double,System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.NormalAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.PointAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Transpose">
            <summary>transpose surface parameterization (swap "s" and "t")</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Reverse(System.Int32)">
            <summary>reverse parameterizatrion, Domain changes from [a,b] to [-b,-a]</summary>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0
and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsAtSeam(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a seam.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>
0 if not a seam,
1 if s == Domain(0)[i] and srf(s, t) == srf(Domain(0)[1-i], t)
2 if t == Domain(1)[i] and srf(s, t) == srf(s, Domain(1)[1-i])
3 if 1 and 2 are true.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsAtSingularity(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsAtSingularity(System.Double,System.Double,System.Boolean)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="bExact">
[in] if true, test if s,t is exactly at a singularity 
if false, test if close enough to cause numerical problems.
</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsSingular(System.Int32)">
            <returns>TRUE if surface side is collapsed to a point</returns>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPeriodic(System.Int32)">
            <returns>TRUE if surface is periodic in direction (default is FALSE)</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsClosed(System.Int32)">
            <returns>TRUE if surface is closed in direction</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsTorus">
            <summary>Determine if the surface is a portion of a torus within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Torus definition of this surface on success, null if this is NOT a torus</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsTorus(System.Double)">
            <summary>Determine if the surface is a portion of a torus</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Torus definition of this surface on success, null if this is NOT a torus</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsCone">
            <summary>Determine if the surface is a portion of a cone within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Cone definition of this surface on success, null if this is NOT a cone</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsCone(System.Double)">
            <summary>Determine if the surface is a portion of a cone</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Cone definition of this surface on success, null if this is NOT a cone</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsCylinder">
            <summary>Determine if the surface is a portion of a cylinder within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Cylinder definition of this surface on success, null if this is NOT a cylinder</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsCylinder(System.Double)">
            <summary>Determine if the surface is a portion of a cylinder</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Cylinder definition of this surface on success, null if this is NOT a cylinder</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsSphere">
            <summary>Determine if the surface is a portion of a sphere within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Sphere definition of this surface on success, null if this is NOT a sphere</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsSphere(System.Double)">
            <summary>Determine if the surface is a portion of a sphere</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Sphere definition of this surface on success, null if this is NOT a sphere</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPlanar">
            <summary>Test a surface to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsIsoparametric(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test a 2d bounding box to see if it is iso parameteric in the surface's parameter space.
</summary>
            <param name="bbox">[in] bounding box to test Returns: Isoparametric status of the bounding box.</param>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <param name="curve_domain">[in] optional sub domain of the curve</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetParameterTolerance(System.Int32,System.Double,System.Double@,System.Double@)">
            <summary>returns tminus &lt; tplus: parameters tminus &lt;= s &lt;= tplus</summary>
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
            <param name="t">parameter in domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Degree(System.Int32)">
            <summary>
returns maximum algebraic degree of any span 
( or a good estimate if curve spans are not algebraic )
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetSpanVectorIndex(System.Int32,System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval@)">
            <summary>
If t is in the domain of the surface, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="t">[IN] evaluation parameter</param>
            <param name="side">[IN] 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_interval">[OUT] domain of the span containing t</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetSpanVector(System.Int32,System.Double[]@)">
            <summary>span knots</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="span_vector">array of length SpanCount() + 1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.SpanCount(System.Int32)">
            <returns>number of smooth nonempty spans in the parameter direction</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetSurfaceSize(System.Double@,System.Double@)">
            <summary>
Get an estimate of the size of the rectangle that would be created if the 3d
surface where flattened into a rectangle.
</summary>
            <param name="width">[out] (corresponds to the first surface parameter)</param>
            <param name="height">[out] (corresponds to the first surface parameter)</param>
            <example>
Reparameterize a surface to minimize distortion
in the map from parameter space to 3d.
  ON_Surface* surf = ...;
  double width, height;
  if ( surf-&gt;GetSurfaceSize( &amp;width, &amp;height ) )
  {
    srf-&gt;SetDomain( 0, ON_Interval( 0.0, width ) );
    srf-&gt;SetDomain( 1, ON_Interval( 0.0, height ) );
  }
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.Domain(System.Int32)">
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.SetDomain(System.Int32,System.Double,System.Double)">
            <param name="dir">0 sets first parameter's domain, 1 sets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.SetDomain(System.Int32,RMA.OpenNURBS.IOnInterval)">
            <param name="dir">0 sets first parameter's domain, 1 sets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.GetDomain(System.Int32,System.Double@,System.Double@)">
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh">[in] if not NULL, the surface mesh will be put into this mesh.</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSurface.DuplicateSurface">
            <summary>Get a duplicate of the surface.</summary>
            <returns>A duplicate of the surface.</returns>
            <remarks>
The caller must delete the returned surface. For non-ON_SurfaceProxy objects,
this simply duplicates the surface using ON_Object::Duplicate.
For ON_SurfaceProxy objects, this duplicates the actual proxy surface geometry and,
if necessary, transposes the result to that the returned surfaces's
parameterization and locus match the proxy surface's.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.VolumeMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>Calculate volume mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bVolume">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate volume first moments, volume, and volume centroid.</param>
            <param name="bSecondMoments">[in] true to calculate volume second moments.</param>
            <param name="bProductMoments">[in] true to calculate volume product moments.</param>
            <param name="base_point">
[in] If the surface is closed, then pass ON_UNSET_VALUE. This parameter is for expert users
who are computing a volume whose boundary is defined by several non-closed breps, surfaces,
and meshes. When computing the volume, volume centroid, or volume first moments of a volume
whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point
to each call to VolumeMassProperties. When computing the volume second moments or volume
product moments of a volume whose boundary is defined by several breps, surfaces, and meshes,
you MUST pass the entire volume's centroid as the base_point and the input mp parameter
must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point).
In particular, in this case, you need to make two sets of calls; use first set to calculate
the volume centroid and the second set calculate the second moments and product moments.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.AreaMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of the surface.</summary>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate area</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NurbsSurface(RMA.OpenNURBS.OnNurbsSurface,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="pNurbsSurface">
[in/out] if not NULL, this pNurbsSurface will be used to store the NURBS representation of the surface and will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS surface representation.</param>
            <param name="s_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <param name="t_subdomain">
[in] if not NULL, then the NURBS representation for this portion of the surface is returned.
</param>
            <returns>NULL or a NURBS representation of the surface.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Surface::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.HasNurbForm">
            <summary>Is there a NURBS surface representation of this surface.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the surface's
2 success - NURBS point locus matches the surface's and
           the domain of the NURBS surface is correct. However,
           This surface's parameterization and the NURBS
           surface parameterization may not match. This situation
           happens when getting NURBS representations of surfaces
           that have a transendental parameterization like spheres,
           cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Surface::GetNurbForm ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@,System.Double)">
            <summary>Get a NURBS surface representation of this surface.</summary>
            <param name="nurbs_surface">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the surface's to wthe desired accuracy
2 success - returned NURBS point locus matches the surface's to the desired accuracy and the
           domain of the NURBS surface is correct. On However, This surface's parameterization
           and the NURBS surface parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of surfaces that have a
           transendental parameterization like spheres, cylinders, and cones.
</returns>
            <remarks>
This is a low-level virtual function. If you do not need the parameterization information
provided by the return code, then ON_Surface::NurbsSurface may be easier to use.
See Also: ON_Surface::NurbsSurface
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Offset(System.Double,System.Double)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Offset(System.Double,System.Double,System.Double@)">
            <summary>Offset surface.</summary>
            <param name="offset_distance">[in] offset distance</param>
            <param name="tolerance">
[in] Some surfaces do not have an exact offset that can be represented using
the same class of surface definition. In that case, the tolerance specifies
the desired accuracy.
</param>
            <param name="max_deviation">
[out] If this parameter is not NULL, the maximum deviation from the returned offset
to the TRUE offset is returned here. This deviation is zero except for cases where
an exact offset cannot be computed using the same class of surface definition.
</param>
            <returns>Offset surface.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameters of the point on a surface that is locally closest to 
the test_point.  The search for a local close point starts at 
seed parameters. If a sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the surface.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the parameters of the point on the surface that is closest to P.</summary>
            <param name="P">[in] test point</param>
            <param name="s">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="t">[out] (*s,*t) = parameters of the surface point that is closest to P.</param>
            <param name="maximum_distance">
[in] optional upper bound on the distance from P to the surface. If you are
only interested in finding a point Q on the surface when P.DistanceTo(Q) &lt; maximum_distance,
then set maximum_distance to that value.
</param>
            <param name="sdomain">[in] optional domain restriction</param>
            <param name="tdomain">[in] optional domain restriction</param>
            <returns>
True if successful. If false, the values of *s and *t are undefined.
See Also: ON_Surface::GetLocalClosestPoint.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnSurface@,RMA.OpenNURBS.OnSurface@)">
            <summary>Splits (divides) the surface into two parts at the specified parameter.</summary>
            <param name="dir">
0 The surface is split vertically. The "west" side is returned in
 "west_or_south_side" and the "east" side is returned
 in "east_or_north_side".
1 The surface is split horizontally. The "south" side is returned in
 "west_or_south_side" and the "north" side is returned in
 "east_or_north_side".
</param>
            <param name="c">[in] value of constant parameter in interval returned by Domain(dir)</param>
            <param name="west_or_south_side">[out] west/south portion of surface returned here</param>
            <param name="east_or_north_side">[out] east/north portion of surface returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pullback(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Pull a 3d curve back to the surface's parameter space.</summary>
            <param name="curve_3d">[in] a 3d curve</param>
            <param name="tolerance">
[in] the maximum acceptable 3d distance between from surface(curve_2d(t)) to
the locus of points on the surface that are closest to curve_3d.
</param>
            <param name="curve_3d_subdomain">[in] optional subdomain for curve_3d</param>
            <param name="start_uv">[in] optional starting point (if known)</param>
            <param name="end_uv">[in] optional ending point (if known)</param>
            <returns>
2d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pushup
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Pushup(RMA.OpenNURBS.IOnCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Compute a 3d curve that is the composite of a 2d curve and the surface map.</summary>
            <param name="curve_2d">[in] a 2d curve whose image is in the surface's domain.</param>
            <param name="tolerance">
[in] the maximum acceptable distance from the returned 3d curve to the image of curve_2d on the surface.
</param>
            <param name="curve_2d_subdomain">[in] optional subdomain for curve_2d</param>
            <returns>
3d curve.
See Also: ON_Surface::IsoCurve ON_Surface::Pullback
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsoCurve(System.Int32,System.Double)">
            <summary>Get isoparametric curve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant e.g., point on
 IsoCurve(0,c) at t is srf(t,c) This is a horizontal line from left to right
1 first parameter is constant and second parameter varies e.g., point on
 IsoCurve(1,c) at t is srf(c,t This is a vertical line from bottom to top
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>Isoparametric curve.</returns>
            <remarks>
In this function "dir" indicates which direction
the resulting curve runs. 0: horizontal, 1: vertical
In the other ON_Surface functions that take a "dir" argument,
"dir" indicates if "c" is a "u" or "v" parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvNormal(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="normal">unit normal</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Evaluate3rdDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="duuu">third partial derivatives (Dsss)</param>
            <param name="duuv">third partial derivatives (Dsst)</param>
            <param name="duvv">third partial derivatives (Dstt)</param>
            <param name="dvvv">third partial derivatives (Dttt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Evaluate3rdDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnSurface.EvaluateQuadrant)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="duuu">third partial derivatives (Dsss)</param>
            <param name="duuv">third partial derivatives (Dsst)</param>
            <param name="duvv">third partial derivatives (Dstt)</param>
            <param name="dvvv">third partial derivatives (Dttt)</param>
            <param name="quadrant">
   determines which side to evaluate from
   EvaluateQuadrant::NE_quadrant = (Quadrant 1)
   EvaluateQuadrant::NW_quadrant = (Quadrant 2)
   EvaluateQuadrant::SW_quadrant = (Quadrant 3)
   EvaluateQuadrant::SE_quadrant = (Quadrant 4)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Evaluate2ndDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Evaluate2ndDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnSurface.EvaluateQuadrant)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="quadrant">
   determines which side to evaluate from
   EvaluateQuadrant::NE_quadrant = (Quadrant 1)
   EvaluateQuadrant::NW_quadrant = (Quadrant 2)
   EvaluateQuadrant::SW_quadrant = (Quadrant 3)
   EvaluateQuadrant::SE_quadrant = (Quadrant 4)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Evaluate1stDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Evaluate1stDerivative(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnSurface.EvaluateQuadrant)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
   determines which side to evaluate from
   EvaluateQuadrant::NE_quadrant = (Quadrant 1)
   EvaluateQuadrant::NW_quadrant = (Quadrant 2)
   EvaluateQuadrant::SW_quadrant = (Quadrant 3)
   EvaluateQuadrant::SE_quadrant = (Quadrant 4)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev2Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="duu">second partial derivatives (Dss)</param>
            <param name="duv">second partial derivatives (Dst)</param>
            <param name="dvv">second partial derivatives (Dtt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Ev1Der(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>
returns FALSE if unable to evaluate
</summary>
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="du">first partial derivatives (Ds)</param>
            <param name="dv">first partial derivatives (Dt)</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.EvPoint(System.Double,System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>
returns FALSE if unable to evaluate
</summary>
            <summary>returns FALSE if unable to evaluate</summary>
            <param name="u">evaluation parameter</param>
            <param name="v">evaluation parameter</param>
            <param name="point">returns value of surface</param>
            <param name="quadrant">
optional - determines which side to evaluate from
   0 = default
   1 from NE quadrant
   2 from NW quadrant
   3 from SW quadrant
   4 from SE quadrant
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.FrameAt(System.Double,System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.NormalAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.PointAt(System.Double,System.Double)">
            <summary>simple evaluation interface - no error handling</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a surface parameter value.</summary>
            <param name="c">[in] continuity to test for</param>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance,
then the surface is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the surface is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the surface is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two normal vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the surface has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetNextDiscontinuity(System.Int32,RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="dir">
[in] If 0, then "u" parameter is checked.
If 1, then the "v" parameter is checked.
</param>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c 
is a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t. A value
of 1 means the first derivative or unit tangent was discontinuous. A value of 2
means the second derivative or curvature was discontinuous. A value of 0 means the
curve is not closed, a locus discontinuity test was applied, and t1 is at the start
of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or
ON::G2_continuous. If the cosine of the angle between two tangent vectors
is &lt;= cos_angle_tolerance, then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0
and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1. Note
 well that all curves are parametrically continuous at the ends of their domains.

Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsAtSeam(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a seam.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>
0 if not a seam,
1 if s == Domain(0)[i] and srf(s, t) == srf(Domain(0)[1-i], t)
2 if t == Domain(1)[i] and srf(s, t) == srf(s, Domain(1)[1-i])
3 if 1 and 2 are true.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsAtSingularity(System.Double,System.Double)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsAtSingularity(System.Double,System.Double,System.Boolean)">
            <summary>Test if a surface parameter value is at a singularity.</summary>
            <param name="s">[in] surface parameter to test</param>
            <param name="t">[in] surface parameter to test</param>
            <param name="bExact">
[in] if true, test if s,t is exactly at a singularity 
if false, test if close enough to cause numerical problems.
</param>
            <returns>true if surface is singular at (s,t)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsSingular(System.Int32)">
            <returns>TRUE if surface side is collapsed to a point</returns>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPeriodic(System.Int32)">
            <returns>TRUE if surface is periodic in direction (default is FALSE)</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsClosed(System.Int32)">
            <returns>TRUE if surface is closed in direction</returns>
            <param name="dir">0 = "s", 1 = "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsTorus">
            <summary>Determine if the surface is a portion of a torus within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Torus definition of this surface on success, null if this is NOT a torus</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsTorus(System.Double)">
            <summary>Determine if the surface is a portion of a torus</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Torus definition of this surface on success, null if this is NOT a torus</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsCone">
            <summary>Determine if the surface is a portion of a cone within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Cone definition of this surface on success, null if this is NOT a cone</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsCone(System.Double)">
            <summary>Determine if the surface is a portion of a cone</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Cone definition of this surface on success, null if this is NOT a cone</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsCylinder">
            <summary>Determine if the surface is a portion of a cylinder within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Cylinder definition of this surface on success, null if this is NOT a cylinder</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsCylinder(System.Double)">
            <summary>Determine if the surface is a portion of a cylinder</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Cylinder definition of this surface on success, null if this is NOT a cylinder</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsSphere">
            <summary>Determine if the surface is a portion of a sphere within OnUtil.On_ZERO_TOLERANCE</summary>
            <returns>Sphere definition of this surface on success, null if this is NOT a sphere</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsSphere(System.Double)">
            <summary>Determine if the surface is a portion of a sphere</summary>
            <param name="tolerance">tolerance used when checking</param>
            <returns>Sphere definition of this surface on success, null if this is NOT a sphere</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPlanar">
            <summary>Test a surface to see if it is planar.</summary>
            <returns>
true if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <returns>
true if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a surface to see if it is planar.</summary>
            <param name="plane">[out] if not NULL and TRUE is returned, the plane parameters are filled in.</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from the surface to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsIsoparametric(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test a 2d bounding box to see if it is iso parameteric in the surface's parameter space.
</summary>
            <param name="bbox">[in] bounding box to test Returns: Isoparametric status of the bounding box.</param>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.IsIsoparametric(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval)">
            <summary>Test a 2d curve to see if it is iso parameteric in the surface's parameter space.</summary>
            <param name="curve">[in] curve to test</param>
            <param name="curve_domain">[in] optional sub domain of the curve</param>
            <returns>Isoparametric status of the curve.</returns>
            <remarks>
Because it may transpose domains, ON_SurfaceProxy overrides this function.
All other surface classes just use the base class implementation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetParameterTolerance(System.Int32,System.Double,System.Double@,System.Double@)">
            <summary>returns tminus &lt; tplus: parameters tminus &lt;= s &lt;= tplus</summary>
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
            <param name="t">parameter in domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Degree(System.Int32)">
            <summary>
returns maximum algebraic degree of any span 
( or a good estimate if curve spans are not algebraic )
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetSpanVectorIndex(System.Int32,System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval@)">
            <summary>
If t is in the domain of the surface, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="t">[IN] evaluation parameter</param>
            <param name="side">[IN] 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_interval">[OUT] domain of the span containing t</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetSpanVector(System.Int32,System.Double[]@)">
            <summary>span knots</summary>
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
            <param name="span_vector">array of length SpanCount() + 1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.SpanCount(System.Int32)">
            <returns>number of smooth nonempty spans in the parameter direction</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetSurfaceSize(System.Double@,System.Double@)">
            <summary>
Get an estimate of the size of the rectangle that would be created if the 3d
surface where flattened into a rectangle.
</summary>
            <param name="width">[out] (corresponds to the first surface parameter)</param>
            <param name="height">[out] (corresponds to the first surface parameter)</param>
            <example>
Reparameterize a surface to minimize distortion
in the map from parameter space to 3d.
  ON_Surface* surf = ...;
  double width, height;
  if ( surf-&gt;GetSurfaceSize( &amp;width, &amp;height ) )
  {
    srf-&gt;SetDomain( 0, ON_Interval( 0.0, width ) );
    srf-&gt;SetDomain( 1, ON_Interval( 0.0, height ) );
  }
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.Domain(System.Int32)">
            <param name="dir">0 gets first parameter's domain, 1 gets second parameter's domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.GetDomain(System.Int32,System.Double@,System.Double@)">
            <param name="dir">0 gets first parameter, 1 gets second parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.CreateMesh(RMA.OpenNURBS.IOnMeshParameters,RMA.OpenNURBS.OnMesh)">
            <summary>Computes a polygon mesh approximation of the surface.</summary>
            <param name="mp">[in] meshing parameters</param>
            <param name="mesh">[in] if not NULL, the surface mesh will be put into this mesh.</param>
            <returns>A polygon mesh of the surface.</returns>
            <remarks>
This virtual function works in the openNURBS that is part of the Rhino SDK.
The source code for this functionallity is not provided in the free openNURBS toolkit.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSurface.DuplicateSurface">
            <summary>Get a duplicate of the surface.</summary>
            <returns>A duplicate of the surface.</returns>
            <remarks>
The caller must delete the returned surface. For non-ON_SurfaceProxy objects,
this simply duplicates the surface using ON_Object::Duplicate.
For ON_SurfaceProxy objects, this duplicates the actual proxy surface geometry and,
if necessary, transposes the result to that the returned surfaces's
parameterization and locus match the proxy surface's.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnSurface.EvaluateQuadrant">
            <summary>
Flags for which quadrant to use while evaluating the derivatives
of a surface
</summary>
            <remarks>
See Also:
 OnSurface::Evaluate1stDerivative
 OnSurface::Evaluate2ndDerivative
 OnSurface::Evaluate3rdDerivative
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnSurface.ISO">
            <summary>
flags for isoparametric curves
note: odd values are all "x" = constant
and even values &gt; 0 are all "y" = constant
ON_BrepTrim::m_iso uses these flags
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurveArray.Append(RMA.OpenNURBS.IOnCurve)">
            <summary>
Adds a copy of a curve to this list. DuplicateCurve is called on the input curve and the duplicate
is saved in the CurveArray
</summary>
            <param name="curve">the curve to copy and add to the array</param>
            <returns>the duplicated curve that has been added to the array</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.DestroyCurveTree">
            <summary>
Destroys the runtime curve tree used to speed closest
point and intersection calcuations.
</summary>
            <remarks>
If the geometry of the curve is modified in any way,
then call DestroyCurveTree();  The curve tree is 
created as needed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbFormParameterFromCurveParameter(System.Double,System.Double@)">
            <summary>Convert a curve parameter to a NURBS curve parameter.</summary>
            <param name="curve_t">[in] curve parameter</param>
            <param name="nurbs_t">[out] nurbs form parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
 ON_Curve::GetNurbForm, ON_Curve::GetCurveParameterFromNurbFormParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetCurveParameterFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve parameter to a curve parameter</summary>
            <param name="nurbs_t">[in] nurbs form parameter</param>
            <param name="curve_t">[out] curve parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
ON_Curve::GetNurbForm, ON_Curve::GetNurbFormParameterFromCurveParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.HasNurbForm">
            <summary>Does a NURBS curve representation of this curve.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the curve's to wthe desired accuracy
2 success - NURBS point locus matches the curve's and the domain of the NURBS curve is correct.
           However, This curve's parameterization and the NURBS curve parameterization may not
           match. This situation happens when getting NURBS representations of curves that have a
           transendental parameterization like circles
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Curve::GetNurbForm ON_Curve::NurbsCurve
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Split(System.Double,RMA.OpenNURBS.OnCurve@,RMA.OpenNURBS.OnCurve@)">
            <summary>
Splits (divides) the curve at the specified parameter. The parameter must be
in the interior of the curve's domain. The pointers passed to Split must
either be NULL or point to an ON_Curve object of the same type. If the pointer
is NULL, then a curve will be created in Split(). You may pass "this"
as left_side or right_side.
</summary>
            <param name="t">[in] parameter to split the curve at in the interval returned by Domain().</param>
            <param name="left_side">[out] left portion of curve returned here</param>
            <param name="right_side">[out] right portion of curve returned here</param>
            <returns>
TRUE - The curve was split into two pieces.
FALSE - The curve could not be split. For example if the parameter is too close to an endpoint.
</returns>
            <example>
For example, if crv were an ON_NurbsCurve, then
  ON_NurbsCurve right_side;
  crv.Split( crv.Domain().Mid() &amp;crv, &amp;right_side );
would split crv at the parametric midpoint, put the left side in crv, and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Extend(RMA.OpenNURBS.IOnInterval)">
            <summary>
Pure virtual function. Default returns false.
Where possible, analytically extends curve to include domain.
</summary>
            <param name="domain">
[in] if domain is not included in curve domain, curve will be extended so
that its domain includes domain. Will not work if curve is closed.
Original curve is identical to the restriction of the resulting curve to
the original curve domain, 
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Trim(RMA.OpenNURBS.IOnInterval)">
            <summary>Removes portions of the curve outside the specified interval.</summary>
            <param name="domain">
[in] interval of the curve to keep.  Portions of the curve before
curve(domain[0]) and after curve(domain[1]) are removed.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
A 0.0 s value corresponds to sub_domain-&gt;Min() and a 1.0 s value corresponds to
sub_domain-&gt;Max().
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.RemoveShortSegments(System.Double)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.RemoveShortSegments(System.Double,System.Boolean)">
            <summary>
Looks for segments that are shorter than tolerance that can be removed.
If bRemoveShortSegments is true, then the short segments are removed.
Does not change the domain, but it will change the relative parameterization.
</summary>
            <param name="tolerance">[in]</param>
            <param name="bRemoveShortSegments">[in] If true, then short segments are removed.</param>
            <returns>
True if removable short segments can were found.
False if no removable short segments can were found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection
of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLength(System.Double@)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLength(System.Double@,System.Double)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLength(System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of
the curve (must be non-decreasing)
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="curveB_domain">[in] optional restriction on curveB domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <param name="curve_domain">[in] optional restriction</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate4thDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate forth derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <param name="derivative4">[out] value of forth derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate4thDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate forth derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <param name="derivative4">[out] value of forth derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate3rdDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate third derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate3rdDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate third derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate2ndDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate2ndDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate1stDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Evaluate1stDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32,System.Int32@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.FrameAt(System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>Return a 3d frame at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="plane">[out] the frame is returned here</param>
            <returns>TRUE if successful</returns>
            <remarks>
See Also:
 ON_Curve::PointAt, ON_Curve::TangentAt,
 ON_Curve::Ev1Der, Ev2Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.PointAtEnd">
            <summary>Evaluate point at the end of the curve.</summary>
            <returns>Point (location of the end of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.PointAtStart">
            <summary>Evaluate point at the start of the curve.</summary>
            <returns>Point (location of the start of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::EvPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetEndPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to end at a specified point.</summary>
            <param name="end_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetStartPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetStartPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Force the curve to start at a specified point.</summary>
            <param name="start_point">[in]</param>
            <returns>TRUE if successful.</returns>
            <remarks>
Some end points cannot be moved. Be sure to check return code.
See Also: ON_Curve::SetEndPoint ON_Curve::PointAtStart ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Reverse">
            <summary>Reverse the direction of the curve.</summary>
            <returns>TRUE if curve was reversed.</returns>
            <remarks>If reveresed, the domain changes from [a,b] to [-b,-a]</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous.
If K0 and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPeriodic">
            <summary>Test a curve to see if it is periodic.</summary>
            <returns>TRUE if the curve is closed and at least C2 at the start/end.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosed">
            <summary>Test a curve to see if it is closed.</summary>
            <returns>TRUE if the curve is closed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosable(System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosable(System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsClosable(System.Double,System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <param name="min_rel_size">
[in] if greater than 1.0 and chord length is less than 
min_rel_size*gap, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPlanar">
            <summary>Test a curve to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc,System.Double)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPolyline">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.Arraydouble)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <param name="pline_t">
[out] if not NULL and TRUE is returned, then the parameters of the polyline points are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsLinear">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.IsLinear(System.Double)">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <param name="tolerance">[in] tolerance to use when checking linearity</param>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetParameterTolerance(System.Double,System.Double@,System.Double@)">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
            <param name="t">[IN] t = parameter in domain</param>
            <param name="tminus">[OUT]</param>
            <param name="tplus">[OUT]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Degree">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetSpanVectorIndex(System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval)">
            <summary>
If t is in the domain of the curve, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="t">[IN] t = evaluation parameter</param>
            <param name="side">[IN] side 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_domain">[OUT] domain of the span containing "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetSpanVector(System.Double[]@)">
            <summary>Get number of parameters of "knots".</summary>
            <param name="knots">
[out] an array of length SpanCount()+1 is filled in
with the parameters where the curve is not smooth (C-infinity).
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SpanCount">
            <summary>Get number of nonempty smooth (c-infinity) spans in curve</summary>
            <returns>Number of nonempty smooth (c-infinity) spans.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.ChangeDimension(System.Int32)">
            <summary>Change the dimension of a curve.</summary>
            <param name="desired_dimension">[in]</param>
            <returns>
TRUE if the curve's dimension was already desired_dimension or if the
curve's dimension was successfully changed to desired_dimension.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.ChangeClosedCurveSeam(System.Double)">
            <summary>
If this curve is closed, then modify it so that the start/end point is at curve parameter t.
</summary>
            <param name="t">[in] curve parameter of new start/end point. The returned curves domain will start at t.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetDomain(System.Double,System.Double)">
            <summary>Set the domain of the curve.</summary>
            <param name="t0">[in]</param>
            <param name="t1">[in] new domain will be [t0,t1]</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.SetDomain(RMA.OpenNURBS.IOnInterval)">
            <summary>Set the domain of the curve.</summary>
            <param name="domain">[in] increasing interval Returns: true if successful.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.Domain">
            <summary>
domain of the curve.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.GetDomain(System.Double@,System.Double@)">
            <summary>Gets domain of the curve</summary>
            <param name="t0">[out]</param>
            <param name="t1">[out] domain is [*t0, *t1]</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCurve.DuplicateCurve">
            <summary>Get a duplicate of the curve.</summary>
            <returns>A duplicate of the curve.</returns>
            <remarks>
The caller must delete the returned curve. For non-ON_CurveProxy objects,
this simply duplicates the curve using ON_Object::Duplicate.
For ON_CurveProxy objects, this duplicates the actual proxy curve geometry and,
if necessary, trims and reverse the result to that the returned curve's
parameterization and locus match the proxy curve's.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.OnCurve">
            <summary>pure virtual class for curve objects</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.AreaMassProperties(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate area mass properties of a curve. The curve should be planar.</summary>
            <param name="base_point">
[in] A point on the plane that contians the curve. To get the best results,
the point should be in the near the curve's centroid. When computing
the area, area centroid, or area first moments of a planar area whose boundary
is defined by several curves, pass the same base_point and plane_normal to each
call to AreaMassProperties. The base_point must be in the plane of the curves.
When computing the area second moments or area product moments of a planar area
whose boundary is defined by several curves, you MUST pass the entire area's
centroid as the base_point and the input mp parameter must contain the results of
a previous call to AreaMassProperties(mp,true,true,false,false,base_point). In
particular, in this case, you need to make two sets of calls; use first set to
calculate the area centroid and the second set calculate the second moments and
product moments.
</param>
            <param name="plane_normal">
[in] nonzero unit normal to the plane of integration. If a closed curve has
counter clock-wise orientation with respect to this normal, the area will be
positive. If the a closed curve has clock-wise orientation with respect to
this normal, the area will be negative.
</param>
            <param name="mp">[out]</param>
            <param name="bArea">[in] true to calculate volume</param>
            <param name="bFirstMoments">[in] true to calculate area first moments, area, and area centroid.</param>
            <param name="bSecondMoments">[in] true to calculate area second moments.</param>
            <param name="bProductMoments">[in] true to calculate area product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.LengthMassProperties(RMA.OpenNURBS.OnMassProperties@,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Double)">
            <summary>Calculate length mass properties of the curve.</summary>
            <param name="mp">[out]</param>
            <param name="bLength">[in] true to calculate length</param>
            <param name="bFirstMoments">
[in] true to calculate volume first moments, length, and length centroid.
</param>
            <param name="bSecondMoments">[in] true to calculate length second moments.</param>
            <param name="bProductMoments">[in] true to calculate length product moments.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbFormParameterFromCurveParameter(System.Double,System.Double@)">
            <summary>Convert a curve parameter to a NURBS curve parameter.</summary>
            <param name="curve_t">[in] curve parameter</param>
            <param name="nurbs_t">[out] nurbs form parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
 ON_Curve::GetNurbForm, ON_Curve::GetCurveParameterFromNurbFormParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetCurveParameterFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve parameter to a curve parameter</summary>
            <param name="nurbs_t">[in] nurbs form parameter</param>
            <param name="curve_t">[out] curve parameter</param>
            <remarks>
If GetNurbForm returns 2, this function converts the curve
parameter to the NURBS curve parameter.
See Also:
ON_Curve::GetNurbForm, ON_Curve::GetNurbFormParameterFromCurveParameter
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.NurbsCurve(RMA.OpenNURBS.OnNurbsCurve,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="pNurbsCurve">
[in/out] if not NULL, this ON_NurbsCurve will be used to store the NURBS representation
of the curve will be returned.
</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>NULL or a NURBS representation of the curve.</returns>
            <remarks>
See ON_Surface::GetNurbForm for important details about the NURBS surface parameterization.
See Also: ON_Curve::GetNurbForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.HasNurbForm">
            <summary>Does a NURBS curve representation of this curve.</summary>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - NURBS parameterization matches the curve's to wthe desired accuracy
2 success - NURBS point locus matches the curve's and the domain of the NURBS curve is correct.
           However, This curve's parameterization and the NURBS curve parameterization may not
           match. This situation happens when getting NURBS representations of curves that have a
           transendental parameterization like circles
</returns>
            <remarks>
This is a low-level virtual function.
See Also: ON_Curve::GetNurbForm ON_Curve::NurbsCurve
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a NURBS curve representation of this curve.</summary>
            <param name="nurbs_curve">[out] NURBS representation returned here</param>
            <param name="tolerance">[in] tolerance to use when creating NURBS representation.</param>
            <param name="subdomain">
[in] if not NULL, then the NURBS representation for this portion of the curve is returned.
</param>
            <returns>
0 unable to create NURBS representation with desired accuracy.
1 success - returned NURBS parameterization matches the curve's to wthe desired accuracy
2 success - returned NURBS point locus matches the curve's to the desired accuracy and
           the domain of the NURBS curve is correct. On However, This curve's parameterization
           and the NURBS curve parameterization may not match to the desired accuracy. This
           situation happens when getting NURBS representations of curves that have a transendental
           parameterization like circles Remarks: This is a low-level virtual function. If you do
           not need the parameterization information provided by the return code, then
           ON_Curve::NurbsCurve may be easier to use.
See Also: ON_Curve::NurbsCurve
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Split(System.Double,RMA.OpenNURBS.OnCurve@,RMA.OpenNURBS.OnCurve@)">
            <summary>
Splits (divides) the curve at the specified parameter. The parameter must be
in the interior of the curve's domain. The pointers passed to Split must
either be NULL or point to an ON_Curve object of the same type. If the pointer
is NULL, then a curve will be created in Split(). You may pass "this"
as left_side or right_side.
</summary>
            <param name="t">[in] parameter to split the curve at in the interval returned by Domain().</param>
            <param name="left_side">[out] left portion of curve returned here</param>
            <param name="right_side">[out] right portion of curve returned here</param>
            <returns>
TRUE - The curve was split into two pieces.
FALSE - The curve could not be split. For example if the parameter is too close to an endpoint.
</returns>
            <example>
For example, if crv were an ON_NurbsCurve, then
  ON_NurbsCurve right_side;
  crv.Split( crv.Domain().Mid() &amp;crv, &amp;right_side );
would split crv at the parametric midpoint, put the left side in crv, and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoints(System.Double[],System.Double[]@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] array of normalized arc length parameters.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">
[out] array of curve parameters such that the length of the curve from its
start to t[i] is s[i]*curve_length.
</param>
            <param name="absolute_tolerance">
[in] if absolute_tolerance &gt; 0, then the difference between (s[i+1]-s[i])*curve_length
and the length of the curve segment from t[i] to t[i+1] will be &lt;= absolute_tolerance.
</param>
            <param name="fractional_tolerance">
[in] desired fractional precision for each segment.
fabs("true" length - actual length)/(actual length) &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
A 0.0 s value corresponds to sub_domain-&gt;Min() and a 1.0 s value corresponds to
sub_domain-&gt;Max().
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNormalizedArcLengthPoint(System.Double,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the curve that is a prescribed arc length from the start of the curve.
</summary>
            <param name="s">
[in] normalized arc length parameter.
E.g., 0 = start of curve, 1/2 = midpoint of curve, 1 = end of curve.
</param>
            <param name="t">[out] parameter such that the length of the curve from its start to t is arc_length.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of the curve.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsShort(System.Double)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsShort(System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Used to quickly find short curves.</summary>
            <param name="tolerance">[in] (&gt;=0)</param>
            <param name="sub_domain">
[in] If not NULL, the test is performed on the interval that is the intersection
of sub_domain with Domain().
</param>
            <returns>True if the length of the curve is &lt;= tolerance.</returns>
            <remarks>Faster than calling Length() and testing the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLength(System.Double@)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLength(System.Double@,System.Double)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parametrizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLength(System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Get the length of the curve.</summary>
            <param name="length">[out] length returned here.</param>
            <param name="fractional_tolerance">
[in] desired fractional precision.
fabs(("exact" length from start to t) - arc_length)/arc_length &lt;= fractional_tolerance
</param>
            <param name="sub_domain">
[in] If not NULL, the calculation is performed on the specified sub-domain of
the curve (must be non-decreasing)
</param>
            <returns>
TRUE if returned if the length calculation is successful.
FALSE is returned if the length is not calculated.
</returns>
            <remarks>
The arc length will be computed so that (returned length - real length)/(real length) &lt;= fractional_tolerance
More simply, if you want N significant figures in the answer, set the fractional_tolerance to 1.0e-N.
For "nice" curves, 1.0e-8 works fine. For very high degree NURBS and NURBS with bad
parameterizations, use larger values of fractional_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t)
to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will
be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0,
then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectCurve(RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this curve with curveB.</summary>
            <param name="curveB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event.
If the input intersection_tolerance &lt;= 0.0, then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events
and the distance from curve(t) to curveB is &lt;= overlap_tolerance for
every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event.
If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="curveA_domain">[in] optional restriction on this curve's domain</param>
            <param name="curveB_domain">[in] optional restriction on curveB domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Find curve's self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <param name="curve_domain">[in] optional restriction</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is locally closest to 
the test_point.  The search for a local close point starts at 
seed_parameter. If the sub_domain parameter is not NULL, then
the search is restricted to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Find parameter of the point on a curve that is closest to test_point.
If the maximum_distance parameter is &gt; 0, then only points whose distance
to the given point is &lt;= maximum_distance will be returned.  Using a 
positive value of maximum_distance can substantially speed up the search.
If the sub_domain parameter is not NULL, then the search is restricted
to the specified portion of the curve.
</summary>
            <returns>
TRUE if returned if the search is successful.  FALSE is returned if
the search fails.
</returns>
            <param name="t">parameter of local closest point returned here</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>
FALSE if unable to evaluate.
See Also: ON_Curve::CurvatureAt ON_Curve::Ev2Der ON_EvCurvature
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0 default
&lt;0 to evaluate from below,
&gt;0 to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>See Also: ON_Curve::TangentAt ON_Curve::Ev1Der</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate4thDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate forth derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <param name="derivative4">[out] value of forth derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate4thDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate forth derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <param name="derivative4">[out] value of forth derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate3rdDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate third derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate3rdDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate third derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="derivative3">[out] value of third derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate2ndDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate2ndDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="derivative2">[out] value of second derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate1stDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Evaluate1stDerivative(System.Double,RMA.OpenNURBS.ValueTypes.Point3d@,RMA.OpenNURBS.ValueTypes.Vector3d@,RMA.OpenNURBS.IOnCurve.EvaluateSide)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="derivative1">[out] value of first derivative at t</param>
            <param name="side">
[in] determines which side to evaluate from
from_above to evaluate from above
from_below to evaluate from below
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
=0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
ON_Curve::Ev1Der
ON_Curve::EvCurvature
ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,System.Int32,System.Int32@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
   =0   default
&lt;0   to evaluate from below, 
&gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::EvPoint
 ON_Curve::Ev2Der
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@,System.Int32,System.Int32@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="side">
[in] optional - determines which side to evaluate from
    =0   default
 &lt;0   to evaluate from below, 
 &gt;0   to evaluate from above
</param>
            <param name="hint">[in/out] optional evaluation hint used to speed repeated evaluations</param>
            <returns>FALSE if unable to evaluate.</returns>
            <remarks>
See Also:
 ON_Curve::PointAt
 ON_Curve::EvTangent
 ON_Curve::Evaluate
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.FrameAt(System.Double,RMA.OpenNURBS.OnPlane@)">
            <summary>Return a 3d frame at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="plane">[out] the frame is returned here</param>
            <returns>TRUE if successful</returns>
            <remarks>
See Also:
 ON_Curve::PointAt, ON_Curve::TangentAt,
 ON_Curve::Ev1Der, Ev2Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
 ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.PointAtEnd">
            <summary>Evaluate point at the end of the curve.</summary>
            <returns>Point (location of the end of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.PointAtStart">
            <summary>Evaluate point at the start of the curve.</summary>
            <returns>Point (location of the start of the curve.)</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::PointAt
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
            <remarks>
No error handling.
See Also:
ON_Curve::EvPoint
ON_Curve::PointAtStart
ON_Curve::PointAtEnd
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsContinuous(RMA.OpenNURBS.IOn.continuity,System.Double,System.Int32@,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Test continuity at a curve parameter value.</summary>
            <param name="c">[in] type of continuity to test for. Read ON::continuity comments for details.</param>
            <param name="t">[in] parameter to test</param>
            <param name="hint">[in] evaluation hint</param>
            <param name="point_tolerance">
[in] if the distance between two points is greater than point_tolerance, then the curve is not C0.
</param>
            <param name="d1_tolerance">
[in] if the difference between two first derivatives is greater than d1_tolerance, then the curve is not C1.
</param>
            <param name="d2_tolerance">
[in] if the difference between two second derivatives is greater than d2_tolerance, then the curve is not C2.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous. If K0 and K1 are
curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance, then a
curvature discontinuity is reported.
</param>
            <returns>TRUE if the curve has at least the c type continuity at the parameter t.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetNextDiscontinuity(RMA.OpenNURBS.IOn.continuity,System.Double,System.Double,System.Double@,System.Int32@,System.Int32@,System.Double,System.Double)">
            <summary>Search for a derivatitive, tangent, or curvature discontinuity.</summary>
            <param name="c">[in] type of continity to test for.</param>
            <param name="t0">
[in] Search begins at t0. If there is a discontinuity at t0, it will be ignored.
This makes it possible to repeatedly call GetNextDiscontinuity and step through
the discontinuities.
</param>
            <param name="t1">
[in] (t0 != t1) If there is a discontinuity at t1 is will be ingored unless c is
a locus discontinuity type and t1 is at the start or end of the curve.
</param>
            <param name="t">
[out] if a discontinuity is found, then *t reports the parameter at the discontinuity.
</param>
            <param name="hint">
[in/out] if GetNextDiscontinuity will be called repeatedly, passing a "hint"
with initial value *hint=0 will increase the speed of the search.
</param>
            <param name="dtype">
[out] if not NULL, *dtype reports the kind of discontinuity found at *t.
A value of 1 means the first derivative or unit tangent was discontinuous.
A value of 2 means the second derivative or curvature was discontinuous.
A value of 0 means teh curve is not closed, a locus discontinuity test was applied,
and t1 is at the start of end of the curve.
</param>
            <param name="cos_angle_tolerance">
[in] default = cos(1 degree) Used only when c is ON::G1_continuous or ON::G2_continuous.
If the cosine of the angle between two tangent vectors is &lt;= cos_angle_tolerance,
then a G1 discontinuity is reported.
</param>
            <param name="curvature_tolerance">
[in] (default = ON_SQRT_EPSILON) Used only when c is ON::G2_continuous.
If K0 and K1 are curvatures evaluated from above and below and |K0 - K1| &gt; curvature_tolerance,
then a curvature discontinuity is reported.
</param>
            <returns>
Parametric continuity tests c = (C0_continuous, ..., G2_continuous):
 TRUE if a parametric discontinuity was found strictly between t0 and t1.
 Note well that all curves are parametrically continuous at the ends of
 their domains.
Locus continuity tests c = (C0_locus_continuous, ...,G2_locus_continuous):
 TRUE if a locus discontinuity was found strictly between t0 and t1 or at t1
 is the at the end of a curve. Note well that all open curves (IsClosed()=false)
 are locus discontinuous at the ends of their domains. All closed curves
 (IsClosed()=true) are at least C0_locus_continuous at the ends of their domains.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPeriodic">
            <summary>Test a curve to see if it is periodic.</summary>
            <returns>TRUE if the curve is closed and at least C2 at the start/end.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosed">
            <summary>Test a curve to see if it is closed.</summary>
            <returns>TRUE if the curve is closed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosable(System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosable(System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsClosable(System.Double,System.Double,System.Double)">
            <summary>
Decide if it makes sense to close off this curve by moving 
the endpoint to the start based on start-end gap size and length
of curve as approximated by chord defined by 6 points.
</summary>
            <param name="tolerance">
[in] maximum allowable distance between start and end.
if start - end gap is greater than tolerance, returns false
</param>
            <param name="min_abs_size">
[in] if greater than 0.0 and none of the interior sampled
points are at least min_abs_size from start, returns false.
</param>
            <param name="min_rel_size">
[in] if greater than 1.0 and chord length is less than 
min_rel_size*gap, returns false.
</param>
            <returns>
true if start and end points are close enough based on above conditions.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsInPlane(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Test a curve to see if it lies in a specific plane.
</summary>
            <param name="test_plane">[in]</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if the maximum distance from the curve to the
test_plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPlanar">
            <summary>Test a curve to see if it is planar.</summary>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPlanar(RMA.OpenNURBS.OnPlane)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPlanar(RMA.OpenNURBS.OnPlane,System.Double)">
            <summary>Test a curve to see if it is planar.</summary>
            <param name="plane">
[out] if not NULL and TRUE is returned, the plane parameters are filled in.
</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
TRUE if there is a plane such that the maximum distance from
the curve to the plane is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc(RMA.OpenNURBS.IOnPlane)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsArc(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.OnArc,System.Double)">
            <summary>
Test a curve to see if the locus if its points is an arc or circle.
</summary>
            <param name="plane">[in] if not NULL, test is performed in this plane</param>
            <param name="arc">[out] if not NULL and TRUE is returned, then arc parameters are filled in</param>
            <param name="tolerance">[in] tolerance to use when checking</param>
            <returns>
ON_Arc.m_angle &gt; 0 if curve locus is an arc between
specified points.  If ON_Arc.m_angle is 2.0*ON_PI, then the curve
is a circle.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPolyline">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsPolyline(RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.Arraydouble)">
            <summary>
Several types of ON_Curve can have the form of a polyline including a degree 1 ON_NurbsCurve,
an ON_PolylineCurve, and an ON_PolyCurve all of whose segments are some form of polyline.
IsPolyline tests a curve to see if it can be represented as a polyline.
</summary>
            <param name="pline_points">
[out] if not NULL and TRUE is returned, then the points of the polyline form are returned here.
</param>
            <param name="pline_t">
[out] if not NULL and TRUE is returned, then the parameters of the polyline points are returned here.
</param>
            <returns>
0 curve is not some form of a polyline
&gt;=2 number of points in polyline form
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsLinear">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.IsLinear(System.Double)">
            <summary>
Test a curve to see if the locus if its points is a line segment.
</summary>
            <param name="tolerance">[in] tolerance to use when checking linearity</param>
            <returns>
TRUE if the ends of the curve are farther than tolerance apart
and the maximum distance from any point on the curve to
the line segment connecting the curve's ends is &lt;= tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetParameterTolerance(System.Double,System.Double@,System.Double@)">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
            <param name="t">[IN] t = parameter in domain</param>
            <param name="tminus">[OUT]</param>
            <param name="tplus">[OUT]</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Degree">
            <summary>
Returns maximum algebraic degree of any span
or a good estimate if curve spans are not algebraic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetSpanVectorIndex(System.Double,System.Int32,System.Int32@,RMA.OpenNURBS.OnInterval)">
            <summary>
If t is in the domain of the curve, GetSpanVectorIndex() returns the 
span vector index "i" such that span_vector[i] &lt;= t &lt;= span_vector[i+1].
The "side" parameter determines which span is selected when t is at the
end of a span.
</summary>
            <param name="t">[IN] t = evaluation parameter</param>
            <param name="side">[IN] side 0 = default, -1 = from below, +1 = from above</param>
            <param name="span_vector_index">[OUT] span vector index</param>
            <param name="span_domain">[OUT] domain of the span containing "t"</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetSpanVector(System.Double[]@)">
            <summary>Get number of parameters of "knots".</summary>
            <param name="knots">
[out] an array of length SpanCount()+1 is filled in
with the parameters where the curve is not smooth (C-infinity).
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.SpanCount">
            <summary>Get number of nonempty smooth (c-infinity) spans in curve</summary>
            <returns>Number of nonempty smooth (c-infinity) spans.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.Domain">
            <summary>
domain of the curve.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.GetDomain(System.Double@,System.Double@)">
            <summary>Gets domain of the curve</summary>
            <param name="t0">[out]</param>
            <param name="t1">[out] domain is [*t0, *t1]</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCurve.DuplicateCurve">
            <summary>Get a duplicate of the curve.</summary>
            <returns>A duplicate of the curve.</returns>
            <remarks>
The caller must delete the returned curve. For non-ON_CurveProxy objects,
this simply duplicates the curve using ON_Object::Duplicate.
For ON_CurveProxy objects, this duplicates the actual proxy curve geometry and,
if necessary, trims and reverse the result to that the returned curve's
parameterization and locus match the proxy curve's.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCurve.EvaluateSide">
            <summary>
Flags for which side to evaluate the derivative from
</summary>
            <remarks>
See Also:
 OnCurve::Evaluate1stDerivative
 OnCurve::Evaluate2ndDerivative
 OnCurve::Evaluate3rdDerivative
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCurve">
            <summary>pure virtual class for curve objects</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.EvaluatePoint(RMA.OpenNURBS.IOnObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate the location of a point from the object reference.</summary>
            <param name="objref">[in]</param>
            <param name="point">
[out] If the evaluation cannot be performed, ON_UNSET_POINT is returned.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.ComponentIndex">
            <summary>
If this piece of geometry is a component in something larger, like an ON_BrepEdge
in an ON_Brep, then this function returns the component index.
</summary>
            <returns>
This object's component index. If this object is not a sub-piece 
of a larger geometric entity, then the returned index has m_type = ON_COMPONENT_INDEX::invalid_type
and m_index = -1.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.BrepForm">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.BrepForm(RMA.OpenNURBS.OnBrep)">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <param name="brep">[in] if not NULL, brep is used to store the brep form of the geometry.</param>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.HasBrepForm">
            <summary>Query an object to see if it has an ON_Brep form.</summary>
            <returns>
TRUE if the virtual ON_Geometry::BrepForm can compute an ON_Brep representation of this object.
</returns>
            <remarks>
The default implementation of ON_Geometry::BrepForm returns FALSE.
See Also ON_Geometry::BrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.IsMorphable">
            <summary>
Returns: True if the object can be morphed by calling Morph(). See Also: ON_Geometry::Morph
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>Apply the space morph to this geometry.</summary>
            <param name="morph">[in]</param>
            <returns>
True is successful. If false is returned, the object may be damaged and should be discarded.
See Also: ON_Geometry::IsMorphable
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.SwapCoordinates(System.Int32,System.Int32)">
            <summary>Swaps object coordinate values with indices i and j.</summary>
            <param name="i">[in] coordinate index</param>
            <param name="j">[in] coordinate index</param>
            <remarks>
The default implementation uses the virtual Transform() 
function to calculate the result.  If you are creating
an object where Transform() is slow, coordinate swapping
will be frequently used, and coordinate swapping can
be quickly accomplished, then override this function.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.MakeDeformable">
            <summary>
If possible, converts the object into a form that can be accuratly modified
with "squishy" transformations like projections, shears, and
non-uniform scaling.
</summary>
            <returns>
False if object cannot be converted to a deformable object.
True if object was already deformable or was converted into a deformable object.
See Also: ON_Geometry::IsDeformable();
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.IsDeformable">
            <summary>
Returns: True if object can be accuratly modified with "squishy"
transformations like projections, shears, an non-uniform scaling.
See Also: ON_Geometry::MakeDeformable();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Transform(RMA.OpenNURBS.ValueTypes.Xform)">
            <summary>Transforms the object.</summary>
            <param name="xform">
[in] transformation to apply to object. If xform.IsSimilarity() is zero,
then you may want to call MakeSquishy() before calling Transform.
</param>
            <remarks>
When overriding this function, be sure to include a call to
ON_Object::TransformUserData() which takes care of transforming
any ON_UserData that may be attached to the object.
See Also: ON_Geometry::IsDeformable();
Classes derived from ON_Geometry should call ON_Geometry::Transform()
to handle user data transformations and then transform their definition.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transforms the object.</summary>
            <param name="xform">
[in] transformation to apply to object. If xform.IsSimilarity() is zero,
then you may want to call MakeSquishy() before calling Transform.
</param>
            <remarks>
When overriding this function, be sure to include a call to
ON_Object::TransformUserData() which takes care of transforming
any ON_UserData that may be attached to the object.
See Also: ON_Geometry::IsDeformable();
Classes derived from ON_Geometry should call ON_Geometry::Transform()
to handle user data transformations and then transform their definition.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.ClearBoundingBox">
            <summary>
Some objects cache bounding box information.
If you modify an object, then call ClearBoundingBox()
to inform the object that any cached bounding boxes
are invalid.  
</summary>
            <remarks>
Generally, ClearBoundingBox() overrides
simply invalidate a cached bounding box and then wait
for a call to GetBBox() before recomputing the bounding box.
The default implementation does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.ValueTypes.BoundingBox@,System.Boolean,RMA.OpenNURBS.ValueTypes.Xform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="grow_box">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <param name="xform">
[in] If not NULL, the tight bounding box of the transformed
geometry is calculated. The geometry is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed geometry is calculated. The geometry is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Dimension">
            <summary>Dimension of the object.</summary>
            <remarks>
The dimension is typically three.  For parameter space trimming
curves the dimension is two.  In rare cases the dimension can
be one or greater than three.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Scale(System.Double)">
            <summary>
Scales the object by the specified facotor.  The scale is
centered at the origin.
</summary>
            <returns>TRUE if object successfully scaled</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Translate(RMA.OpenNURBS.ValueTypes.Vector3d)">
            <summary>Translates the object along the specified vector.</summary>
            <returns>TRUE if object successfully translated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translates the object along the specified vector.</summary>
            <returns>TRUE if object successfully translated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Rotate(System.Double,RMA.OpenNURBS.ValueTypes.Vector3d,RMA.OpenNURBS.ValueTypes.Point3d)">
            <summary>
Rotates the object about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if object successfully rotated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the object about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if object successfully rotated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Rotate(System.Double,System.Double,RMA.OpenNURBS.ValueTypes.Vector3d,RMA.OpenNURBS.ValueTypes.Point3d)">
            <summary>
Rotates the object about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if object successfully rotated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the object about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if object successfully rotated</returns>
            <remarks>Uses virtual Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned.
If FALSE, the object's bounding box is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.ValueTypes.BoundingBox@,System.Boolean)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="grow_box">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned in bbox.  
If FALSE, the object's bounding box is returned in bbox.
</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned in bbox.  
If FALSE, the object's bounding box is returned in bbox.
</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnGeometry.BoundingBox">
            <summary>Get object's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.OnGeometry">
            <summary>
Base class for all geometry classes that must
provide runtime class id.  Provides interface
for common geometric operations like finding bounding
boxes and transforming.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.EvaluatePoint(RMA.OpenNURBS.IOnObjRef,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate the location of a point from the object reference.</summary>
            <param name="objref">[in]</param>
            <param name="point">
[out] If the evaluation cannot be performed, ON_UNSET_POINT is returned.
</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.ComponentIndex">
            <summary>
If this piece of geometry is a component in something larger, like an ON_BrepEdge
in an ON_Brep, then this function returns the component index.
</summary>
            <returns>
This object's component index. If this object is not a sub-piece 
of a larger geometric entity, then the returned index has m_type = ON_COMPONENT_INDEX::invalid_type
and m_index = -1.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.BrepForm">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.BrepForm(RMA.OpenNURBS.OnBrep)">
            <summary>If possible, BrepForm() creates a brep form of the ON_Geometry.</summary>
            <param name="brep">[in] if not NULL, brep is used to store the brep form of the geometry.</param>
            <returns>
a pointer to on ON_Brep or NULL. If the brep parameter is not NULL,
then brep is returned if the geometry has a brep form and NULL is returned
if the geometry does not have a brep form.
</returns>
            <remarks>
The caller is responsible for managing the brep memory.
See Also ON_Geometry::HasBrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.HasBrepForm">
            <summary>Query an object to see if it has an ON_Brep form.</summary>
            <returns>
TRUE if the virtual ON_Geometry::BrepForm can compute an ON_Brep representation of this object.
</returns>
            <remarks>
The default implementation of ON_Geometry::BrepForm returns FALSE.
See Also ON_Geometry::BrepForm
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.IsMorphable">
            <summary>
Returns: True if the object can be morphed by calling Morph(). See Also: ON_Geometry::Morph
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.IsDeformable">
            <summary>
Returns: True if object can be accuratly modified with "squishy"
transformations like projections, shears, an non-uniform scaling.
See Also: ON_Geometry::MakeDeformable();
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.ValueTypes.BoundingBox@,System.Boolean,RMA.OpenNURBS.ValueTypes.Xform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="grow_box">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <param name="xform">
[in] The tight bounding box of the transformed geometry
is calculated. The geometry is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the curve's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed geometry is calculated. The geometry is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
            <remarks>In general, GetTightBoundingBox is slower that BoundingBox, especially when xform is not null.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.Dimension">
            <summary>Dimension of the object.</summary>
            <remarks>
The dimension is typically three.  For parameter space trimming
curves the dimension is two.  In rare cases the dimension can
be one or greater than three.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@,System.Int32)">
            <summary>
Get corners of object's 3d axis aligned bounding box or
the union of the input box with the object's bounding box.
</summary>
            <param name="bbox_min">[in/out] minimum corner of the 3d bounding box</param>
            <param name="bbox_max">[in/out] maximum corner of the 3d bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned.
If FALSE, the object's bounding box is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.ValueTypes.BoundingBox@,System.Boolean)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned in bbox.  
If FALSE, the object's bounding box is returned in bbox.
</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get object's 3d axis aligned bounding box or the
union of the input box with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=FALSE) 
If TRUE, then the union of the input bbox and the 
object's bounding box is returned in bbox.  
If FALSE, the object's bounding box is returned in bbox.
</param>
            <returns>TRUE if object has bounding box and calculation was successful.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnGeometry.BoundingBox">
            <summary>Get object's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
            <remarks>Uses virtual GetBBox() function to calculate the result.</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnGeometry">
            <summary>
Base class for all geometry classes that must
provide runtime class id.  Provides interface
for common geometric operations like finding bounding
boxes and transforming.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.UserdataXform">
            <summary>
Updated if user data is attached to a piece of geometry that is transformed 
and the virtual ON_UserData::Transform() is not overridden.  If you override
ON_UserData::Transform() and want m_userdata_xform to be updated, then call the 
ON_UserData::Transform() in your override.
The default constructor sets m_userdata_xform to the identity.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.UserdataCopycount">
            <summary>
If m_userdata_copycount is 0, user data is not copied when object is copied.
If &gt; 0, user data is copied and m_copycount is incremented when parent object is copied.
The user data's  operator=() is used to copy. The default constructor sets m_userdata_copycount
to zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.ApplicationUuid">
            <summary>
This uuid is used to identify the application that created this piece of user data. In the case of
Rhino, this is the id of the plug-in that created the user data. User data with a nil application id
will not be saved in 3dm archives.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.UserdataUuid">
            <summary>
This uuid is the value that must be passed to ON_Object::GetUserData() to retrieve this piece of user data.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUserData.Transform(RMA.OpenNURBS.ValueTypes.Xform)">
            <summary>
If Transform() return FALSE, then the userdata is destroyed when its parent
object is transformed. The default Transform() updates m_userdata_xform and
returns TRUE. Carefully read the comments above m_userdata_xform
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.Description">
            <returns>description of user data shown in object properties dump.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.IsUnknownUserData">
            <summary>
Returns TRUE if the user data is anonymous. This happens when the user data
class is not defined at the time the user data is read from an archive. For
example, if a class derived from ON_UserData is defined in application A but
is not defined in application B, then the class can be defined when an
archive is written by A but not exist when an archive is read by B. In this
case, the user data is not lost, it is just read as ON_UnknownUserData by
application B. If application B saves the parent object in an archive, the
unknown user data is resaved in a form that can be read by application A.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUserData.Next">
            <summary>Used for traversing list of user data attached to an object.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUserData.Owner">
            <returns>object that owns the user data, may be null</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUserData.Dump(RMA.OpenNURBS.OnTextLog)">
            <summary>Prints class name, description, and uuid.</summary>
            <param name="text_log">[in] Information is sent to this text log.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnUserData.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>
Tests an object to see if its data members are correctly initialized.
</summary>
            <param name="text_log">
[optional] if the object is not valid and text_log is not NULL, then a brief english
description of the reason the object is not valid is appened to the log.  The information
appended to text_log is suitable for low-level debugging purposes by programmers and is
not intended to be useful as a high level user interface tool.
</param>
            <returns>
TRUE - object is valid
FALSE - object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUserData.UserdataCopycount">
            <summary>
If UserdataCopycount is 0, user data is not copied when object is copied.
If &gt; 0, user data is copied and m_copycount is incremented when parent object is copied.
The user data's  operator=() is used to copy. The default constructor sets UserdataCopycount
to zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUserData.ApplicationUuid">
            <summary>
This uuid is used to identify the application that created this piece of user data. In the case of
Rhino, this is the id of the plug-in that created the user data. User data with a nil application id
will not be saved in 3dm archives.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUserData.UserdataUuid">
            <summary>
This uuid is the value that must be passed to ON_Object::GetUserData() to retrieve this piece of user data.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUserData.Description">
            <returns>description of user data shown in object properties dump.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUserData.IsUnknownUserData">
            <summary>
Returns TRUE if the user data is anonymous. This happens when the user data
class is not defined at the time the user data is read from an archive. For
example, if a class derived from ON_UserData is defined in application A but
is not defined in application B, then the class can be defined when an
archive is written by A but not exist when an archive is read by B. In this
case, the user data is not lost, it is just read as ON_UnknownUserData by
application B. If application B saves the parent object in an archive, the
unknown user data is resaved in a form that can be read by application A.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUserData.Next">
            <summary>Used for traversing list of user data attached to an object.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUserData.Owner">
            <returns>object that owns the user data</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUserData.Dump(RMA.OpenNURBS.OnTextLog)">
            <summary>Prints class name, description, and uuid.</summary>
            <param name="text_log">[in] Information is sent to this text log.</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUserData.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>
Tests an object to see if its data members are correctly initialized.
</summary>
            <param name="text_log">
[optional] if the object is not valid and text_log is not NULL, then a brief english
description of the reason the object is not valid is appened to the log.  The information
appended to text_log is suitable for low-level debugging purposes by programmers and is
not intended to be useful as a high level user interface tool.
</param>
            <returns>
TRUE - object is valid
FALSE - object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="T:RMA.OpenNURBS.ISupportsBinaryArchive">
            <summary>
OnUserData subclasses that want to support storing of their information in
3dm archives must implement the ISupportsBinaryArchive interface
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DuplicateOnObject">
            <summary>Create a copy of the object</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DestroyRuntimeCache">
            <summary>
Expert user function. If you are using openNURBS in its default configuration
to read and write 3dm archives, you never need to call this function. Many
objects employ lazy creation of (runtime) caches that save information to help
speed geometric calculations. This function will destroy all runtime information.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DestroyRuntimeCache(System.Boolean)">
            <summary>
Expert user function. If you are using openNURBS in its default configuration
to read and write 3dm archives, you never need to call this function. Many
objects employ lazy creation of (runtime) caches that save information to help
speed geometric calculations. This function will destroy all runtime information.
</summary>
            <param name="bDelete">
[in] if true, any cached information is properly deleted.
If false, any cached information is simply discarded.
This is useful when the cached information may be in alternate memory
pools that are managed in nonstandard ways.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.MoveUserData(RMA.OpenNURBS.OnObject@)">
            <summary>
Expert user tool Moves user data from source_object to this, including
user data with a nil m_userdata_copycount. Deletes any source user data
with a duplicate m_userdata_uuid on this.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.CopyUserData(RMA.OpenNURBS.IOnObject)">
            <summary>
Expert user tool that copies user data that has a positive m_userdata_copycount
from the source_object to this.
</summary>
            <param name="source_object">[in] source of user data to copy</param>
            <remarks>
Generally speaking you don't need to use CopyUserData().
Simply rely on ON_Object::operator=() or the copy constructor to do the right thing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.TransformUserData(RMA.OpenNURBS.ValueTypes.Xform)">
            <summary>
Objects derived from ON_Geometry must call TransformUserData() in their Transform() member function.
</summary>
            <param name="xform">[in] transformation to apply to user data</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.TransformUserData(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: User data is stored as a linked list of ON_UserData classes. FirstUserData gets the first item in the linked list. This is the most recent item attached using AttachUserData(). Remark: To iterate through all the user data on an object, call FirstUserData() and then use ON_UserData::Next() to traverse the list.
</summary>
            <summary>
Objects derived from ON_Geometry must call TransformUserData() in their Transform() member function.
</summary>
            <param name="xform">[in] transformation to apply to user data</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.PurgeUserData">
            <summary>PurgeUserData() removes all user data from object.</summary>
            <remarks>Use delete GetUserData(...) to destroy a single piece of user data.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.GetUserStringKeys(System.String[]@)">
            <summary>
Description: Get a list of all user strings on an object. Parameters: user_strings - [out] user strings are appended to this list. Returns: Number of elements appended to the user_strings list.
</summary>
            <summary>Get a list of all user string keys on an object.</summary>
            <param name="user_string_keys">[out] user string keys are appended to this list.</param>
            <returns>Number of elements appended to the user_strings list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.GetUserString(System.String,System.String@)">
            <summary>Get user string from an object.</summary>
            <param name="key">[in] id used to retrieve the string.</param>
            <param name="string_value">[out]</param>
            <returns>True if a string with id was found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.SetUserString(System.String,System.String)">
            <summary>
Attach a user string to an object. This information will perisist through
copy construction, operator=, and file IO.
</summary>
            <param name="key">[in] id used to retrieve this string.</param>
            <param name="string_value">[in] If NULL, the string with this id will be removed.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.ModelObjectId">
            <summary>
All objects in an opennurbs model have an id
( ON_Layer.m_layer_id, ON_Font.m_font_id, ON_Material.m_material_id, ON_3dmObjectAttributes.m_uuid ).
</summary>
            <returns>The id used to identify the object in the openurbs model.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.ObjectType">
            <summary>
Useful for switch statements that need to differentiate between basic
object types like points, curves, surfaces, and so on.
</summary>
            <returns>
ON::object_type enum value.

ON::unknown_object_type unknown object
ON::point_object derived from ON_Point
ON::pointset_object some type of ON_PointCloud, ON_PointGrid, ...
ON::curve_object derived from ON_Curve
ON::surface_object derived from ON_Surface
ON::brep_object derived from ON_Brep
ON::beam_object derived from ON_Beam
ON::mesh_object derived from ON_Mesh
ON::layer_object derived from ON_Layer
ON::material_object derived from ON_Material
ON::light_object derived from ON_Light
ON::annotation_object derived from ON_Annotation,
ON::userdata_object derived from ON_UserData
ON::text_dot derived from ON_TextDot
</returns>
            <remarks>The default implementation of this virtual function returns ON::unknown_object_type</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Low level archive writing tool used by ON_BinaryArchive::ReadObject().</summary>
            <param name="binary_archive">archive to read from</param>
            <returns>Returns TRUE if the read is successful.</returns>
            <remarks>
Use ON_BinaryArchive::ReadObject() to read objects. This Read() function
should read the objects definition back into its data members. The default
implementation of this virtual function returns FALSE and does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Low level archive writing tool used by ON_BinaryArchive::WriteObject().</summary>
            <param name="binary_archive">archive to write to</param>
            <returns>Returns TRUE if the write is successful.</returns>
            <remarks>
Use ON_BinaryArchive::WriteObject() to write objects. This Write() function
should just write the specific definition of this object. It should not write
and any chunk typecode or length information. The default implementation of
this virtual function returns FALSE and does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.DataCRC(System.UInt32)">
            <summary>
Returns a CRC calculated from the information that defines the object.
This CRC can be used as a quick way to see if two objects are not identical.
</summary>
            <param name="current_remainder">[in]</param>
            <returns>CRC of the information the defines the object.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.SizeOf">
            <summary>
Returns: An estimate of the amount of memory the class uses in bytes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Creates a text dump of the object.</summary>
            <remarks>
Dump() is intended for debugging and is not suitable for creating
high quality text descriptions of an object. The default implementations
of this virtual function prints the class's name.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.IsValid">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <param name="text_log">
[in] if the object is not valid and text_log is not NULL, then a brief
english description of the reason the object is not valid is appened to
the log. The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful as a
high level user interface tool.
</param>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.IsKindOf(RMA.OpenNURBS.IOnClassId)">
            <summary>
Low level tool to test if an object is derived
from a specified class.
</summary>
            <param name="pClassId">[in] use classname::ClassId()</param>
            <returns>
TRUE if the instantiated object is derived from the
class whose id is passed as the argument.
</returns>
            <example>
 ON_Object* p = ....;
 if ( p-&gt;IsKindOf( ON_NurbsCurve::ClassId() ) )
 {
   it's a NURBS curve
 }
</example>
            <remarks>
The primary reason for IsKindOf() is to support the
static Cast() members declared in the ON_OBJECT_DECLARE
macro.  If we determine that dynamic_cast is properly 
supported and implemented by all supported compilers, 
then IsKindOf() may dissappear.  If an application needs
to determine if a pointer points to a class derived from
ON_SomeClassName, then call 
ON_SomeClassName::Cast(mystery pointer) and check for 
a non-null return.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnObject.MemoryRelocate">
            <summary>
The MemoryRelocate() function is called when an object's location in
memory is changed. For example, if an object resides in a chunk of memory
that is grown by calling a realloc that has to allocate a new chunk and
copy the contents of the old chunk to the new chunk, then the location of
the object's memory changes. In practice this happens when classes
derived from ON_Object are stored in dynamic arrays, like the default
implementation of ON_ObjectArray&lt;&gt;'s that use realloc to grow
the dynamic array.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnObject">
            <summary>
Pure virtual base class for all classes that must provide
runtime class id or support object level 3DM serialization
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.DuplicateOnObject">
            <summary>
Description: User data is stored as a linked list of ON_UserData classes. FirstUserData gets the first item in the linked list. This is the most recent item attached using AttachUserData(). Remark: To iterate through all the user data on an object, call FirstUserData() and then use ON_UserData::Next() to traverse the list.
</summary>
            <summary>Create a copy of the object</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.GetUserStringKeys(System.String[]@)">
            <summary>
Description: Get a list of all user strings on an object. Parameters: user_strings - [out] user strings are appended to this list. Returns: Number of elements appended to the user_strings list.
</summary>
            <summary>Get a list of all user string keys on an object.</summary>
            <param name="user_string_keys">[out] user string keys are appended to this list.</param>
            <returns>Number of elements appended to the user_strings list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.GetUserString(System.String,System.String@)">
            <summary>Get user string from an object.</summary>
            <param name="key">[in] id used to retrieve the string.</param>
            <param name="string_value">[out]</param>
            <returns>True if a string with id was found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.SetUserString(System.String,System.String)">
            <summary>
Attach a user string to an object. This information will perisist through
copy construction, operator=, and file IO.
</summary>
            <param name="key">[in] id used to retrieve this string.</param>
            <param name="string_value">[in] If NULL, the string with this id will be removed.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.ModelObjectId">
            <summary>
All objects in an opennurbs model have an id
( ON_Layer.m_layer_id, ON_Font.m_font_id, ON_Material.m_material_id, ON_3dmObjectAttributes.m_uuid ).
</summary>
            <returns>The id used to identify the object in the openurbs model.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.ObjectType">
            <summary>
Useful for switch statements that need to differentiate between basic
object types like points, curves, surfaces, and so on.
</summary>
            <returns>
ON::object_type enum value.

ON::unknown_object_type unknown object
ON::point_object derived from ON_Point
ON::pointset_object some type of ON_PointCloud, ON_PointGrid, ...
ON::curve_object derived from ON_Curve
ON::surface_object derived from ON_Surface
ON::brep_object derived from ON_Brep
ON::beam_object derived from ON_Beam
ON::mesh_object derived from ON_Mesh
ON::layer_object derived from ON_Layer
ON::material_object derived from ON_Material
ON::light_object derived from ON_Light
ON::annotation_object derived from ON_Annotation,
ON::userdata_object derived from ON_UserData
ON::text_dot derived from ON_TextDot
</returns>
            <remarks>The default implementation of this virtual function returns ON::unknown_object_type</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Low level archive writing tool used by ON_BinaryArchive::WriteObject().</summary>
            <param name="binary_archive">archive to write to</param>
            <returns>Returns TRUE if the write is successful.</returns>
            <remarks>
Use ON_BinaryArchive::WriteObject() to write objects. This Write() function
should just write the specific definition of this object. It should not write
and any chunk typecode or length information. The default implementation of
this virtual function returns FALSE and does nothing.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.DataCRC(System.UInt32)">
            <summary>
Returns a CRC calculated from the information that defines the object.
This CRC can be used as a quick way to see if two objects are not identical.
</summary>
            <param name="current_remainder">[in]</param>
            <returns>CRC of the information the defines the object.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.SizeOf">
            <summary>
Returns: An estimate of the amount of memory the class uses in bytes.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Creates a text dump of the object.</summary>
            <remarks>
Dump() is intended for debugging and is not suitable for creating
high quality text descriptions of an object. The default implementations
of this virtual function prints the class's name.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.IsValid">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.IsValid(RMA.OpenNURBS.OnTextLog)">
            <summary>Tests an object to see if its data members are correctly initialized.</summary>
            <param name="text_log">
[in] if the object is not valid and text_log is not NULL, then a brief
english description of the reason the object is not valid is appened to
the log. The information appended to text_log is suitable for low-level
debugging purposes by programmers and is not intended to be useful as a
high level user interface tool.
</param>
            <returns>
TRUE object is valid
FALSE object is invalid, uninitialized, etc.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObject.IsKindOf(RMA.OpenNURBS.IOnClassId)">
            <summary>
Low level tool to test if an object is derived
from a specified class.
</summary>
            <param name="pClassId">[in] use classname::ClassId()</param>
            <returns>
TRUE if the instantiated object is derived from the
class whose id is passed as the argument.
</returns>
            <example>
 ON_Object* p = ....;
 if ( p-&gt;IsKindOf( ON_NurbsCurve::ClassId() ) )
 {
   it's a NURBS curve
 }
</example>
            <remarks>
The primary reason for IsKindOf() is to support the
static Cast() members declared in the ON_OBJECT_DECLARE
macro.  If we determine that dynamic_cast is properly 
supported and implemented by all supported compilers, 
then IsKindOf() may dissappear.  If an application needs
to determine if a pointer points to a class derived from
ON_SomeClassName, then call 
ON_SomeClassName::Cast(mystery pointer) and check for 
a non-null return.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnObject">
            <summary>
Pure virtual base class for all classes that must provide
runtime class id or support object level 3DM serialization
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Mark">
            <summary>
Opennurbs classes have a mark value of 0.
Core Rhino classes have a mark value of 1.
Rhino plug-in classes have a mark value of &gt; 1.
</summary>
            <returns>Class mark value</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Uuid">
            <summary>
Returns: class uuid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Create">
            <summary>
Create an instance of the class associated with class id.
</summary>
            <returns>Instance of the class id's class.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.IsDerivedFrom(RMA.OpenNURBS.IOnClassId)">
            <summary>
Determine if the class associated with this ON_ClassId
is derived from another class.
</summary>
            <param name="potential_parent">[in] Class to test as parent.</param>
            <returns>TRUE if this is derived from potential_parent.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.BaseClass">
            <summary>
Returns: base class id
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.BaseClassName">
            <summary>
Returns: base class name
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.ClassName">
            <summary>
OnExitMemoryCleanup() releases all internal memory used by the
openNURBS classes for Cast() and serialization construction.
ON_ClassId::OnExitMemoryCleanup() should only be called when
the application is finished using the openNURBS library.
</summary>
            <summary>
Returns: class name
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Dumps the ON_ClassId list</summary>
            <param name="dump">[in] destination for the text dump.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.Purge(System.Int32)">
            <summary>
Each class derived from ON_Object has a corresponding
ON_ClassId stored in a linked list.  If a class definition
is going to disappear (which happens when the derived object
definition is in a DLL that uses openNURBS as a DLL and the 
DLL containing the derived object's definition is unloaded),
then the class's ON_ClassId needs to be removed from the class 
list.  ON_ClassId::Purge( mark ) removes all ON_ClassIds with a
a prescribed mark and returns the number of classes that
were purged.  
</summary>
            <param name="mark">[in] All ON_ClassIds with this mark will be purged.</param>
            <returns>Number of classes that were purged.</returns>
            <example>
  // Call ON_ClassId::IncrementMark() BEFORE loading MY.DLL.
  int my_dll_classid_mark = ON_ClassId::IncrementMark();
  load MY.DLL with classes derived from ON_Object
  ...
  // Call ON_ClassId::Purge() BEFORE unloading MY.DLL.
  ON_ClassId::Purge( my_dll_classid_mark );
  unload MY.DLL
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.IncrementMark">
            <summary>
Each class derived from ON_Object has a corresponding ON_ClassId
stored in a linked list and the class is marked with an integer
value.  ON_ClassId::IncrementMark() increments the value used to
mark new classes and returns the new marking value.
</summary>
            <returns>Value that will be used to mark all future ON_ClassIds.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.ClassId(System.Guid)">
            <summary>Gets a class's ON_ClassId from the class's uuid.</summary>
            <param name="class_uuid">[in] uuid for the class</param>
            <returns>Pointer to the class's ON_ClassId.</returns>
            <example>
ON_UUID brep_uuid = ON_UuidFromString("60B5DBC5-E660-11d3-BFE4-0010830122F0");
const ON_ClassId* brep_id = ON_CLassId::ClassId(brep_uuid);
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnClassId.ClassId(System.String)">
            <summary>Gets a class's ON_ClassId from the class's name.</summary>
            <param name="sClassName">[in] name of class</param>
            <returns>Pointer to the class's ON_ClassId.</returns>
            <example>const ON_ClassId* brep_id = ON_CLassId::ClassId("ON_Brep");</example>
        </member>
        <member name="T:RMA.OpenNURBS.OnClassId">
            <summary>
Every class derived from ON_Object has a class id that records
its class name, baseclass name, and class uuid.  The 
ON_OBJECT_DECLARE and ON_OBJECT_IMPLEMENT macros generate
the code that creates and initializes class ids.
The ON_Object::IsKindOf() and ON_Object::Cast() functions
use these class ids.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.Mark">
            <summary>
Opennurbs classes have a mark value of 0.
Core Rhino classes have a mark value of 1.
Rhino plug-in classes have a mark value of &gt; 1.
</summary>
            <returns>Class mark value</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.Uuid">
            <summary>
Returns: class uuid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.Create">
            <summary>
Create an instance of the class associated with class id.
</summary>
            <returns>Instance of the class id's class.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.IsDerivedFrom(RMA.OpenNURBS.IOnClassId)">
            <summary>
Determine if the class associated with this ON_ClassId
is derived from another class.
</summary>
            <param name="potential_parent">[in] Class to test as parent.</param>
            <returns>TRUE if this is derived from potential_parent.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.BaseClass">
            <summary>
Returns: base class id
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.BaseClassName">
            <summary>
Returns: base class name
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClassId.ClassName">
            <summary>
Returns: class name
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnClassId">
            <summary>
Every class derived from ON_Object has a class id that records
its class name, baseclass name, and class uuid.  The 
ON_OBJECT_DECLARE and ON_OBJECT_IMPLEMENT macros generate
the code that creates and initializes class ids.
The ON_Object::IsKindOf() and ON_Object::Cast() functions
use these class ids.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>Convert a arc radians parameter to a NURBS curve arc parameter.</summary>
            <param name="arc_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double arc_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double nurbs_t;
arc.GetNurbFormParameterFromRadian( arc_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t);
// arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve
created by ON_Arc::GetNurbForm. At radian values of 0.0, 0.5*ON_PI,
ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian
parameter are the same. At all other values the nurbs and radian
parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve arc parameter to a arc radians parameter.</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="arc_radians_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double arc_t;
arc.GetRadianFromNurbFormParameter( nurbs_t, &amp;arc_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); 
arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created
by ON_Arc::GetNurbForm. At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI,
1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian parameter are the same.
At all other values the nurbs and radian parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a rational degree 2 NURBS curve representation
of the arc.  Note that the parameterization of NURBS curve
does not match  arc's transcendental paramaterization.  
Use GetRadianFromNurbFormParameter() and
GetParameterFromRadian() to convert between the NURBS curve 
parameter and the transcendental parameter
</summary>
            <param name="nurbs_curve">[out] nurbs_curve returned here.</param>
            <returns>0 for failure and 2 for success.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Reverse">
            <summary>
Reverse the orientation of the arc.  Changes the domain from [a,b] to [-b.-a].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Length">
            <summary>
Length of the arc = radius*(subtended angle in radians).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <returns>
The point on the arc that is closest to test_point.
If test_point is the center of the arc, then the 
starting point of the arc is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <param name="t">
[out] parameter (in radians) of the point on the arc that
is closest to test_point.  If test_point is the center
of the arc, then the starting point of the arc is
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.EndPoint">
            <summary>
Point at end of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.MidPoint">
            <summary>
Point at middle of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.StartPoint">
            <summary>
Point at start of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.SetAngleDegrees(System.Double)">
            <summary>Set arc's subtended angle in degrees.</summary>
            <param name="angle_in_degrees">[in] 0 &lt; angle_in_degrees &lt;= 360</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Trim(RMA.OpenNURBS.IOnInterval)">
            <summary>Set arc's domain as a subdomain of the circle.</summary>
            <param name="domain_radian">[in] 0 &lt; domain_radian[1] - domain_radian[0] &lt;= 2.0 * ON*PI</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.SetAngleIntervalRadians(RMA.OpenNURBS.IOnInterval)">
            <summary>Set arc's angle interval in radians.</summary>
            <param name="angle_in_radians">
[in] increasing interval with start and end angle in radians.
Length of the interval &lt;= 2.0*ON_PI.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.SetAngleRadians(System.Double)">
            <summary>
Set arc's subtended angle in radians.
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.DomainDegrees">
            <summary>
The arc's domain in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.DomainRadians">
            <summary>
The arc's domain in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Domain">
            <summary>
Get evaluation domain. Returns Evaluation domain (same as DomainRadians()).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.IsCircle">
            <summary>
true if the arc is a complete circle; i.e., the arc's
angle is 360 degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed arc is calculated. The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) 
If true, then the union of the input bbox and the 
arc's bounding box is returned in bbox.  
If false, the arc's bounding box is returned in bbox.
</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.BoundingBox">
            <summary>Get arc's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.IsValid">
            <summary>Checks an arc to make sure it is valid.</summary>
            <remarks>Radius&gt;0 and 0&lt;AngleRadians()&lt;=2 ON_PI</remarks>
            <returns>true if the arc is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Creates a text dump of the arc listing the normal, center
radius, start point, end point, and angle.
</summary>
            <remarks>
Dump() is intended for debugging and is not suitable
for creating high quality text descriptions of an arc.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create an arc from a 3d start point, 3d start direction, and 3d end point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create an arc from a 2d start point, 2d start direction, and 2d end point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
arc through 3 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
arc through 3 2d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
Create an arc parallel to plane from a center point, radius, 
and angle in radians.  The arc starts at center+radius*plane.xaxis.
</summary>
            <param name="plane">circle will be parallel to this plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
Create an arc parallel to the world XY plane from a center point,
radius, and angle in radians.  The arc starts at center+(radius,0,0).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>
Create an arc from a plane, radius and an angle in radians.
The center of the arc is at the plane's origin.
</summary>
            <param name="plane">[IN] circle is in this plane with center at m_origin</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnCircle,RMA.OpenNURBS.IOnInterval)">
            <summary>Create an arc from a circle and an increasing angle interval</summary>
            <param name="circle">[in]</param>
            <param name="angle_interval_in_radians">
[in] increasing angle interval in radians with angle_interval_in_radians.Length() &lt;= 2.0*ON_PI
</param>
            <returns>true if input is valid and a valid arc is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.Create(RMA.OpenNURBS.IOnCircle,System.Double)">
            <summary>Create an arc from a circle and an angle in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
arc through 3 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary />
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
arc parallel to a plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
arc is parallel to XY plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>
circle is in this plane with center at m_origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor(RMA.OpenNURBS.IOnCircle,RMA.OpenNURBS.IOnInterval)">
            <param name="angle_interval_in_radians">
[in] increasing angle interval
in radians with angle_interval_in_radians.Length() &lt;= 2.0*ON_PI.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnArc.#ctor">
            <summary>
Create a radius one arc with angle = 2*pi
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnArc">
            <summary>
An ON_Arc is a subcurve of 3d circle. 
Details:
The curve is parameterized by	an angle expressed in radians.   For an IsValid() arc 
the total subtended angle 	AngleRadians() = Domain()(1) - Domain()(0) must satisfy
			0&lt; AngleRadians() &lt;2*Pi .

The parameterization of the ON_Arc is inherited from the ON_Circle it is derived from.
In particular
		 t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where xaxis and yaxis, (part of ON_Circle::m_plane) form an othonormal frame of the plane 
containing the circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>Convert a arc radians parameter to a NURBS curve arc parameter.</summary>
            <param name="arc_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double arc_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double nurbs_t;
arc.GetNurbFormParameterFromRadian( arc_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t);
// arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve
created by ON_Arc::GetNurbForm. At radian values of 0.0, 0.5*ON_PI,
ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian
parameter are the same. At all other values the nurbs and radian
parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>Convert a NURBS curve arc parameter to a arc radians parameter.</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="arc_radians_parameter">[out]</param>
            <example>
ON_Arc arc = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double arc_t;
arc.GetRadianFromNurbFormParameter( nurbs_t, &amp;arc_t );
ON_NurbsCurve nurbs_curve;
arc.GetNurbsForm( nurbs_curve );
arc_pt = arc.PointAt(arc_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); 
arc_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created
by ON_Arc::GetNurbForm. At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI,
1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and radian parameter are the same.
At all other values the nurbs and radian parameter values are different.
See Also: ON_Arc::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a rational degree 2 NURBS curve representation
of the arc.  Note that the parameterization of NURBS curve
does not match  arc's transcendental paramaterization.  
Use GetRadianFromNurbFormParameter() and
GetParameterFromRadian() to convert between the NURBS curve 
parameter and the transcendental parameter
</summary>
            <param name="nurbs_curve">[out] nurbs_curve returned here.</param>
            <returns>0 for failure and 2 for success.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.Length">
            <summary>
Length of the arc = radius*(subtended angle in radians).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <returns>
The point on the arc that is closest to test_point.
If test_point is the center of the arc, then the 
starting point of the arc is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Get the point on the arc that is closest to test_point.</summary>
            <param name="t">
[out] parameter (in radians) of the point on the arc that
is closest to test_point.  If test_point is the center
of the arc, then the starting point of the arc is
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.EndPoint">
            <summary>
Point at end of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.MidPoint">
            <summary>
Point at middle of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.StartPoint">
            <summary>
Point at start of the arc.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.DomainDegrees">
            <summary>
The arc's domain in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.DomainRadians">
            <summary>
The arc's domain in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.Domain">
            <summary>
Get evaluation domain. Returns Evaluation domain (same as DomainRadians()).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.AngleDegrees">
            <summary>
The arc's subtended angle in degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.AngleRadians">
            <summary>
The arc's subtended angle in radians.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.IsCircle">
            <summary>
true if the arc is a complete circle; i.e., the arc's
angle is 360 degrees.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed arc is calculated. The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get arc's 3d axis aligned bounding box or the
union of the input box with the arc's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) 
If true, then the union of the input bbox and the 
arc's bounding box is returned in bbox.  
If false, the arc's bounding box is returned in bbox.
</param>
            <returns>true if arc has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.BoundingBox">
            <summary>Get arc's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.IsValid">
            <summary>Checks an arc to make sure it is valid.</summary>
            <remarks>Radius&gt;0 and 0&lt;AngleRadians()&lt;=2 ON_PI</remarks>
            <returns>true if the arc is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnArc.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Creates a text dump of the arc listing the normal, center
radius, start point, end point, and angle.
</summary>
            <remarks>
Dump() is intended for debugging and is not suitable
for creating high quality text descriptions of an arc.
</remarks>
        </member>
        <member name="T:RMA.OpenNURBS.IOnArc">
            <summary>
An ON_Arc is a subcurve of 3d circle. 
Details:
The curve is parameterized by	an angle expressed in radians.   For an IsValid() arc 
the total subtended angle 	AngleRadians() = Domain()(1) - Domain()(0) must satisfy
			0&lt; AngleRadians() &lt;2*Pi .

The parameterization of the ON_Arc is inherited from the ON_Circle it is derived from.
In particular
		 t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where xaxis and yaxis, (part of ON_Circle::m_plane) form an othonormal frame of the plane 
containing the circle.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to centroid coordinates.
These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: WorldCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about centroid coordinate axes.</summary>
            <returns>
Radii of gyration with respect to centroid coordinate system.
CentroidCoordRadiiOfGyration().x = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
CentroidCoordRadiiOfGyration().y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
CentroidCoordRadiiOfGyration().z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about centroid coordinate axes.</summary>
            <returns>
Moments of inertia with respect to centroid coordinate system.
WorldCoordMomentsOfInertia().x = integral of ((y-y0)^2 + (z-z0)^2) dm
WorldCoordMomentsOfInertia().y = integral of ((z-z0)^2 + (x-x0)^2) dm
WorldCoordMomentsOfInertia().z = integral of ((z-z0)^2 + (y-y0)^2) dm
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.CentroidCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the centroid coordinate second
moments are returned in a vector (m_ccs_xx,m_ccs_yy,m_ccs_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to centroid coordinate system.
CentroidCoordSecondMoments().x = integral of (x-x0)^2 dm
CentroidCoordSecondMoments().y = integral of (y-y0)^2 dm
CentroidCoordSecondMoments().z = integral of (z-z0)^2 dm
where (x0,y0,z0) = centroid.
See Also: WorldCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to world coordinates.
These are simply the eigenvalues and eigenvectors of the woorld coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: CentroidCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about world coordinate axes.</summary>
            <returns>
Radii of gyration with respect to world coordinate system.
WorldCoordRadiiOfGyration().x = sqrt(integral of (y^2 + z^2) dm/M)
WorldCoordRadiiOfGyration().y = sqrt(integral of (z^2 + x^2) dm/M)
WorldCoordRadiiOfGyration().z = sqrt(integral of (z^2 + y^2) dm/M)
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about world coordinate axes.</summary>
            <returns>
Moments of inertia with respect to world coordinate system.
WorldCoordMomentsOfInertia().x = integral of (y^2 + z^2) dm
WorldCoordMomentsOfInertia().y = integral of (z^2 + x^2) dm
WorldCoordMomentsOfInertia().z = integral of (z^2 + y^2) dm
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the world coordinate second moments
are returned in a vector (m_world_xx,m_world_yy,m_world_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to world coordinate system.
WorldCoordSecondMoments().x = integral of x^2 dm
WorldCoordSecondMoments().y = integral of y^2 dm
WorldCoordSecondMoments().z = integral of z^2 dm
See Also: CentroidCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.WorldCoordFirstMoments">
            <summary>
If m_bValidFirstMoments is true, then the world coordinate first moments
are returned in a vector (m_world_x,m_world_y,m_world_z)
If m_bValidFirstMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
First moments with respect to world coordinate system.
WorldCoordFirstMoments().x = integral of x dm
WorldCoordFirstMoments().y = integral of y dm
WorldCoordFirstMoments().z = integral of z dm
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Volume">
            <summary>
Returns volume of the solid if the mass properties calculation was a volume calculation.
</summary>
            <returns>Volume of the solid if m_mass_type = 3 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Area">
            <summary>
Returns area of the surface or mesh if the mass properties calculation was an area calculation.
</summary>
            <returns>Area of the surface or mesh if m_mass_type = 2 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Length">
            <summary>
Returns length of the curve if the mass properties calculation was a length calculation.
</summary>
            <returns>Length of the curve if m_mass_type = 1 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Centroid">
            <summary>
Returns: Centroid of object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Sum(RMA.OpenNURBS.IOnMassProperties[])">
            <summary>Sum a list of mass properties together to get an aggregate mass.</summary>
            <param name="summands">[in] array of mass properties to add</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Sum(RMA.OpenNURBS.IOnMassProperties[],System.Boolean)">
            <summary>Sum a list of mass properties together to get an aggregate mass.</summary>
            <param name="summands">[in] array of mass properties to add</param>
            <param name="bAddTo">[in] if true, then the summands are added to the existing mass.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Prints a text description of the mass properties information.</summary>
            <param name="dump">[in] target for text dump information.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMassProperties.Create">
            <summary>
Set values to constructor defaults.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zx">
            <summary>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "zx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yz">
            <summary>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "yz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xy">
            <summary>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "xy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_zz">
            <summary>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "zz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_yy">
            <summary>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "yy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_ccs_xx">
            <summary>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "xx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zx">
            <summary>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "zx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yz">
            <summary>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "yz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xy">
            <summary>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "xy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_zz">
            <summary>
SECOND MOMENTS - with respect to world coordinate system
integral of "zz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_yy">
            <summary>
SECOND MOMENTS - with respect to world coordinate system
integral of "yy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_xx">
            <summary>
SECOND MOMENTS - with respect to world coordinate system
integral of "xx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_z_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_z">
            <summary>
FIRST MOMENTS - with respect to world coordinate system
integral of "z dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_y_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_y">
            <summary>
FIRST MOMENTS - with respect to world coordinate system
integral of "y dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_x_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_world_x">
            <summary>
FIRST MOMENTS - with respect to world coordinate system
integral of "x dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_z0">
            <summary>
CENTROID - in world coordinate system
= m_world_z / m_mass
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_y0">
            <summary>
CENTROID - in world coordinate system
= m_world_y / m_mass
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_x0">
            <summary>
CENTROID - in world coordinate system
= m_world_x / m_mass
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_mass_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_mass">
            <summary>
MASS - length, area, or volume of object
    = integral of "dm" over the object
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_bValidMass">
            <summary>
These flags are set to true if the calcluation was
successful.  If a flag is false, the corresponding
values should not be used.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMassProperties.m_mass_type">
            <summary>
Determines what type of "mass" is returned.
1 = length, 2 = area, 3 = volume
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMassProperties">
            <summary>
This class is used to returned results of mass properties calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to centroid coordinates.
These are simply the eigenvalues and eigenvectors of the centroid coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: WorldCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to centroid coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_ccs_xx m_ccs_xy m_ccs_xz
  m_ccs_xy m_ccs_yy m_ccs_yz
  m_ccs_xz m_ccs_yz m_ccs_zz
See Also: WorldCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about centroid coordinate axes.</summary>
            <returns>
Radii of gyration with respect to centroid coordinate system.
CentroidCoordRadiiOfGyration().x = sqrt(integral of ((y-y0)^2 + (z-z0)^2) dm/M)
CentroidCoordRadiiOfGyration().y = sqrt(integral of ((z-z0)^2 + (x-x0)^2) dm/M)
CentroidCoordRadiiOfGyration().z = sqrt(integral of ((z-z0)^2 + (y-y0)^2) dm/M)
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about centroid coordinate axes.</summary>
            <returns>
Moments of inertia with respect to centroid coordinate system.
WorldCoordMomentsOfInertia().x = integral of ((y-y0)^2 + (z-z0)^2) dm
WorldCoordMomentsOfInertia().y = integral of ((z-z0)^2 + (x-x0)^2) dm
WorldCoordMomentsOfInertia().z = integral of ((z-z0)^2 + (y-y0)^2) dm
where (x0,y0,z0) = centroid.
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.CentroidCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the centroid coordinate second
moments are returned in a vector (m_ccs_xx,m_ccs_yy,m_ccs_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to centroid coordinate system.
CentroidCoordSecondMoments().x = integral of (x-x0)^2 dm
CentroidCoordSecondMoments().y = integral of (y-y0)^2 dm
CentroidCoordSecondMoments().z = integral of (z-z0)^2 dm
where (x0,y0,z0) = centroid.
See Also: WorldCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordPrincipalMoments(System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@,System.Double@,RMA.OpenNURBS.On3dVector@)">
            <summary>
Calculates the principal moments and principal axes with repect to world coordinates.
These are simply the eigenvalues and eigenvectors of the woorld coordinate inertia matrix.
</summary>
            <param name="pxx">[out] principal moment</param>
            <param name="Ax">[out] principal axis for pxx</param>
            <param name="pyy">[out] principal moment</param>
            <param name="Ay">[out] principal axis for pyy</param>
            <param name="pzz">[out] principal moment</param>
            <param name="Az">[out] principal axis for pzz</param>
            <returns>
True if successful.
See Also: CentroidCoordPrincipalMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordIntertiaMatrix">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordIntertiaMatrix(RMA.OpenNURBS.OnMatrix)">
            <summary>
If moments are valid, then the 3x3 inertia matrix with respect to world coordinates is returned.
This matrix is sometimes called the "intertia tensor".
</summary>
            <param name="matrix">
[in] If you want to fill in an existing matrix, pass a pointer to that matrix.
Otherwise a matrix will be created and returned.
</param>
            <returns>
The inertia matrix or NULL if the moments are not valid.
  m_world_xx m_world_xy m_world_xz
  m_world_xy m_world_yy m_world_yz
  m_world_xz m_world_yz m_world_zz
See Also: CentroidCoordIntertiaMatrix
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordRadiiOfGyration">
            <summary>Calculates the radii of gyration about world coordinate axes.</summary>
            <returns>
Radii of gyration with respect to world coordinate system.
WorldCoordRadiiOfGyration().x = sqrt(integral of (y^2 + z^2) dm/M)
WorldCoordRadiiOfGyration().y = sqrt(integral of (z^2 + x^2) dm/M)
WorldCoordRadiiOfGyration().z = sqrt(integral of (z^2 + y^2) dm/M)
</returns>
            <remarks>
What is meant by "radii of gyration" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordMomentsOfInertia">
            <summary>Calculates the moments of inertia about world coordinate axes.</summary>
            <returns>
Moments of inertia with respect to world coordinate system.
WorldCoordMomentsOfInertia().x = integral of (y^2 + z^2) dm
WorldCoordMomentsOfInertia().y = integral of (z^2 + x^2) dm
WorldCoordMomentsOfInertia().z = integral of (z^2 + y^2) dm
</returns>
            <remarks>
What is meant by "moments of intertia" varies widely in textbooks and papers.
The values returned here are the integrals listed in the Returns section.
Some applications may want the values from WorldCoordSecondMoments() instead of the values returned here.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordSecondMoments">
            <summary>
If m_bValidSecondMoments is true, then the world coordinate second moments
are returned in a vector (m_world_xx,m_world_yy,m_world_zz)
If m_bValidSecondMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
Second moments with respect to world coordinate system.
WorldCoordSecondMoments().x = integral of x^2 dm
WorldCoordSecondMoments().y = integral of y^2 dm
WorldCoordSecondMoments().z = integral of z^2 dm
See Also: CentroidCoordSecondMoments
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.WorldCoordFirstMoments">
            <summary>
If m_bValidFirstMoments is true, then the world coordinate first moments
are returned in a vector (m_world_x,m_world_y,m_world_z)
If m_bValidFirstMoments is false, then (0,0,0) is returned.
</summary>
            <returns>
First moments with respect to world coordinate system.
WorldCoordFirstMoments().x = integral of x dm
WorldCoordFirstMoments().y = integral of y dm
WorldCoordFirstMoments().z = integral of z dm
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Volume">
            <summary>
Returns volume of the solid if the mass properties calculation was a volume calculation.
</summary>
            <returns>Volume of the solid if m_mass_type = 3 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Area">
            <summary>
Returns area of the surface or mesh if the mass properties calculation was an area calculation.
</summary>
            <returns>Area of the surface or mesh if m_mass_type = 2 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Length">
            <summary>
Returns length of the curve if the mass properties calculation was a length calculation.
</summary>
            <returns>Length of the curve if m_mass_type = 1 and zero otherwise.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Centroid">
            <summary>
Returns: Centroid of object.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMassProperties.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>Prints a text description of the mass properties information.</summary>
            <param name="dump">[in] target for text dump information.</param>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zx">
            <summary>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "zx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yz">
            <summary>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "yz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xy">
            <summary>
PRODUCT MOMENTS - with respect to centroid coordinate system
integral of "xy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_zz">
            <summary>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "zz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_yy">
            <summary>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "yy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_ccs_xx">
            <summary>
The "centroid coordinate system" (ccs) is the
coordinate system with origin at the centroid and
axes parallel to the world coordinate axes.
SECOND MOMENTS - with respect to centroid coordinate system
integral of "xx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zx">
            <summary>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "zx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yz">
            <summary>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "yz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xy">
            <summary>
PRODUCT MOMENTS - with respect to world coordinate system
integral of "xy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zz_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_zz">
            <summary>
SECOND MOMENTS - with respect to world coordinate system
integral of "zz dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yy_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_yy">
            <summary>
SECOND MOMENTS - with respect to world coordinate system
integral of "yy dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xx_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_xx">
            <summary>
SECOND MOMENTS - with respect to world coordinate system
integral of "xx dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_z_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_z">
            <summary>
FIRST MOMENTS - with respect to world coordinate system
integral of "z dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_y_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_y">
            <summary>
FIRST MOMENTS - with respect to world coordinate system
integral of "y dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_x_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_world_x">
            <summary>
FIRST MOMENTS - with respect to world coordinate system
integral of "x dm" over the length/area/volume
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_z0">
            <summary>
CENTROID - in world coordinate system
= m_world_z / m_mass
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_y0">
            <summary>
CENTROID - in world coordinate system
= m_world_y / m_mass
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_x0">
            <summary>
CENTROID - in world coordinate system
= m_world_x / m_mass
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_mass_err">
            <summary>
uncertainty in calculation
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_mass">
            <summary>
MASS - length, area, or volume of object
    = integral of "dm" over the object
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_bValidMass">
            <summary>
These flags are set to true if the calcluation was
successful.  If a flag is false, the corresponding
values should not be used.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMassProperties.m_mass_type">
            <summary>
Determines what type of "mass" is returned.
1 = length, 2 = area, 3 = volume
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMassProperties">
            <summary>
This class is used to returned results of mass properties calculations.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnRead3dmBufferArchive.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
Construct an ON_BinaryArchive for reading information from a memory buffer.
</summary>
            <param name="buffer">[in] memory buffer containing binary archive</param>
            <param name="archive_3dm_version">[in] (1,2,3,4 or 5)</param>
            <param name="archive_opennurbs_version">[in] YYYYMMDDn</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryFile.EnableMemoryBuffer">
            <summary>
To use custom memory buffering instead of relying on fread()/fwrite()'s
built in buffering, call EnableMemoryBuffer() with the buffer size immediately
after constructing the ON_BinaryFile.  There appear to be enough bugs in
existing Windows NT/2000 NETWORK I/O that using this hack will speed up
I/O by factors of 10 to 100.

This version uses a default capacity of 16384
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryFile.EnableMemoryBuffer(System.Int32)">
            <summary>
To use custom memory buffering instead of relying on fread()/fwrite()'s
built in buffering, call EnableMemoryBuffer() with the buffer size immediately
after constructing the ON_BinaryFile.  There appear to be enough bugs in
existing Windows NT/2000 NETWORK I/O that using this hack will speed up
I/O by factors of 10 to 100.
</summary>
            <param name="buffer_capacity">
capacity of memory buffer (default is 16384)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryFile.SeekFromEnd(System.Int32)">
            <summary>
fseek from end (since the file has an end)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Dump3dmChunk(RMA.OpenNURBS.OnTextLog@)">
            <summary>
Expert user function for studying contents of a file. The primary use is as an aid to help
dig through files that have been damaged (bad disks, transmission errors, etc.) If an error
is found, a line that begins with the word "ERROR" is printed.
</summary>
            <param name="text_log">[in] place to print informtion</param>
            <returns>0 if something went wrong, otherwise the typecode of the chunk that was just studied.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Dump3dmChunk(RMA.OpenNURBS.OnTextLog@,System.Int32)">
            <summary>
Expert user function for studying contents of a file. The primary use is as an aid to help
dig through files that have been damaged (bad disks, transmission errors, etc.) If an error
is found, a line that begins with the word "ERROR" is printed.
</summary>
            <param name="text_log">[in] place to print informtion</param>
            <param name="recursion_depth">[in] simply a counter to aid in debugging.</param>
            <returns>0 if something went wrong, otherwise the typecode of the chunk that was just studied.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.FindTableInDamagedArchive(System.UInt32,System.UInt32,System.Guid,System.Int32)">
            <summary>
Expert user function for reading damaged files. The search starts at the beginning of the file.
</summary>
            <param name="tcode_table">[in] typecode of the table</param>
            <param name="tcode_record">[in] typecode of the record</param>
            <param name="class_uuid">[in] id of the opennurbs class in the record</param>
            <param name="min_length_data">[in] minimum size of the opennurbs class data</param>
            <returns>
True if the table start is found. In this case the current position of the archive
is at the start of the table and the standared BeginRead3dm...Table() function can be used.
False if the table start is not found.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.GetCurrentChunk(RMA.OpenNURBS.On3DM_CHUNK@)">
            <summary>Expert user function for reading damaged files.</summary>
            <param name="chunk">[out] current chunk.</param>
            <returns>Level of the chunk or 0 if there is no current chunk.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ArchiveStartOffset">
            <summary>
When a 3dm archive is saved from an MFC application that supports Windows linking/embedding,
the first 5kb to 1mb of the file contains information that is put there by MFC. ArchiveStartOffset()
returns the offset into the file where the 3dm archive actually begins. The call to ON_BinaryArchive::Read3dmStartSection()
calculates this offset and stores the value in m_3dm_start_section_offset.
</summary>
            <returns>Offset into the binary "file" where the actual 3dm archive begins.</returns>
            <remarks>Generally, this value can be ignored. This function is a diagnostice tool that is used to analyzed damaged files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ArchiveOpenNURBSVersion">
            <summary>
If a 3dm archive is being read, then this is the version of openNURBS that was used to write the archive.
This value is only available after ON_BinaryArchive::Read3dmProperties is called.
</summary>
            <returns>
Version of openNURBS used to write the archive. The openNURBS version is the value returned by ON::Version.
</returns>
            <remarks>This value is rarely needed. You probably want to use ON_BinaryArchive::Archive3dmVersion.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Archive3dmVersion">
            <summary>
Low level tool to read user data and attach it to the object. This function should never be called directly. Parameters: object - [in/out] Returns: True if successful.
</summary>
            <summary>
If a 3dm archive is being read or written, then this is the version of the 3dm archive format (1, 2, 3, 4 or 5).
</summary>
            <returns>
0 a 3dm archive is not being read/written
1 a version 1 3dm archive is being read/written
2 a version 2 3dm archive is being read/written
3 a version 3 3dm archive is being read/written
4 a version 4 3dm archive is being read/written
5 a version 5 3dm archive is being read/written
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteObjectUserData(RMA.OpenNURBS.OnUserData)">
            <summary>
Low level tool to writes user data attached to the object. This function should never be called directly. Parameters: object - [in] Returns: True if successful.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmChunkVersion(System.Int32@,System.Int32@)">
            <summary>
A chunk version is a single byte that encodes a major.minor 
version number.  Useful when creating I/O code for 3dm chunks
that may change in the future.  Increment the minor version 
number if new information is added to the end of the chunk. 
Increment the major version if the format of the chunk changes
in some other way.
</summary>
            <param name="major">0 to 15</param>
            <param name="minor">0 to 16</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmChunkVersion(System.Int32,System.Int32)">
            <summary>
A chunk version is a single byte that encodes a major.minor 
version number.  Useful when creating I/O code for 3dm chunks
that may change in the future.  Increment the minor version 
number if new information is added to the end of the chunk. 
Increment the major version if the format of the chunk changes
in some other way.
</summary>
            <param name="major">0 to 15</param>
            <param name="minor">0 to 16</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Seek3dmChunkFromCurrentPosition(System.UInt32)">
            <summary>
beginning at the current position, search portion of archive
included in active chunk for the start of a subchunk with the
specified type.
if true is returned, then the position is set so the next call to
BeginRead3dmChunk() will read a chunk with the specified typecode
</summary>
            <param name="typecode">typecode from opennurbs_3dm.h</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Seek3dmChunkFromStart(System.UInt32)">
            <summary>
beginning at the start of the active chunk, search portion of
archive included in active chunk for the start of a subchunk 
with the specified type.
if true is returned, then the position is set so the next call to
BeginRead3dmChunk() will read a chunk with the specified typecode
</summary>
            <param name="typecode">typecode from opennurbs_3dm.h</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.PeekAt3dmChunkType(System.UInt32@,System.Int32@)">
            <summary>does not change file position</summary>
            <param name="typecode">typecode from opennurbs_3dm.h</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmGoo(RMA.OpenNURBS.On3dmGoo@)">
            <summary>Call to read "goo"</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginReadDictionaryEntry(System.Int32@,System.String@)">
            <summary>Begin reading a dictionary entry.</summary>
            <param name="de_type">[out]</param>
            <param name="entry_name">[out]</param>
            <returns>
0: serious IO error
1: success.. read information and then call EndReadDictionaryEntry()
2: at end of dictionary
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginWriteDictionaryEntry(System.Int32,System.String)">
            <summary>Begins writing a dictionary entry.</summary>
            <param name="de_type" />
            <param name="entry_name" />
            <returns>
true  = Entry header was written and you must call EndWriteDictionary() after writing the entry data.
false = Failed to write entry header.  Do not call EndWriteDictionary().
</returns>
            <remarks>
Begins a new chunk with tcode TCODE_DICTIONARY_ENTRY, then writes the int, and then writes the string.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginWriteDictionary(System.Guid,System.UInt32,System.String)">
            <summary>Begins writing a dictionary.</summary>
            <param name="dictionary_id">[in]</param>
            <param name="version">[in] It is suggested that you use YYYYMMDD as the version number.</param>
            <param name="dictionary_name">[in] you may pass NULL</param>
            <remarks>
Begins a new chunk with tcode TCODE_DICTIONARY and then writes
a TCODE_DICTIONARY_ID chunk containing the id, version and name.
After calling this function, you may either write entries by calling
BeginWriteDictionaryEntry(); 
write entry definition...
EndWriteDictionaryEntry();
or you may finish writing the dictionay by calling
EndWriteDictionary();
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EndRead3dmChunk">
            <summary>Calling this will skip rest of stuff in chunk if it was only partially read.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginRead3dmChunk(System.UInt32,System.Int32@,System.Int32@)">
            <summary>Begins reading a chunk that must be in the archive at this location.</summary>
            <param name="expected_tcode">[in] chunk's typecode from opennurbs_3dm.h</param>
            <param name="major_version">[out]</param>
            <param name="minor_version">[out]</param>
            <returns>
True if beginning of the chunk was read. In this case you must call EndRead3dmChunk(),
even if something goes wrong while you attempt to read the interior of the chunk.
False if the chunk did not exist at the current location in the file.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginRead3dmChunk(System.UInt32@,System.Int32@)">
            <summary>
When the end of the 3dm file is reached, BeginReadChunk() will
return true with a typecode of TCODE_ENDOFFILE.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmGoo(RMA.OpenNURBS.IOn3dmGoo)">
            <summary>call to write "goo"</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EndWrite3dmChunk">
            <summary>updates length in chunk header</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginWrite3dmChunk(System.UInt32,System.Int32,System.Int32)">
            <summary>Begins writing a chunk.</summary>
            <param name="tcode">[in] chunk's typecode from opennurbs_3dm.h. This cannot be a short tcode.</param>
            <param name="major_version">[in] ( &gt;= 1)</param>
            <param name="minor_version">[in] ( &gt;= 0 )</param>
            <returns>
True if input was valid and chunk was started. In this case You must call EndWrite3dmChunk(),
even if something goes wrong while you attempt to write the contents of the chunk.
False if input was not valid or the write failed.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginWrite3dmChunk(System.UInt32,System.Int32)">
            <summary>
Writes a chunk header containing 4 byte typecode and 4 byte value.

Low level tools to  Write/Read chunks. See opennurbs_3dm.h for details
about the structure of chunks. Every chunk must begin with a call to
BeginWrite/ReadChunk(). If BeginWriteChunk()/BeginReadChunk() returns
true, then you must call EndWrite/ReadChunk() or cease using the archive.
</summary>
            <param name="typecode">[in] a TCODE_* number from opennurbs_3dm.h</param>
            <param name="value">
[in] if (typecode AND TCODE_SHORT) is nonzero, then this is the value to be saved.
Otherwise, pass a zero and the EndWrite3dmChunk() call will store the length
of the chunk.
</param>
            <returns>true if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmEndMark(System.UInt64@)">
            <summary>
Checks for a TCODE_ENDOFFILE chunk at the current position.
If it finds one, it reads it and returns the number of bytes in the archive.
Comparing this number with the current file position can help detect files
that have been damaged by loosing sections.
</summary>
            <param name="sizeof_archive">[out] number of bytes written to archive</param>
            <returns>
true if successful, false if unable to find or read a TCODE_ENDOFFILE chunk.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmEndMark">
            <summary>
Writes a TCODE_ENDOFFILE chunk that contains the number of bytes in the archive.
</summary>
            <returns>true if successful, false if unable to write to archive.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmAnonymousUserTable(RMA.OpenNURBS.On3dmGoo@)">
            <summary>
Use Read3dmAnonymousUserTableRecord() if you don't know how to decipher 
the contents of a user table but you need to rewrite it for some reason.
If you simple want to skip over the table, just call EndRead3dmUserTable().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BeginRead3dmUserTable(System.Guid@)">
            <summary>
BeginRead3dmUserTable returns false when there are no more user tables
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmAnonymousUserTable(RMA.OpenNURBS.IOn3dmGoo)">
            <summary>
Use Write3dmAnonymousUserTable() to put back what Read3dmAnonymousUserTable() read.
(Generally a plugin or some other app will be called to write
it's information to the archive.)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmHistoryRecord(RMA.OpenNURBS.OnHistoryRecord@)">
            <returns>
0 at end of object table
1 if object is read
-1 if file is corrupt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmObject(RMA.OpenNURBS.OnObject@,RMA.OpenNURBS.On3dmObjectAttributes@,System.UInt32)">
            <returns>
0 at end of object table
1 if object is read
2 if object is skipped because it does not match filter
-1 if file is corrupt
</returns>
            <param name="object">object returned here (NULL if skipped)</param>
            <param name="attributes">optional - if NOT NULL, object attributes are returned here</param>
            <param name="object_filter">
optional filter made by setting ON::object_type bits
set to 0 if no filter is to be applied
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmObject(RMA.OpenNURBS.IOnObject,RMA.OpenNURBS.IOn3dmObjectAttributes)">
            <param name="attributes">optional, may be null</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmInstanceDefinition(RMA.OpenNURBS.OnInstanceDefinition@)">
            <summary>Reads instance definitions from instance defintion table.</summary>
            <param name="idef">
If an instance defintion is read, an instance defintion is created by calling new 
ON_InstanceDefinition(), initialized with values stored in the archive, and a
pointer to the new instance defintion is returned
</param>
            <returns>
0  at the end of the instance defintion table
1  instance defintion was successfully read
-1 archive is corrupt at this point
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmLight(RMA.OpenNURBS.OnLight@,RMA.OpenNURBS.On3dmObjectAttributes@)">
            <returns>
returns 0 at end of light table
1 light successfully read
-1 if file is corrupt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmDimStyle(RMA.OpenNURBS.OnDimStyle@)">
            <summary>
Reads annotation dimension styles from dimension style table.
If the dimension style definition is read, a dimension style
is created by calling new ON_DimStyle(), initialized with
values stored in the archive, and returned.
</summary>
            <param name="ppDimStyle">
If the dimstyle definition is read, a dimstyle is created by
calling new ON_DimStyle(), initialized with values stored in
the archive, and a pointer to the new dimstyle is returned in *ppDimStyle.
</param>
            <returns>
0     at the end of the dimension style table
1     dimension style definition was successfully read
-1    archive is corrupt at this point
</returns>
            <remarks>
Calls to Read3dmDimStyle need to be bracketed by calls
to BeginRead3dmDimStyleTable() / EndRead3dmDimStyleTable().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmFont(RMA.OpenNURBS.OnFont@)">
            <summary>
Reads fonts from font table. If the font definition is read, a font
is created by calling new ON_Font(), initialized with values stored
in the archive, and returned.
</summary>
            <param name="ppFont">
If the font definition is read, a font is created by calling new ON_Font(),
initialized with values stored in the archive, and a pointer to the new
font is returned in *ppFont.
</param>
            <returns>
0     at the end of the font table
1     font definition was successfully read
-1    archive is corrupt at this point
</returns>
            <remarks>
Calls to Read3dmFont need to be bracketed by calls
to BeginRead3dmFontTable() / EndRead3dmFontTable().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmGroup(RMA.OpenNURBS.OnGroup@)">
            <summary>
Reads groups from group table.  If the group definition is read,
a group is created by calling new ON_Group(), initialized with
values stored in the archive, and returned.
</summary>
            <param name="ppGroup">
If the group definition is read, a group is created by calling
new ON_Group(), initialized with values stored in the archive,
and a pointer to the new group is returned in *ppGroup.
</param>
            <returns>
0     at the end of the group table
1     group definition was successfully read
-1    archive is corrupt at this point
</returns>
            <remarks>
Calls to Read3dmGroup need to be bracketed by calls
to BeginRead3dmGroupTable() / EndRead3dmGroupTable().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmMaterial(RMA.OpenNURBS.OnMaterial@)">
            <returns>returns 0 at end of table</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmTextureMapping(RMA.OpenNURBS.OnTextureMapping@)">
            <returns>returns 0 at end of table</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmBitmap(RMA.OpenNURBS.OnBitmap@)">
            <returns>
0 at end of light table
1 bitmap successfully read
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Read3dmStartSection(System.Int32@,System.String@)">
            <param name="version">returns version 1-5</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Write3dmStartSection(System.Int32,System.String)">
            <param name="version">1, 2, 3, 4, or 5</param>
            <param name="app_name">
NULL or ASCII string with application name, etc.
This information is primarily used when debugging files
that contain problems.  McNeel and Associates stores
application name, application version, compile date, 
OS in use when file was written.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSaveUserData">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSaveUserData(System.Boolean)">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmAnalysisMeshes">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmAnalysisMeshes(System.Boolean)">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmRenderMeshes">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableSave3dmRenderMeshes(System.Boolean)">
            <summary>returns previous state</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteObject(RMA.OpenNURBS.IOnObject)">
            <summary>writes object definition</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadObject(RMA.OpenNURBS.OnObject@)">
            <summary>Reads and object from a 3dm archive.</summary>
            <param name="object">
[in] The value of object.ON_ClassId()-&gt;Uuid() must exactly match the class uuid
in of the next object in the archive.
</param>
            <returns>
0: failure - unable to read object because of file IO problems.
1: success
2: unable to read object because the class id in the archive did not match pObject-&gt;ClassId.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadOnObject(RMA.OpenNURBS.OnObject@)">
            <summary>Reads and object from a 3dm archive</summary>
            <param name="ppObject">
[out]  object is allocated and a pointer to the allocated object is returned
</param>
            <returns>
0: failure - unable to read object because of file IO problems
1: success
3: unable to read object because it's UUID is not registered
this could happen in cases where old code is attempting to read
new objects.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteString(System.String)">
            <summary>
All times are stored in universal coordinated time
( a.k.a GMT, UCT ).  Use ANSI C time() and gmtime() calls.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteDouble(System.Double)">
            <summary>Write a single double</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteFloat(System.Single)">
            <summary>Write a single float</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteBigTime(System.Int64)">
            <summary>UCT seconds since 1 January 1970 (64 bits)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteBigSize(System.UInt32)">
            <summary>64 bits</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteSize(System.UInt32)">
            <summary>Write a single size_t</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteLong(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>Write a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteLong(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>Write a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteInt(System.UInt32)">
            <summary>Write a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteInt(System.Int32)">
            <summary>Write a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteShort(System.UInt16)">
            <summary>Write a single 16 bit unsigned short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteShort(System.Int16)">
            <summary>Write a single 16 bit short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteChar(System.Byte)">
            <summary>Write a single 8 bit unsigned char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteChar(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>Write a single 8 bit char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadAnsiString(System.String@)">
            <summary>
All times are stored in coordinated universal time
( a.k.a GMT, UTC ).  Use ANSI C time() and gmtime() calls.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadDouble(System.Double@)">
            <summary>Read a single double</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadFloat(System.Single@)">
            <summary>Read a single float</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadBigTime(System.Int64@)">
            <summary>UCT seconds since 1 January 1970 (64 bits)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadBigSize(System.UInt32@)">
            <summary>64 bits</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadSize(System.UInt32@)">
            <summary>Read a single size_t</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadLong(System.UInt32!System.Runtime.CompilerServices.IsLong@)">
            <summary>Read a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadLong(System.Int32!System.Runtime.CompilerServices.IsLong@)">
            <summary>Read a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadInt(System.UInt32@)">
            <summary>Read a single 32 bit unsigned integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadInt(System.Int32@)">
            <summary>Read a single 32 bit integer</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadShort(System.UInt16@)">
            <summary>Read a single 16 bit unsigned short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadShort(System.Int16@)">
            <summary>Read a single 16 bit short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadChar(System.Byte@)">
            <summary>Read a single 8 bit unsigned char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadChar(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte@)">
            <summary>Read a single 8 bit char</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteCompressedBuffer(System.Byte[])">
            <summary>Compress buffer and write the compressed information to the archive.</summary>
            <param name="inbuffer">[in] uncompressed buffer</param>
            <returns>True if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteCompressedBuffer(System.UInt32,System.IntPtr)">
            <summary>Compress buffer and write the compressed information to the archive.</summary>
            <param name="sizeof_inbuffer">[in] size of the uncompressed buffer in bytes</param>
            <param name="inbuffer">[in] uncompressed buffer</param>
            <returns>True if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.EnableCRCCalculation(System.Boolean)">
            <summary>
Expert user function to control CRC calculation while reading and writing.
Typically this is used when seeking around and reading/writing information
in non-serial order.
</summary>
            <returns>
Current state of CRC calculation.  Use the returned value to restore the
CRC calculation setting after you are finished doing your fancy pants expert IO.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteBytes(System.Byte[])">
            <summary>must fail if mode is not write or readwrite</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadBytes(System.Byte[]@)">
            <summary>must fail if mode is not read or readwrite</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.BadCRCCount">
            <summary>number of chunks read with bad CRC</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.Endian">
            <returns>Endian-ness of the cpu reading this file.</returns>
            <remarks>3dm files are alwasy saved with little endian byte order.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.WriteMode">
            <summary>true if writing is permitted</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.ReadMode">
            <summary>true if reading is permitted</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.AtEnd">
            <summary>true if at end of file</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.SeekFromStart(System.UInt64)">
            <summary>seek from current position ( like fseek( ,SEEK_SET) )</summary>
            <param name="byte_offset">( &gt;= 0 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.SeekFromStart(System.UInt32)">
            <summary>seek from current position ( like fseek( ,SEEK_SET) )</summary>
            <param name="byte_offset">( &gt;= 0 )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.SeekFromCurrentPosition(System.Int32)">
            <summary>seek from current position ( like fseek( ,SEEK_CUR) )</summary>
            <param name="byte_offset">( &gt;= -CurrentPostion() )</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBinaryArchive.CurrentPosition">
            <summary>current offset (in bytes) into archive ( like ftell() )</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnBinaryArchive">
            <summary>use for generic serialization of binary data</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.GetCurrentChunk(RMA.OpenNURBS.On3DM_CHUNK@)">
            <summary>Expert user function for reading damaged files.</summary>
            <param name="chunk">[out] current chunk.</param>
            <returns>Level of the chunk or 0 if there is no current chunk.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.ArchiveStartOffset">
            <summary>
When a 3dm archive is saved from an MFC application that supports Windows linking/embedding,
the first 5kb to 1mb of the file contains information that is put there by MFC. ArchiveStartOffset()
returns the offset into the file where the 3dm archive actually begins. The call to ON_BinaryArchive::Read3dmStartSection()
calculates this offset and stores the value in m_3dm_start_section_offset.
</summary>
            <returns>Offset into the binary "file" where the actual 3dm archive begins.</returns>
            <remarks>Generally, this value can be ignored. This function is a diagnostice tool that is used to analyzed damaged files.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.ArchiveOpenNURBSVersion">
            <summary>
If a 3dm archive is being read, then this is the version of openNURBS that was used to write the archive.
This value is only available after ON_BinaryArchive::Read3dmProperties is called.
</summary>
            <returns>
Version of openNURBS used to write the archive. The openNURBS version is the value returned by ON::Version.
</returns>
            <remarks>This value is rarely needed. You probably want to use ON_BinaryArchive::Archive3dmVersion.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.Archive3dmVersion">
            <summary>
If a 3dm archive is being read or written, then this is the version of the 3dm archive format (1, 2, or 3).
</summary>
            <returns>
0  a 3dm archive is not being read/written
1  a version 1 3dm archive is being read/written
2  a version 2 3dm archive is being read/written
3  a version 3 3dm archive is being read/written
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.BadCRCCount">
            <summary>
number of chunks read with bad CRC
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.Endian">
            <returns>Endian-ness of the cpu reading this file.</returns>
            <remarks>3dm files are alwasy saved with little endian byte order.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.WriteMode">
            <summary>
true if writing is permitted
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.ReadMode">
            <summary>
true if reading is permitted
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.AtEnd">
            <summary>true if at end of file</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBinaryArchive.CurrentPosition">
            <summary>current offset (in bytes) into archive ( like ftell() )</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBinaryArchive">
            <summary>use for generic serialization of binary data</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_do_crc32">
            <summary>
32 bit CRC
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_do_crc16">
            <summary>
16 bit CRC using CCITT polynomial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_do_length">
            <summary>
true if chunk is a long chunk with length
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_typecode">
            <summary>
file position of first byte after chunk's length.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.On3DM_CHUNK.m_offset">
            <summary>
In read or write_using_fseek mode, this is the
file position of first byte after chunk's length.
In write_using_buffer mode, this of the m_buffer[]
position of first byte after chunk's length.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_do_crc32">
            <summary>
32 bit CRC
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_do_crc16">
            <summary>
16 bit CRC using CCITT polynomial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_do_length">
            <summary>
true if chunk is a long chunk with length
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_typecode">
            <summary>
file position of first byte after chunk's length.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOn3DM_CHUNK.m_offset">
            <summary>
In read or write_using_fseek mode, this is the
file position of first byte after chunk's length.
In write_using_buffer mode, this of the m_buffer[]
position of first byte after chunk's length.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.ChangeMappingChannel(System.Guid@,System.Int32,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="old_mapping_channel_id">[in]</param>
            <param name="new_mapping_channel_id">[in]</param>
            <returns>True if a matching mapping channel was found and changed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.DeleteMappingChannel(System.Guid@,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>
True if a matching mapping channel was deleted.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.DeleteMappingChannel(System.Guid@,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <returns>
True if a matching mapping channel was deleted.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.AddMappingChannel(System.Guid@,System.Int32,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>
True if the mapping channel was added or a pefect match already existed.
False if a mapping channel with a different mapping_id already exists for this plug-in and channel.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.DeleteMappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
If a mapping ref exists, it is returned. Otherwise one is added.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.AddMappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
If a mapping ref exists, it is returned. Otherwise one is added.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.MappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
A pointer to the plug-in's mapping reference, if there is one. Otherwise NULL is returned.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnObjectRenderingAttributes.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Update mapping channel transformations.</summary>
            <param name="xform">[in] Transformation applied to parent object.</param>
            <returns>
True is successful.
False if there are mapping channels and xform cannot be inverted.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjectRenderingAttributes.m_bReceivesShadows">
            <summary>default is true</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjectRenderingAttributes.m_bCastsShadows">
            <summary>default is true</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnObjectRenderingAttributes.m_mappings">
            <summary>
Use AddMappingRef() or AddMappingChannel() if you 
want to add an element to this array.
Every mapping ref in this array must have
a distinct value of ON_MappingRef.m_plugin_id.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Guid@)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjectRenderingAttributes.MappingChannel(System.Guid@,System.Int32)">
            <param name="plugin_id">[in]</param>
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnObjectRenderingAttributes.MappingRef(System.Guid@)">
            <param name="plugin_id">[in]</param>
            <returns>
A pointer to the plug-in's mapping reference, if there is one. Otherwise NULL is returned.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjectRenderingAttributes.m_bReceivesShadows">
            <summary>default is true</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjectRenderingAttributes.m_bCastsShadows">
            <summary>default is true</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnObjectRenderingAttributes.m_mappings">
            <summary>
Use AddMappingRef() or AddMappingChannel() if you 
want to add an element to this array.
Every mapping ref in this array must have
a distinct value of ON_MappingRef.m_plugin_id.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMaterialRef.#ctor">
            <summary>
If m_material_id = ON_MaterialRef::material_from_layer,
then the object's layer determine the material.
See ON::material_from_layer.
static const ON_UUID material_from_layer; // TOD0 - remove this
If m_material_id = ON_MaterialRef::material_from_layer,
then the object's parent determine the material.
See ON::material_from_parent.
static const ON_UUID material_from_parent; // TODO - remove this
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_backface_index">
            <summary>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_index">
            <summary>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_backface_id">
            <summary>
If nil, then m_material_id is used for front and back faces
Identifies an ON_Material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_material_id">
            <summary>
Identifies an ON_Material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMaterialRef.m_plugin_id">
            <summary>
Identifies a rendering plugin
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_backface_index">
            <summary>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_index">
            <summary>
RUNTIME material table index for m_material_id.
This value is not saved in files.  If -1, then it
needs to be set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_backface_id">
            <summary>
If nil, then m_material_id is used for front and back faces
Identifies an ON_Material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_material_id">
            <summary>
Identifies an ON_Material
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMaterialRef.m_plugin_id">
            <summary>
Identifies a rendering plugin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.ChangeMappingChannel(System.Int32,System.Int32)">
            <param name="old_mapping_channel_id">[in]</param>
            <param name="new_mapping_channel_id">[in]</param>
            <returns>True if a matching mapping channel was found and changed.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.DeleteMappingChannel(System.Guid@)">
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>True if a matching mapping channel was deleted.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.DeleteMappingChannel(System.Int32)">
            <param name="mapping_channel_id">[in]</param>
            <returns>True if a matching mapping channel was deleted.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.AddMappingChannel(System.Int32,System.Guid@)">
            <param name="mapping_channel_id">[in]</param>
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>
True if the mapping channel was added or a pefect match already existed.
False if a mapping channel with a different mapping_id already exists for this plug-in and channel.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.MappingChannel(System.Guid@)">
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnMappingRef.MappingChannel(System.Int32)">
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingRef.m_mapping_channels">
            <summary>
Use AddMappingChannel() if you  want to add an 
element to this array.
Every mapping channel in this array must have
a distinct value of ON_MappingChannel.m_mapping_channel_id
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingRef.m_plugin_id">
            <summary>
Identifies a rendering plugin
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMappingRef">
            <summary>
ON_3dmObjectAttributes uses ON_MaterialRef to record which
rendering material and mappings a rendering plug-in wants to 
use.  This allows different rendering plug-ins to have different 
materials on the same object.  The values of
ON_3dmObjectAttributes.m_material_index and 
ON_3dmObjectAttributes.m_matrial_source reflect the settings
of the renderer that is currently active.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingRef.MappingChannel(System.Guid@)">
            <param name="mapping_id">[in] ON_TextureMapping id</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMappingRef.MappingChannel(System.Int32)">
            <param name="mapping_channel_id">[in]</param>
            <returns>A pointer to the plug-in's mapping channel, if there is one. Otherwise NULL is returned.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingRef.m_mapping_channels">
            <summary>
Use AddMappingChannel() if you  want to add an 
element to this array.
Every mapping channel in this array must have
a distinct value of ON_MappingChannel.m_mapping_channel_id
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingRef.m_plugin_id">
            <summary>
Identifies a rendering plugin
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMappingRef">
            <summary>
ON_3dmObjectAttributes uses ON_MaterialRef to record which
rendering material and mappings a rendering plug-in wants to 
use.  This allows different rendering plug-ins to have different 
materials on the same object.  The values of
ON_3dmObjectAttributes.m_material_index and 
ON_3dmObjectAttributes.m_matrial_source reflect the settings
of the renderer that is currently active.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_object_xform">
            <summary>
The default value of m_object_xform is the identity.
When an object that uses this mapping is transformed
by "T", m_object_xform is updated using the formula
m_object_xform = T*m_object_xform.  If texture coordinates
are lost and need to be recalculated and m_object_xform
is not the identity, then m_object_xform should be passed
to ON_TextureMapping::Evaluate() as the mesh_xform parameter.
When validating mapping coordinates, m_object_xform itself 
be passed to HasMatchingTextureCoordinates() as the
object_transform parameter.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_mapping_channel_id">
            <summary>
ON_Texture's with a matching m_mapping_channel_id value
use the mapping identified by m_mapping_id.  This id
must be &gt; 0 and &lt;= 2147483647 (0x7FFFFFFF)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_mapping_index">
            <summary>
RUNTIME textrure mapping table index.
If -1, it needs to be set.  This value is not saved int files.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnMappingChannel.m_mapping_id">
            <summary>
Identifies an ON_TextureMapping
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnMappingChannel">
            <summary>
ON_3dmObjectAttributes uses ON_MappingChannel to record 
which texture mapping function to use when applying a texture
with a matching mapping channel id.
When an object is rendered, if the material has textures and
ON_Texture::m_mapping_channel_id = ON_MappingChannel::m_mapping_channel_id,
then the mapping with id m_mapping_id is used to map the texture.
Otherwise, the mesh m_T[] texture coordinates are used to
apply the texture.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_object_xform">
            <summary>
The default value of m_object_xform is the identity.
When an object that uses this mapping is transformed
by "T", m_object_xform is updated using the formula
m_object_xform = T*m_object_xform.  If texture coordinates
are lost and need to be recalculated and m_object_xform
is not the identity, then m_object_xform should be passed
to ON_TextureMapping::Evaluate() as the mesh_xform parameter.
When validating mapping coordinates, m_object_xform itself 
be passed to HasMatchingTextureCoordinates() as the
object_transform parameter.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_mapping_channel_id">
            <summary>
ON_Texture's with a matching m_mapping_channel_id value
use the mapping identified by m_mapping_id.  This id
must be &gt; 0 and &lt;= 2147483647 (0x7FFFFFFF)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_mapping_index">
            <summary>
RUNTIME textrure mapping table index.
If -1, it needs to be set.  This value is not saved int files.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMappingChannel.m_mapping_id">
            <summary>
Identifies an ON_TextureMapping
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnMappingChannel">
            <summary>
ON_3dmObjectAttributes uses ON_MappingChannel to record 
which texture mapping function to use when applying a texture
with a matching mapping channel id.
When an object is rendered, if the material has textures and
ON_Texture::m_mapping_channel_id = ON_MappingChannel::m_mapping_channel_id,
then the mapping with id m_mapping_id is used to map the texture.
Otherwise, the mesh m_T[] texture coordinates are used to
apply the texture.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.Print(System.String)">
            <summary>Print an unformatted UNICODE string of any length.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.PrintWrappedText(System.String)">
            <summary>line length = 60</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.SetIndentSize(System.Int32)">
            <summary>
0: one tab per indent
&gt;0: number of spaces per indent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.IndentSize">
            <summary>
0: one tab per indent
&gt;0: number of spaces per indent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.SetDoubleFormat(System.String)">
            <summary>
Description: Create a text log that dumps to a string. Parameters: s - [in] String that must exist as long as the text log is in use.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.#ctor(RMA.OpenNURBS.OnFileHandle)">
            <summary>Create a text log that dumps to an ASCII file.</summary>
            <param name="fp">
[in] Pointer to an open ASCII text file.  The file  pointer must
remain valid as long as the text log is in use.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.#ctor(System.IO.TextWriter)">
            <summary>Create a text log that dumps to a TextWriter</summary>
            <param name="log_destination">TextWriter to write log messages. Typically this would be System::Console::Out</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnTextLog.#ctor">
            <summary>Create a text log that dumps to Console.Out</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTextLog.IndentSize">
            <summary>
0: one tab per indent
&gt;0: number of spaces per indent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEvaluator.Domain(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: The domain of the parameter. If the domain is infinite, the (-1.0e300, +1.0e300) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEvaluator.Periodic(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: True if the function parameter is periodic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEvaluator.FiniteDomain">
            <summary>
Description: Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains. Returns: True if the domain of the function is finite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_bPeriodicParameter">
            <summary>
If the function has periodic parameters, then
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_domain">
            <summary>
If the function has a finite domain or periodic
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_value_count">
            <summary>
Number of the function's output values. This number
is &gt;= 1 and is specified in the constructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEvaluator.m_parameter_count">
            <summary>
Number of the function's input parameters. This number
is &gt;= 1 and is specified in the constructor.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnEvaluator">
            <summary>
Abstract function with an arbitrary number of parameters
and values.  ON_Evaluator is used to pass functions to
local solvers.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEvaluator.Domain(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: The domain of the parameter. If the domain is infinite, the (-1.0e300, +1.0e300) is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEvaluator.Periodic(System.Int32)">
            <summary>
Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: True if the function parameter is periodic.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEvaluator.FiniteDomain">
            <summary>
Description: Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains. Returns: True if the domain of the function is finite.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_bPeriodicParameter">
            <summary>
If the function has periodic parameters, then
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_domain">
            <summary>
If the function has a finite domain or periodic
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_value_count">
            <summary>
Number of the function's output values. This number
is &gt;= 1 and is specified in the constructor.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEvaluator.m_parameter_count">
            <summary>
Number of the function's input parameters. This number
is &gt;= 1 and is specified in the constructor.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnEvaluator">
            <summary>
Abstract function with an arbitrary number of parameters
and values.  ON_Evaluator is used to pass functions to
local solvers.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.SummandCount">
            <summary>
Returns: Number of summands.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Total">
            <summary>Calculates the total sum.</summary>
            <returns>Total of the sum.</returns>
            <remarks>
You can get subtotals by mixing calls to Plus() and Total().
In delicate sums, some precision may be lost in the final
total if you call Total() to calculate subtotals.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Total(System.Double@)">
            <summary>Calculates the total sum.</summary>
            <param name="error_estimate">
[out] the returned value of error_estimate is an estimate of the error in the sum.
</param>
            <returns>Total of the sum.</returns>
            <remarks>
You can get subtotals by mixing calls to Plus() and Total().
In delicate sums, some precision may be lost in the final
total if you call Total() to calculate subtotals.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Plus(System.Double)">
            <summary>
Description: Add x to the current sum. Parameters: x - [in] value to add to the current sum.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Begin">
            <summary>
Description: If a sum is being used more than once, call Begin() before starting each sum. Parameters: starting_value - [in] Initial value of sum.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.Begin(System.Double)">
            <summary>
Description: If a sum is being used more than once, call Begin() before starting each sum. Parameters: starting_value - [in] Initial value of sum.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.#ctor">
            <summary>
Description: Creates a sum that is ready to be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.op_SubtractionAssignment(RMA.OpenNURBS.OnSum,System.Double)">
            <summary>
Description: Calls ON_Sum::Plus(-x);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.op_AdditionAssignment(RMA.OpenNURBS.OnSum,System.Double)">
            <summary>
Description: Calls ON_Sum::Plus(x);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSum.op_Implicit(System.Double)~RMA.OpenNURBS.OnSum">
            <summary>
Description: Calls ON_Sum::Begin(x)
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnSum">
            <summary>Class for carefully adding long list of numbers.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSum.SummandCount">
            <summary>
Returns: Number of summands.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnSum">
            <summary>Class for carefully adding long list of numbers.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transforms the morph by transforming the bezier volume map.</summary>
            <param name="xform">[in]</param>
            <returns>True if input is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.SetBezierCage(RMA.OpenNURBS.OnBezierCage@)">
            <summary>Set the unit cube to world map.</summary>
            <param name="unitcube2world">
[in] Bezier volume map from the unit cube (0,1)x(0,1)x(0,1) to world space.
</param>
            <returns>
True if current transformation matrix and input bezier volume are valid.
In all cases, the morph's m_rst2xyz member is set.
See Also:
ON_BezierCage::Create
ON_BezierCage::SetXform
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.SetXform(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: Set the world to unit cube map. Parameters: world2unitcube - [in] Tranformation matrix that maps world coordinates to the unit cube (0,1)x(0,1)x(0,1). Returns True if current bezier volum and input transformation matrix are valid. In all cases, the morph's m_xyz2rst member is set. See Also: ON_BezierCage::Create ON_BezierCage::SetBezierCage
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Bezier volume.</summary>
            <remarks>
P0,P1,P2,P3 defines a parallepiped in world space. The morph maps
this parallepiped to the (0,1)x(0,1)x(0,1) unit cube and then applies
the BezierCage map.

point_countX, point_countY, point_countZ
Number of control points in the bezier volume map. The bezier volume
in the returned morph is the identity map which can be modified as needed. 
</remarks>
            <returns>
True if resulting morph is valid.
See Also: ON_BezierCage::SetBezierCage ON_BezierCage::SetXform
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCageMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Override of virtual ON_SpaceMorph::MorphPoint.</summary>
            <param name="point">[in] (x,y,z) gets mapped to m_rst2xyz(m_xyz2rst*point);</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCageMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Override of virtual ON_SpaceMorph::MorphPoint.</summary>
            <param name="point">[in] (x,y,z) gets mapped to m_rst2xyz(m_xyz2rst*point);</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.ReserveCVCapacity(System.Int32)">
            <summary>
Description: cv_capacity - [in] number of doubles to reserve
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
set a single control vertex
value of control vertex
If NURBS is not rational, euclidean
location of homogeneous point will
be used.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.SetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single control vertex
If NURBS is rational, weight
will be set to 1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.SetWeight(System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCage::GetCV( ON_3dPoint&amp; ) or ON_BezierCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCage::CVStyle ON_BezierCage::GetCV ON_BezierCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (rst.x,rst.y,rst.z).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Scale(System.Double)">
            <summary>
Scales the bezier surface by the specified facotor.  The scale is
centered at the origin.
</summary>
            <param name="scale_factor">[in] scale factor</param>
            <returns>TRUE if bezier surface successfully scaled</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Translates the bezier surface along the specified vector.
</summary>
            <param name="translation_vector">[in] translation vector</param>
            <returns>TRUE if bezier surface successfully translated</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierCage::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
Saves the definition of this class in serial binary form that can be read by ON_BezierVolue::Read.
</summary>
            <param name="archive">[in] target archive</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
Reads the definition of this class from an archive previously saved by ON_BezierVolue::Write.
</summary>
            <param name="archive">[in] target archive</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.EmergencyDestroy">
            <summary>
Sets all members to zero. Does not free the CV array even when m_cv is not NULL.
Generally used when the CVs were allocated from a memory pool that no longer exists
and the free done in ~ON_BezierCage would cause a crash.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Destroy">
            <summary>
Frees the CV array and sets all members to zero.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Create(RMA.OpenNURBS.IOnBoundingBox,System.Int32,System.Int32,System.Int32)">
            <summary>Create a Bezier volume with corners defined by a bounding box.</summary>
            <param name="bbox">
[in] target bounding box - the bezier will map the unit cube onto this bounding box.
</param>
            <param name="order1">[in]</param>
            <param name="order2">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Create(System.Int32,System.Boolean,System.Int32,System.Int32,System.Int32)">
            <summary>Creates a bezier volume with specified orders.</summary>
            <param name="dim">[in]</param>
            <param name="is_rat">[in]</param>
            <param name="order0">[in]</param>
            <param name="order1">[in]</param>
            <param name="order2">[in]</param>
            <returns>True if input was valid and creation succeded.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.Dimension">
            <summary>
The dimension of the image of the bazier volume map. This is generally three,
but can be any positive integer.
</summary>
            <returns>Dimesion of the image space.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.IsValid">
            <summary>Tests class to make sure members are correctly initialized.</summary>
            <returns>
True if the orders are all &gt;= 2, dimension is positive, and the
rest of the members have settings that are valid for the orders and dimension.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCage.#ctor(RMA.OpenNURBS.IOnBoundingBox,System.Int32,System.Int32,System.Int32)">
            <summary>
Construct a bezier volume that maps the unit cube to a bounding box.
</summary>
            <param name="bbox">[in] target bounding box</param>
            <param name="order0">[in]</param>
            <param name="order1">[in]</param>
            <param name="order2">[in]</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCage.m_dim">
            <summary>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.GetCV(System.Int32,System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Weight(System.Int32,System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCage::GetCV( ON_3dPoint&amp; ) or ON_BezierCage::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCage::CVStyle ON_BezierCage::GetCV ON_BezierCage::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.PointAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (rst.x,rst.y,rst.z).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluates bezer volume map.</summary>
            <returns>Value of the bezier volume map at (r,s,t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain, 2 = "w" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>
Saves the definition of this class in serial binary form that can be read by ON_BezierVolue::Read.
</summary>
            <param name="archive">[in] target archive</param>
            <returns>True if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.Dimension">
            <summary>
The dimension of the image of the bazier volume map. This is generally three,
but can be any positive integer.
</summary>
            <returns>Dimesion of the image space.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCage.IsValid">
            <summary>Tests class to make sure members are correctly initialized.</summary>
            <returns>
True if the orders are all &gt;= 2, dimension is positive, and the
rest of the members have settings that are valid for the orders and dimension.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCage.m_dim">
            <summary>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters
in the intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters in the
intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.ReserveCVCapacity(System.Int32)">
            <param name="arg1">number of doubles to reserve</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsoCurve(System.Int32,System.Double)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsoCurve(System.Int32,System.Double,RMA.OpenNURBS.OnBezierCurve)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnBezierSurface@,RMA.OpenNURBS.OnBezierSurface@)">
            <param name="arg1">0 split at "u"=t, 1= split at "v"=t</param>
            <param name="t">splitting parameter must 0 &lt; t &lt; 1</param>
            <param name="arg3">west/south side returned here (can pass *this)</param>
            <param name="arg4">east/north side returned here (can pass *this)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.ZeroCVs">
            <summary>
zeros control vertices and, if rational, sets weights to 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
set a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.SetCV(System.Int32,System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.SetWeight(System.Int32,System.Int32,System.Double)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Weight(System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierSurface::GetCV( ON_3dPoint&amp; ) or ON_BezierSurface::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierSurface::CVStyle ON_BezierSurface::GetCV ON_BezierSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Transpose">
            <summary>
transpose surface parameterization (swap "s" and "t")
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Reverse(System.Int32)">
            <summary>
reverse parameterizatrion
Domain changes from [a,b] to [-b,-a]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Scale(System.Double)">
            <summary>
Scales the bezier surface by the specified facotor.  The scale is
centered at the origin.
</summary>
            <param name="scale_factor">[in] scale factor</param>
            <returns>TRUE if bezier surface successfully scaled</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translates the bezier surface along the specified vector.</summary>
            <param name="translation_vector">[in] translation vector</param>
            <returns>TRUE if bezier surface successfully translated</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier surface about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier surface successfully rotated</returns>
            <remarks>Uses ON_BezierSurface::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Loft(RMA.OpenNURBS.IOnBezierCurve[])">
            <summary>Loft a bezier surface through a list of bezier curves.</summary>
            <param name="curve_list">[in] list of curves that have the same degree.</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.EmergencyDestroy">
            <summary>
call if memory used by ON_NurbsCurve becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierSurface.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_cv_capacity">
            <summary>
if 0, then destructor does not free m_cv
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_order(System.Int32)">
            <summary>
order = degree+1 &gt;= 2
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_is_rat">
            <summary>
0 = no, 1 = yes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierSurface.m_dim">
            <summary>
&gt;= 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier surface that is locally closest to
the point P when the search begins at (s_seed,t_seed).
</summary>
            <param name="P">[in]</param>
            <param name="s_seed">[in]Parameters where the search begins. </param>
            <param name="t_seed">[in]Parameters where the search begins. </param>
            <param name="s">[out] Closest point parameter</param>
            <param name="t">[out] Closest point parameter</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters
in the intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters
in the intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameters of the point on the bezier surface that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="s">[out]</param>
            <param name="t">[out]</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
from the bezier surface to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0,
then maximum_distance is ignored.
</param>
            <param name="sub_domain0">
[in] If not NULL, the search is confined to "s" parameters in the
intersection of the sub_domain0 interval and (0,1).
</param>
            <param name="sub_domain1">
[in] If not NULL, the search is confined to "t" parameters in the
intersection of the sub_domain1 interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_SurfaceTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points
to the same bezier. To efficiently find multiple closest points, make a surface
tree and use it. See the ON_BezierSurface::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsSingular(System.Int32)">
            <summary>
TRUE if surface side is collapsed to a point
</summary>
            <param name="side">
side of parameter space to test
0 = south, 1 = east, 2 = north, 3 = west
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsoCurve(System.Int32,System.Double)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsoCurve(System.Int32,System.Double,RMA.OpenNURBS.OnBezierCurve)">
            <summary>returns the isocurve.</summary>
            <param name="dir">
0 first parameter varies and second parameter is constant
  e.g., point on IsoCurve(0,c) at t is srf(t,c)
1 first parameter is constant and second parameter varies
  e.g., point on IsoCurve(1,c) at t is srf(c,t)
</param>
            <param name="c">value of constant parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Split(System.Int32,System.Double,RMA.OpenNURBS.OnBezierSurface@,RMA.OpenNURBS.OnBezierSurface@)">
            <param name="arg1">0 split at "u"=t, 1= split at "v"=t</param>
            <param name="t">splitting parameter must 0 &lt; t &lt; 1</param>
            <param name="arg3">west/south side returned here (can pass *this)</param>
            <param name="arg4">east/north side returned here (can pass *this)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetCV(System.Int32,System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>
get a single control vertex
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Weight(System.Int32,System.Int32)">
            <summary>
get value of control vertex weight
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierSurface::GetCV( ON_3dPoint&amp; ) or ON_BezierSurface::GetCV( ON_4dPoint&amp; ). Parameters: cv_index0 - [in] (0 &lt;= cv_index0 &lt; m_order[0]) cv_index1 - [in] (0 &lt;= cv_index1 &lt; m_order[1]) Returns: Pointer to control vertex. Remarks: If the Bezier surface is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier surface is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierSurface::CVStyle ON_BezierSurface::GetCV ON_BezierSurface::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Degree(System.Int32)">
            <summary>
degree = order - 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Order(System.Int32)">
            <summary>
order = degree + 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.CVSize">
            <summary>
number of doubles per control vertex
= IsRational() ? Dim()+1 : Dim()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.IsRational">
            <summary>
TRUE if NURBS curve is rational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Domain(System.Int32)">
            <param name="arg1">0 = "u" domain, 1 = "v" domain</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierSurface.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_cv_capacity">
            <summary>
if 0, then destructor does not free m_cv
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_order(System.Int32)">
            <summary>
order = degree+1 &gt;= 2
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_is_rat">
            <summary>
0 = no, 1 = yes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierSurface.m_dim">
            <summary>
&gt;= 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="bezsrfB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <param name="vdomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <param name="bezierB_domain">[in] optional restriction on bezierB domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <param name="other_domain">[in] optional other curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ChangeWeights(System.Int32,System.Double,System.Int32,System.Double)">
            <summary>
Use a combination of scaling and reparametrization to set two rational Bezier weights to specified values.
</summary>
            <param name="i0">[in] control point index (0 &lt;= i0 &lt; order, i0 != i1)</param>
            <param name="w0">[in] Desired weight for i0-th control point</param>
            <param name="i1">[in] control point index (0 &lt;= i1 &lt; order, i0 != i1)</param>
            <param name="w1">[in] Desired weight for i1-th control point</param>
            <returns>
True if successful. The returned bezier has the same locus but probably has a different parameterization.
</returns>
            <remarks>
The i0-th cv will have weight w0 and the i1-rst cv will have weight w1. If v0 and v1 are 
the cv's input weights, then v0, v1, w0 and w1 must all be nonzero,
and w0*v0 and w1*v1 must have the same sign.

The equations
  s * r^i0 = w0/v0
  s * r^i1 = w1/v1
determine the scaling and reparametrization necessary to change v0,v1 to w0,w1.
If the input Bezier has control vertices (B_0, ..., B_d),
then the output Bezier has control vertices (s*B_0, ... s*r^i * B_i, ..., s*r^d * B_d).
See Also:
 ON_Bezier::Reparameterize
 ON_Bezier::ScaleConrolPoints
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ScaleConrolPoints(System.Int32,System.Double)">
            <summary>
Scale a rational Bezier's control vertices to set a weight to a specified value.
</summary>
            <param name="i">[in] (0 &lt;= i &lt; order)</param>
            <param name="w">[in] w != 0.0</param>
            <returns>True if successful. The i-th control vertex will have weight w.</returns>
            <remarks>
Each control point is multiplied by w/w0, where w0 is the input value of Weight(i).
See Also: ON_Bezier::Reparameterize ON_Bezier::ChangeWeights
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Reparameterize(System.Double)">
            <summary>
Use a linear fractional tranformation for [0,1] to reparameterize the bezier.
The locus of the curve is not changed, but the parameterization is changed.
</summary>
            <param name="c">
[in] reparameterization constant (generally speaking, c should be &gt; 0).
If c != 1, then the returned bezier will be rational.
</param>
            <returns>true if successful.</returns>
            <remarks>
The reparametrization is performed by composing the input Bezier with
the function lambda: [0,1] -&gt; [0,1] given by
  t -&gt; c*t / ( (c-1)*t + 1 )

Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) &gt; 0,
lambda'(0) = c and lambda'(1) = 1/c.

If the input Bezier has control vertices {B_0, ..., B_d},
then the output Bezier has control vertices
(B_0, ... c^i * B_i, ..., c^d * B_d).

To derive this formula, simply compute the i-th Bernstein
polynomial composed with lambda().

The inverse parametrization is given by 1/c. That is, the cumulative effect of the two calls
Reparameterize(c)
Reparameterize(1.0/c)
is to leave the bezier unchanged.
See Also: ON_Bezier::ScaleConrolPoints
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Split(System.Double,RMA.OpenNURBS.OnBezierCurve@,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Split() divides the Bezier curve at the specified parameter.
The parameter must satisfy 0 &lt; t &lt; 1.  You may pass *this as
one of the curves to be returned.
</summary>
            <param name="t">[in] (0 &lt; t &lt; 1 ) parameter to split at</param>
            <param name="left_side">[out]</param>
            <param name="right_side">[out]</param>
            <example>
ON_BezierCurve crv = ...;
ON_BezierCurve right_side;
crv.Split( 0.5, crv, right_side );
would split crv at the 1/2, put the left side in crv,
and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Trim(RMA.OpenNURBS.IOnInterval)">
            <summary>
Trims (or extends) the bezier so the bezier so that the
result starts bezier(interval[0]) and ends at 
bezier(interval[1]) (Evaluation performed on input bezier.)
</summary>
            <example>
An interval of [0,1] leaves the bezier unchanged.  An
interval of [0.5,1] would trim away the left half.  An
interval of [0.0,2.0] would extend the right end.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ReserveCVCapacity(System.Int32)">
            <summary>Make sure m_cv array has a certain length.</summary>
            <param name="desired_cv_capacity">[in] minimum length of m_cv array.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ChangeDimension(System.Int32)">
            <summary>Change dimension of bezier.</summary>
            <returns>TRUE if successful.  FALSE if desired_dimension &lt;1</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IncreaseDegree(System.Int32)">
            <summary>Increase degree of bezier.</summary>
            <returns>TRUE if successful.  FALSE if desired_degree &lt; current degree.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.MakeNonRational">
            <summary>
Make beizer not rational by setting all control
vertices to their euclidean locations and setting
m_is_rat to FALSE.
See Also:
ON_Bezier::MakeRational
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.MakeRational">
            <summary>Make beizer rational.</summary>
            <returns>
TRUE if successful.
See Also:
 ON_Bezier::MakeNonRational
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.ZeroCVs">
            <summary>
Zeros control vertices and, if rational, sets weights to 1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>Get value of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Homogenous value of control vertex.
If the bezier is not rational, the weight is 1.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get location of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Location of control vertex.  If the bezier
is rational, the euclidean location is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn4dPoint)">
            <summary>Set value of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[in] control vertex value.  If the bezier is not rational,
the euclidean location of homogenoeous point will be used.
</param>
            <returns>TRUE if successful.</returns>
            <remarks>
See Also:
 ON_BezierCurve::CV, ON_BezierCurve::SetCV,
 ON_BezierCurve::SetWeight, ON_BezierCurve::Weight
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.SetCV(System.Int32,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set location of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[in] control vertex location.  If the bezier is rational, the weight will be set to 1.
</param>
            <returns>TRUE if successful.</returns>
            <remarks>
See Also:
 ON_BezierCurve::CV, ON_BezierCurve::SetCV,
 ON_BezierCurve::SetWeight, ON_BezierCurve::Weight
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.SetWeight(System.Int32,System.Double)">
            <summary>Set weight of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="weight">[in] weight</param>
            <returns>
TRUE if the weight can be set.  If weight is not 1 and
the bezier is not rational, then FALSE is returned.
Use ON_BezierCurve::MakeRational to make a bezier curve
rational.
</returns>
            <remarks>
See Also:
  ON_BezierCurve::SetCV, ON_BezierCurve::MakeRational,
  ON_BezierCurve::IsRational, ON_BezierCurve::Weight
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Weight(System.Int32)">
            <param name="cv_index">[in] control vertex index (0&lt;=i&lt;m_order)</param>
            <returns>Weight of the i-th control vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCurve::GetCV( ON_3dPoint&amp; ) or ON_BezierCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] (0 &lt;= cv_index &lt; m_order) Returns: Pointer to control vertex. Remarks: If the Bezier curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCurve::CVStyle ON_BezierCurve::GetCV ON_BezierCurve::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Degree">
            <summary>
Degree of the bezier. (degree=order-1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Order">
            <summary>
Order of the bezier. (order=degree+1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CVCount">
            <summary>
Number of control vertices in the bezier.
This is always the same as the order of the bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CVSize">
            <summary>
Number of doubles per control vertex.
(= IsRational() ? Dim()+1 : Dim())
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.IsRational">
            <summary>TRUE if bezier is rational.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get ON_NurbsCurve form of a bezier.</summary>
            <param name="nurbs_curve">
[out] NURBS curve form of a bezier.
The domain is [0,1].
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>
FALSE if unable to evaluate.
See Also:
ON_Curve::TangentAt
ON_Curve::Ev1Der
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Reverse">
            <summary>
Reverses bezier by reversing the order
of the control points.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Domain">
            <summary>
Domain of bezier (always [0,1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Scale(System.Double)">
            <summary>
Scales the bezier curve by the specified facotor.  The scale is
centered at the origin.
</summary>
            <param name="scale_factor">[in] scale factor</param>
            <returns>TRUE if bezier curve successfully scaled</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translates the bezier curve along the specified vector.</summary>
            <param name="translation_vector">[in] translation vector</param>
            <returns>TRUE if bezier curve successfully translated</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier curve about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="rotation_angle">[in] angle of rotation in radians</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier curve successfully rotated</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotates the bezier curve about the specified axis.  A positive
rotation angle results in a counter-clockwise rotation
about the axis (right hand rule).
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] sine of rotation angle</param>
            <param name="rotation_axis">[in] direction of the axis of rotation</param>
            <param name="rotation_center">[in] point on the axis of rotation</param>
            <returns>TRUE if bezier curve successfully rotated</returns>
            <remarks>Uses ON_BezierCurve::Transform() function to calculate the result.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transform the bezier.</summary>
            <param name="xform">[in] transformation to apply to bezier</param>
            <returns>
TRUE if successful.  FALSE if bezier is invalid
and cannot be transformed.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed bezier is calculated. The bezier curve is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.BoundingBox">
            <summary>Gets bounding box.</summary>
            <returns>Axis aligned bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <param name="bGrowBox">
[in] if TRUE, input bbox must be a valid bounding box and this box is enlarged to
be the union of the input box and the bezier's bounding box.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Loft(RMA.OpenNURBS.IOn3dPointArray)">
            <summary>Loft a bezier curve through a list of points.</summary>
            <param name="points">[in] an array of 2 or more points to interpolate</param>
            <returns>TRUE if successful</returns>
            <remarks>
The result has order = points.Count() and the loft uses the 
uniform parameterizaton curve( i/(points.Count()-1) ) = points[i].
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.EmergencyDestroy">
            <summary>
call if memory used by ON_NurbsCurve becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Destroy">
            <summary>
Deallocates m_cv memory.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Create(System.Int32,System.Boolean,System.Int32)">
            <summary>Creates a bezier with cv memory allocated.</summary>
            <param name="dim">[in] (&gt;0) dimension of bezier curve</param>
            <param name="bIsRational">[in] TRUE for a rational bezier</param>
            <param name="order">[in] (&gt;=2) order (=degree+1) of bezier curve</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Dimension">
            <summary>
Dimension of bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.op_Implicit(RMA.OpenNURBS.IOn4dPointArray)~RMA.OpenNURBS.OnBezierCurve">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.op_Implicit(RMA.OpenNURBS.IOn3dPointArray)~RMA.OpenNURBS.OnBezierCurve">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.op_Implicit(RMA.OpenNURBS.IOn2dPointArray)~RMA.OpenNURBS.OnBezierCurve">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(RMA.OpenNURBS.IOn4dPointArray)">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(RMA.OpenNURBS.IOn3dPointArray)">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(RMA.OpenNURBS.IOn2dPointArray)">
            <summary>
sets control points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBezierCurve.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>Creates a bezier with cv memory allocated.</summary>
            <param name="dim">[in] (&gt;0) dimension of bezier curve</param>
            <param name="bIsRational">[in] TRUE for a rational bezier</param>
            <param name="order">[in] (&gt;=2) order (=degree+1) of bezier curve</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_cv_capacity">
            <summary>
Number of doubles in m_cv array.  If m_cv_capacity is zero
and m_cv is not NULL, an expert user is managing the m_cv
memory.  ~ON_BezierCurve will not deallocate m_cv unless
m_cv_capacity is greater than zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_cv_stride">
            <summary>
Number of doubles per cv ( &gt;= ((m_is_rat)?m_dim+1:m_dim) )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_order">
            <summary>
order = degree+1
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_is_rat">
            <summary>
1 if bezier is rational, 0 if bezier is not rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnBezierCurve.m_dim">
            <summary>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
dimension of bezier (&gt;=1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSurface(RMA.OpenNURBS.IOnBezierSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier curve with bezsrfB.</summary>
            <param name="bezsrfB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and the distance from
curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then
the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, 
then intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this curve's domain</param>
            <param name="bezsrfB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="bezsrfB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve and surface
trees and intersect them. See the IntersectBezierSurface code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalSurfaceIntersection(RMA.OpenNURBS.IOnBezierSurface,System.Double,System.Double,System.Double,System.Double@,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-surface intersection point.</summary>
            <param name="bezsrf">[in]</param>
            <param name="seed_t">[in] curve paramter</param>
            <param name="seed_u">[in] surface parameter</param>
            <param name="seed_v">[in] surface parameter</param>
            <param name="t">[out] curve paramter</param>
            <param name="u">[out] surface parameter</param>
            <param name="v">[out] surface parameter</param>
            <param name="tdomain">[in] optional curve domain restriction</param>
            <param name="udomain">[in] optional surface domain restriction</param>
            <param name="vdomain">[in] optional surface domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectCurve(RMA.OpenNURBS.IOnBezierCurve,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect this bezier with bezierB.</summary>
            <param name="bezierB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are parameters of this curve's intersection events and the distance
from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the
event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then
intersection_tolerance*2.0 is used.
</param>
            <param name="bezierA_domain">[in] optional restriction on this bezier's domain</param>
            <param name="bezierB_domain">[in] optional restriction on bezierB domain</param>
            <returns>Number of intersection events appended to x.</returns>
            <remarks>
If you are performing more than one intersection, you should create curve trees
and intersect them. See the IntersectBezierCurve code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IntersectSelf(RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Find bezier self intersection points.</summary>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">[in]</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalCurveIntersection(RMA.OpenNURBS.IOnBezierCurve,System.Double,System.Double,System.Double@,System.Double@,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Get a local curve-curve intersection point.</summary>
            <param name="other_bezcrv">[in] other curve</param>
            <param name="this_seed_t">[in] this curve seed paramter</param>
            <param name="other_seed_t">[in] other curve seed paramter</param>
            <param name="this_t">[out] this curve paramter</param>
            <param name="other_t">[out] other curve paramter</param>
            <param name="this_domain">[in] optional this curve domain restriction</param>
            <param name="other_domain">[in] optional other curve domain restriction</param>
            <returns>True if something is returned in (t,u,v). Check answer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetLocalClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double@,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is locally closest
to the point P when the search begins at seed_parameter.
</summary>
            <param name="P">[in]</param>
            <param name="seed_parameter">[in] Parameter where the search begins.</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>True if a point is found.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>
Get the parameter of the point on the bezier curve that is closest to the point P.
</summary>
            <param name="P">[in]</param>
            <param name="t">[out] Closest point parameter.</param>
            <param name="maximum_distance">
[in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance
then maximum_distance is ignored.
</param>
            <param name="sub_domain">
[in] If not NULL, the search is confined to the intersection of the sub_domain interval and (0,1).
</param>
            <returns>
True if a point is found.
See Also: ON_CurveTreeNode::GetClosestPoint
</returns>
            <remarks>
This function is not efficient if you will be finding multiple closest points to
the same bezier. To efficiently find multiple closest points, make a curve tree
and use it.
See the ON_BezierCurve::GetClosestPoint code for an example.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.ControlPolygonLength">
            <summary>returns the length of the control polygon</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Split(System.Double,RMA.OpenNURBS.OnBezierCurve@,RMA.OpenNURBS.OnBezierCurve@)">
            <summary>
Split() divides the Bezier curve at the specified parameter.
The parameter must satisfy 0 &lt; t &lt; 1.  You may pass *this as
one of the curves to be returned.
</summary>
            <param name="t">[in] (0 &lt; t &lt; 1 ) parameter to split at</param>
            <param name="left_side">[out]</param>
            <param name="right_side">[out]</param>
            <example>
ON_BezierCurve crv = ...;
ON_BezierCurve right_side;
crv.Split( 0.5, crv, right_side );
would split crv at the 1/2, put the left side in crv,
and return the right side in right_side.
</example>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On4dPoint@)">
            <summary>Get value of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Homogenous value of control vertex.
If the bezier is not rational, the weight is 1.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetCV(System.Int32,RMA.OpenNURBS.On3dPoint@)">
            <summary>Get location of a control vertex.</summary>
            <param name="cv_index">[in] control vertex index (0 &lt;= cv_index &lt; m_order)</param>
            <param name="point">
[out] Location of control vertex.  If the bezier
is rational, the euclidean location is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Weight(System.Int32)">
            <param name="cv_index">[in] control vertex index (0&lt;=i&lt;m_order)</param>
            <returns>Weight of the i-th control vertex.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CVStyle">
            <summary>
Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCurve::GetCV( ON_3dPoint&amp; ) or ON_BezierCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] (0 &lt;= cv_index &lt; m_order) Returns: Pointer to control vertex. Remarks: If the Bezier curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also ON_BezierCurve::CVStyle ON_BezierCurve::GetCV ON_BezierCurve::Weight
</summary>
            <summary>Returns the style of control vertices in the m_cv array.</summary>
            <returns>
ON::not_rational m_is_rat is FALSE
ON::homogeneous_rational m_is_rat is TRUE
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Degree">
            <summary>
Degree of the bezier. (degree=order-1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Order">
            <summary>
Order of the bezier. (order=degree+1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CVCount">
            <summary>
Number of control vertices in the bezier.
This is always the same as the order of the bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CVSize">
            <summary>
Number of doubles per control vertex.
(= IsRational() ? Dim()+1 : Dim())
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.IsRational">
            <summary>TRUE if bezier is rational.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>Get ON_NurbsCurve form of a bezier.</summary>
            <param name="nurbs_curve">
[out] NURBS curve form of a bezier.
The domain is [0,1].
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.EvCurvature(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent and curvature at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <param name="kappa">[out] value of curvature vector</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.EvTangent(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate unit tangent at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="tangent">[out] value of unit tangent</param>
            <returns>
FALSE if unable to evaluate.
See Also:
ON_Curve::TangentAt
ON_Curve::Ev1Der
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Ev2Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate second derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <param name="second_derivative">[out] value of second derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Ev1Der(System.Double,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@)">
            <summary>Evaluate first derivative at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <param name="first_derivative">[out] value of first derivative at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.EvPoint(System.Double,RMA.OpenNURBS.On3dPoint@)">
            <summary>Evaluate point at a parameter with error checking.</summary>
            <param name="t">[in] evaluation parameter</param>
            <param name="point">[out] value of curve at t</param>
            <returns>FALSE if unable to evaluate.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.CurvatureAt(System.Double)">
            <summary>Evaluate the curvature vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>curvature vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvCurvature
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.TangentAt(System.Double)">
            <summary>Evaluate unit tangent vector at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Unit tangent vector of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::EvTangent
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.DerivativeAt(System.Double)">
            <summary>Evaluate first derivative at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>First derivative of the curve at the parameter t.</returns>
            <remarks>
No error handling.
See Also: ON_Curve::Ev1Der
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.PointAt(System.Double)">
            <summary>Evaluate point at a parameter.</summary>
            <param name="t">[in] evaluation parameter</param>
            <returns>Point (location of curve at the parameter t).</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Domain">
            <summary>
Domain of bezier (always [0,1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the bezier.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox
and the tight bounding box of the bezier curve.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the
transformed bezier is calculated. The bezier curve is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.BoundingBox">
            <summary>Gets bounding box.</summary>
            <returns>Axis aligned bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Gets bounding box.</summary>
            <param name="bbox">[out] axis aligned bounding box returned here.</param>
            <param name="bGrowBox">
[in] if TRUE, input bbox must be a valid bounding box and this box is enlarged to
be the union of the input box and the bezier's bounding box.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Dimension">
            <summary>
Dimension of bezier.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBezierCurve.Dump(RMA.OpenNURBS.OnTextLog@)">
            <summary>
for debugging
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_cv_capacity">
            <summary>
Number of doubles in m_cv array.  If m_cv_capacity is zero
and m_cv is not NULL, an expert user is managing the m_cv
memory.  ~ON_BezierCurve will not deallocate m_cv unless
m_cv_capacity is greater than zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_cv_stride">
            <summary>
Number of doubles per cv ( &gt;= ((m_is_rat)?m_dim+1:m_dim) )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_order">
            <summary>
order = degree+1
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_is_rat">
            <summary>
1 if bezier is rational, 0 if bezier is not rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnBezierCurve.m_dim">
            <summary>
NOTE: These members are left "public" so that expert users may efficiently
     create bezier curves using the default constructor and borrow the
     knot and CV arrays from their native NURBS representation.
     No technical support will be provided for users who access these
     members directly.  If you can't get your stuff to work, then use
     the constructor with the arguments and the SetKnot() and SetCV()
     functions to fill in the arrays.
dimension of bezier (&gt;=1)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialSurface.m_cv">
            <summary>
coefficients ( m_C.Length() = m_order[0]*m_order[1]
coefficient of s^m*t^n = m_cv[m_order[1]*m+n]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialSurface.m_is_rat">
            <summary>
1 if rational, 0 if not rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialSurface.m_dim">
            <summary>
1,2, or 3
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialSurface.m_cv">
            <summary>
coefficients ( m_C.Length() = m_order[0]*m_order[1]
coefficient of s^m*t^n = m_cv[m_order[1]*m+n]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialSurface.m_is_rat">
            <summary>
1 if rational, 0 if not rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialSurface.m_dim">
            <summary>
1,2, or 3
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolynomialCurve.Destroy">
            <summary>
Deallocates the m_cv array and sets fields to zero.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolynomialCurve.Create(System.Int32,System.Boolean,System.Int32)">
            <summary>Initializes fields and allocates the m_cv array.</summary>
            <param name="dim">[in] dimension of the curve</param>
            <param name="bIsRational">[in] TRUE if rational</param>
            <param name="order">[in] (&gt;=2) order = degree+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolynomialCurve.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>See ON_PolynomialCurve::Create.</summary>
            <param name="dim">[in] dimension of the curve</param>
            <param name="bIsRational">[in] TRUE if rational</param>
            <param name="order">[in] (&gt;=2) order = degree+1</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_domain">
            <summary>
domain of polynomial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_cv">
            <summary>
coefficients ( m_cv.Count() = order of monomial )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_order">
            <summary>
order (=degree+1) of polynomial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_is_rat">
            <summary>
1 if polynomial curve is rational, 0 if polynomial curve is not rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPolynomialCurve.m_dim">
            <summary>
dimension of polynomial curve (1,2, or 3)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_domain">
            <summary>
domain of polynomial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_cv">
            <summary>
coefficients ( m_cv.Count() = order of monomial )
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_order">
            <summary>
order (=degree+1) of polynomial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_is_rat">
            <summary>
1 if polynomial curve is rational, 0 if polynomial curve is not rational
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPolynomialCurve.m_dim">
            <summary>
dimension of polynomial curve (1,2, or 3)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>parameterization of NURBS surface does not match torus's transcendental paramaterization</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate torus about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate torus about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate torus about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate torus about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on torus that is closest to test_point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on torus that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MinorCircleDegrees(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_degrees">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_degrees*ON_PI/180.0),
and starting point PointAt( major_angle_degrees*ON_PI/180.0, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MinorCircleRadians(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_radians">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_radians),
and starting point PointAt( major_angle_radians, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MajorCircleDegrees(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_degrees">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at
PointAt( 0.0, minor_angle_degrees*ON_PI/180.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnTorus.MajorCircleRadians(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_radians">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at PointAt( 0.0, minor_angle_radians ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnTorus.minor_radius">
            <summary>
&gt; 0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTorus.major_radius">
            <summary>
&gt; minor_radius
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnTorus.plane">
            <summary>
major circle plane
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnTorus">
            <summary>
The torus is defined by a major circle and minor radius.  The
torus is parameterized by (major_angle,minor_angle).  The angles
are specified in radians.  The domain of both parameters is (0,2pi).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the torus.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the torus is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
returns 0=failure, 2=success
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on torus that is closest to test_point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on torus that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MinorCircleDegrees(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_degrees">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_degrees*ON_PI/180.0),
and starting point PointAt( major_angle_degrees*ON_PI/180.0, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MinorCircleRadians(System.Double)">
            <summary>Get the minor circle that is the isocurve on the torus at a specified major angle.</summary>
            <param name="major_angle_radians">[in]</param>
            <returns>
A circle with radius = minor_radis, center = major_circle.PointAt(major_angle_radians),
and starting point PointAt( major_angle_radians, 0.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MajorCircleDegrees(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_degrees">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at
PointAt( 0.0, minor_angle_degrees*ON_PI/180.0 ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnTorus.MajorCircleRadians(System.Double)">
            <summary>Get the circle that is the isocurve on the torus at a specified minor angle.</summary>
            <param name="minor_angle_radians">[in]</param>
            <returns>
A circle with normal major_circle.plane.zaxis that starts at PointAt( 0.0, minor_angle_radians ).
See Also:
ON_Torus::MajorCircleRadians
ON_Torus::MajorCircleDegrees
ON_Torus::MinorCircleRadians
ON_Torus::MinorCircleDegrees
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTorus.minor_radius">
            <summary>
&gt; 0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTorus.major_radius">
            <summary>
&gt; minor_radius
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnTorus.plane">
            <summary>
major circle plane
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnTorus">
            <summary>
The torus is defined by a major circle and minor radius.  The
torus is parameterized by (major_angle,minor_angle).  The angles
are specified in radians.  The domain of both parameters is (0,2pi).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match sphere's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate sphere about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate sphere about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate sphere about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate sphere about its origin</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on sphere that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>returns parameters of point on sphere that is closest to given point</summary>
            <param name="longitude_radians">longitude  [0,2pi)</param>
            <param name="latitude_radians">latitude   [-pi/2,pi/2]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.NormalAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.PointAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.Create(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
center radius
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSphere.#ctor(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
center, radius
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSphere.radius">
            <summary>
&gt; 0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSphere.plane">
            <summary>
equitorial plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the sphere.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the sphere is not valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match sphere's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on sphere that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>returns parameters of point on sphere that is closest to given point</summary>
            <param name="longitude_radians">longitude  [0,2pi)</param>
            <param name="latitude_radians">latitude   [-pi/2,pi/2]</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.NormalAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSphere.PointAt(System.Double,System.Double)">
            <summary>longitude [0,2pi], latitude [-pi/2,pi/2] in radians</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSphere.radius">
            <summary>
&gt; 0
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSphere.plane">
            <summary>
equitorial plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate cone about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate cone about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
rotate cone about its origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
rotate cone about its origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.LineAt(System.Double)">
            <summary>Get iso curve line segment at a specified angle.</summary>
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.CircleAt(System.Double)">
            <summary>Get iso curve circle at a specified height.</summary>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.NormalAt(System.Double,System.Double)">
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
            <remarks>
If radius&gt;0 and height&gt;0, then the normal points "out"
when height_parameter &gt;= 0.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.PointAt(System.Double,System.Double)">
            <summary>evaluate parameters and return point</summary>
            <param name="radial_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.AngleInDegrees">
            <summary>
The angle (in degrees) between the axis and the side.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.AngleInRadians">
            <summary>
The angle (in radians) between the axis and the 
side of the cone.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Axis">
            <summary>
Returns: Unit vector axis of cone.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.ApexPoint">
            <summary>Point at the tip of the cone.</summary>
            <remarks>The apex point is plane.origin.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.BasePoint">
            <summary>
Returns: Center of base circle.
</summary>
            <remarks>The base point is plane.origin + height*plane.zaxis.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.IsValid">
            <summary>
Returns TRUE if plane is valid, height is not zero, and
radius is not zero.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.Create(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>
Creates a right circular cone from a plane, height, and radius.
</summary>
            <param name="plane">[in] The apex of cone is at plane.origin and the axis of the cone is plane.zaxis.</param>
            <param name="height">[in] The center of the base is height*plane.zaxis.</param>
            <param name="radius">[in] tan(cone angle) = radius/height</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.#ctor(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <summary>See ON_Cone::Create.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCone.#ctor">
            <summary>
Creates a cone with world XY plane as the base plane,
center = (0,0,0), radius = 0.0, height = 0.0.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCone.radius">
            <summary>
not zero
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCone.height">
            <summary>
not zero
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCone.plane">
            <summary>
apex = plane.origin, axis = plane.zaxis
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnCone">
            <summary>
Lightweight right circular cone.  Use ON_ConeSurface if
you need ON_Cone geometry as a virtual ON_Surface.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cone that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.LineAt(System.Double)">
            <summary>Get iso curve line segment at a specified angle.</summary>
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.CircleAt(System.Double)">
            <summary>Get iso curve circle at a specified height.</summary>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.NormalAt(System.Double,System.Double)">
            <param name="radial_parameter">[in] (in radians) 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
            <remarks>
If radius&gt;0 and height&gt;0, then the normal points "out"
when height_parameter &gt;= 0.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.PointAt(System.Double,System.Double)">
            <summary>evaluate parameters and return point</summary>
            <param name="radial_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="height_parameter">[in] 0 = apex, height = base</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.AngleInDegrees">
            <summary>
The angle in degrees) between the axis and the side.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.AngleInRadians">
            <summary>
The angle (in radians) between the axis and the 
side of the cone.
The angle and the height have the same sign.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.Axis">
            <summary>
Returns: Unit vector axis of cone.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.ApexPoint">
            <summary>Point at the tip of the cone.</summary>
            <remarks>The apex point is plane.origin.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.BasePoint">
            <summary>
Returns: Center of base circle.
</summary>
            <remarks>The base point is plane.origin + height*plane.zaxis.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCone.IsValid">
            <summary>
Returns TRUE if plane is valid, height is not zero, and
radius is not zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCone.radius">
            <summary>
not zero
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCone.height">
            <summary>
not zero
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCone.plane">
            <summary>
apex = plane.origin, axis = plane.zaxis
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCone">
            <summary>
Lightweight right circular cone.  Use ON_ConeSurface if
you need ON_Cone geometry as a virtual ON_Surface.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match cylinder's transcendental paramaterization
</summary>
            <returns>
0=failure, 2=success
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate cylinder about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
For intersections see ON_Intersect();
rotate cylinder about its origin
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cylinder that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cylinder that is closest to given point
</summary>
            <param name="arg2">angular parameter [0,2pi]</param>
            <param name="arg3">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.NormalAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.PointAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.GetHeight">
            <summary>
returns 0 for infinite cylinder
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.IsFinite">
            <summary>
returns TRUE if the cylinder is finite (height[0] != height[1]) and
FALSE if the cylinder is infinite.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Create(RMA.OpenNURBS.IOnCircle,System.Double)">
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.Create(RMA.OpenNURBS.IOnCircle)">
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.#ctor(RMA.OpenNURBS.IOnCircle,System.Double)">
            <summary>infinte cylinder</summary>
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.#ctor(RMA.OpenNURBS.IOnCircle)">
            <summary>infinte cylinder</summary>
            <param name="arg1">point on the bottom plane</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCylinder.#ctor">
            <summary>
zeros all fields - cylinder is invalid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCylinder.circle">
            <summary>
base circle
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnCylinder">
            <summary>ON_Cylinder is a right circular cylinder.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.RevSurfaceForm">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.RevSurfaceForm(RMA.OpenNURBS.OnRevSurface)">
            <summary>Creates a surface of revolution definition of the cylinder.</summary>
            <param name="srf">[in] if not NULL, then this srf is used.</param>
            <returns>A surface of revolution or NULL if the cylinder is not valid or is infinite.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.GetNurbForm(RMA.OpenNURBS.OnNurbsSurface@)">
            <summary>
parameterization of NURBS surface does not match cylinder's transcendental paramaterization
</summary>
            <returns>
0=failure, 2=success
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on cylinder that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>
returns parameters of point on cylinder that is closest to given point
</summary>
            <param name="arg2">angular parameter [0,2pi]</param>
            <param name="arg3">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.NormalAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.PointAt(System.Double,System.Double)">
            <summary>
evaluate parameters and return point
</summary>
            <param name="arg1">angular parameter [0,2pi]</param>
            <param name="arg2">linear parameter (height from base circle's plane)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.GetHeight">
            <summary>
returns 0 for infinite cylinder
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.IsFinite">
            <summary>
returns TRUE if the cylinder is finite (height[0] != height[1]) and
FALSE if the cylinder is infinite.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCylinder.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCylinder.circle">
            <summary>
base circle
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCylinder">
            <summary>ON_Cylinder is a right circular cylinder.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Find a point on the polyline that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Int32,System.Int32)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that is closest to
test_point.  If mulitple solutions exist, then the smallest solution is returned.
</param>
            <param name="segment_index0">[in] index of segment where search begins</param>
            <param name="segment_index1">
[in] index of segment where search ends
This segment is NOT searched.
</param>
            <example>
Search segments 3,4, and 5 for the point closest to (0,0,0).
double t;
ClosestPointTo( ON_3dPoint(0,0,0), t, 3, 6 );
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that
is closest to test_point.  If mulitple solutions
exist, then the smallest solution is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.TangentAt(System.Double)">
            <summary>Evaluate the polyline unit tangent at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.DerivativeAt(System.Double)">
            <summary>Evaluate the polyline first derivative at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.PointAt(System.Double)">
            <summary>Evaluate the polyline location at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.SegmentTangent(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>Unit vector in the direction of the segment</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.SegmentDirection(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>vector = point[segment_index+1] - point[segment_index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.Length">
            <summary>
Returns: Length of the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsClosed">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsClosed(System.Double)">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.SegmentCount">
            <summary>
Returns: Number of segments in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.PointCount">
            <summary>
Returns: Number of points in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.Clean">
            <summary>Removes duplicate points that result in zero length segments.</summary>
            <returns>Number of points removed.</returns>
            <remarks>
If the distance between points polyline[i] and polyline[i+1]
is &lt;= tolerance, then the point with index (i+1) is removed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.Clean(System.Double)">
            <summary>Removes duplicate points that result in zero length segments.</summary>
            <param name="tolerance">[in] tolerance used to check for duplicate points.</param>
            <returns>Number of points removed.</returns>
            <remarks>
If the distance between points polyline[i] and polyline[i+1]
is &lt;= tolerance, then the point with index (i+1) is removed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsValid">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.IsValid(System.Double)">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <param name="tolerance">[in] tolerance used to check for duplicate points.</param>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.CreateStarPolygon(RMA.OpenNURBS.IOnCircle,System.Double,System.Int32)">
            <summary>
Create a regular star polygon.
The star begins at circle.PointAt(0) and the vertices alternate
between being on circle and begin on a concentric circle of other_radius.
</summary>
            <param name="circle">[in] circle star polygon starts on</param>
            <param name="other_radius">[in] radius of other circle</param>
            <param name="corner_count">
[in] (&gt;=3) number of corners on circle
There will be 2*corner_count sides and 2*corner_count vertices.
</param>
            <returns>
TRUE if successful.  FALSE if circle is invalid, other_radius &lt; 0.0,
or side_count &lt; 3.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.CreateCircumscribedPolygon(RMA.OpenNURBS.IOnCircle,System.Int32)">
            <summary>
Create a regular polygon circumscribe about a circle.
The midpoints of the polygon's edges will be tanget to the circle.
</summary>
            <param name="circle">[in]</param>
            <param name="side_count">[in] (&gt;=3) number of sides</param>
            <returns>
TRUE if successful.  FALSE if circle is invalid or side_count &lt; 3.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPolyline.CreateInscribedPolygon(RMA.OpenNURBS.IOnCircle,System.Int32)">
            <summary>
Create a regular polygon inscribed in a circle.
The vertices of the polygon will be on the circle.
</summary>
            <param name="circle">[in]</param>
            <param name="side_count">[in] (&gt;=3) number of sides</param>
            <returns>
TRUE if successful.  FALSE if circle is invalid or side_count &lt; 3.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Find a point on the polyline that is closest to test_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Int32,System.Int32)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that is closest to
test_point.  If mulitple solutions exist, then the smallest solution is returned.
</param>
            <param name="segment_index0">[in] index of segment where search begins</param>
            <param name="segment_index1">
[in] index of segment where search ends
This segment is NOT searched.
</param>
            <example>
Search segments 3,4, and 5 for the point closest to (0,0,0).
double t;
ClosestPointTo( ON_3dPoint(0,0,0), t, 3, 6 );
</example>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find a point on the polyline that is closest to test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">
[out] parameter for a point on the polyline that
is closest to test_point.  If mulitple solutions
exist, then the smallest solution is returned.
</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.TangentAt(System.Double)">
            <summary>Evaluate the polyline unit tangent at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.DerivativeAt(System.Double)">
            <summary>Evaluate the polyline first derivative at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.PointAt(System.Double)">
            <summary>Evaluate the polyline location at a parameter.</summary>
            <param name="t">[in] the i-th segment goes from i &lt;= t &lt; i+1</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.SegmentTangent(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>Unit vector in the direction of the segment</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.SegmentDirection(System.Int32)">
            <param name="segment_index">[in] zero based segment index</param>
            <returns>vector = point[segment_index+1] - point[segment_index].</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.Length">
            <summary>
Returns: Length of the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsClosed">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsClosed(System.Double)">
            <summary>Test a polyline to see if it is closed.</summary>
            <returns>
TRUE if polyline has 4 or more points, the distance between the
start and end points is &lt;= tolerance, and there is a
point in the polyline whose distance from the start and end
points is &gt; tolerance.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.SegmentCount">
            <summary>
Returns: Number of segments in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.PointCount">
            <summary>
Returns: Number of points in the polyline.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsValid">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPolyline.IsValid(System.Double)">
            <summary>
Checks that polyline has at least two points
and that sequential points are distinct.  If the
polyline has 2 or 3 points, then the start and end
point must be distinct.
</summary>
            <param name="tolerance">[in] tolerance used to check for duplicate points.</param>
            <returns>
TRUE if polyline is valid.
See Also: ON_Polyline::Clean.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate line about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Reverse">
            <summary>
Reverse line by swapping from and to.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>
distance from the point on the line that is closest to test_point.
See Also: ON_3dPoint::DistanceTo ON_Line::ClosestPointTo
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>The point on the line that is closest to test_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">[out] line.PointAt(*t) is the point on the line that is closest to test_point.</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.PointAt(System.Double)">
            <summary>Evaluate point on (infinite) line.</summary>
            <param name="t">
[in] evaluation parameter.
t=0 returns line.from and t=1 returns line.to.
</param>
            <returns>
(1-t)*line.from + t*line.to.
See Also: ON_Line::Direction ON_Line::Tangent
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Tangent">
            <summary>
Returns: Unit tangent vector.
See Also: ON_Line::Direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Direction">
            <summary>
Returns: direction vector = line.to - line.from
See Also: ON_Line::Tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Length">
            <summary>
Returns: Length of line
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.InPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.InPlane(RMA.OpenNURBS.OnPlane@,System.Double)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <param name="tolerance">[in]</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL)
If not NULL, the tight bounding box of the transformed line is calculated.
The line is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true, then the union of the input bbox and the
object's bounding box is returned in bbox.
If false, the object's bounding box is returned in bbox.
</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.BoundingBox">
            <summary>Get line's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Create a line from two points.</summary>
            <param name="start">[in] point at start of line segment</param>
            <param name="end">[in] point at end of line segment</param>
            <returns>true if start and end are distinct points.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLine.IsValid">
            <summary>
Returns: True if from != to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLine.to">
            <summary>
end point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLine.from">
            <summary>
start point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IntersectSurface(RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.ArrayOnX_EVENT@,System.Double,System.Double,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Intersect infinite line with surfaceB.</summary>
            <param name="surfaceB">[in]</param>
            <param name="x">[out] Intersection events are appended to this array.</param>
            <param name="intersection_tolerance">
[in] If the distance from a point on this line to the surface is &lt;= intersection tolerance,
then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0,
then 0.001 is used.
</param>
            <param name="overlap_tolerance">
[in] If t1 and t2 are curve parameters of intersection events and
the distance from line(t) to the surface is &lt;= overlap_tolerance
for every t1 &lt;= t &lt;= t2, then the event will be returened as an
overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used.
</param>
            <param name="line_domain">
[in] optional restriction on line's domain If you want a finite intersection,
then specify a line_domain. If you want a ray intersection, then specify a line
domain like (0.0, ON_DBL_MAX).
</param>
            <param name="surfaceB_udomain">[in] optional restriction on surfaceB u domain</param>
            <param name="surfaceB_vdomain">[in] optional restriction on surfaceB v domain</param>
            <returns>Number of intersection events appended to x.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from this line to the other object is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <returns>True if if the shortest distance from this line to the other object is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the longest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &gt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="L">[in] (another finite chord)</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Finds the shortest distance between the line as a finite chord and the other object.
</summary>
            <param name="P">[in]</param>
            <returns>
A value d such that if Q is any point on this line and P is any point
on the other object, then d &lt;= Q.DistanceTo(P).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>
distance from the point on the line that is closest to test_point.
See Also: ON_3dPoint::DistanceTo ON_Line::ClosestPointTo
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <returns>The point on the line that is closest to test_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>Find the point on the (infinite) line that is closest to the test_point.</summary>
            <param name="test_point">[in]</param>
            <param name="t">[out] line.PointAt(*t) is the point on the line that is closest to test_point.</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.PointAt(System.Double)">
            <summary>Evaluate point on (infinite) line.</summary>
            <param name="t">
[in] evaluation parameter.
t=0 returns line.from and t=1 returns line.to.
</param>
            <returns>
(1-t)*line.from + t*line.to.
See Also: ON_Line::Direction ON_Line::Tangent
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.Tangent">
            <summary>
Returns: Unit tangent vector.
See Also: ON_Line::Direction
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.Direction">
            <summary>
Returns: direction vector = line.to - line.from
See Also: ON_Line::Tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.Length">
            <summary>
Returns: Length of line
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.InPlane(RMA.OpenNURBS.OnPlane@)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.InPlane(RMA.OpenNURBS.OnPlane@,System.Double)">
            <summary>Get a plane that contains the line.</summary>
            <param name="plane">
[out] a plane that contains the line.
The orgin of the plane is at the start of the line.
The distance from the end of the line to the plane is &lt;= tolerance.
If possible a plane parallel to the world xy, yz or zx plane is returned.
</param>
            <param name="tolerance">[in]</param>
            <returns>true if a coordinate of the line's direction vector is larger than tolerance.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false)
If true and the input tight_bbox is valid, then returned tight_bbox is
the union of the input tight_bbox and the line's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL)
If not NULL, the tight bounding box of the transformed line is calculated.
The line is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get line's 3d axis aligned bounding box or the union of the input box
with the object's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true, then the union of the input bbox and the
object's bounding box is returned in bbox.
If false, the object's bounding box is returned in bbox.
</param>
            <returns>true if object has bounding box and calculation was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.BoundingBox">
            <summary>Get line's 3d axis aligned bounding box.</summary>
            <returns>3d bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLine.IsValid">
            <summary>
Returns: True if from != to.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLine.to">
            <summary>
end point
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLine.from">
            <summary>
start point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsCSXEvent">
            <summary>
Returns: True if m_type is csx_point or csx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsCCXEvent">
            <summary>
Returns: True if m_type is ccx_point or ccx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsOverlapEvent">
            <summary>
Returns: True if m_type is ccx_overlap or csx_overlap.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsPointEvent">
            <summary>
Returns: True if m_type is ccx_point or csx_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.OverlapTolerance(System.Double,System.Double)">
            <summary>Convert input intersection tolerance to value used in calculations.</summary>
            <param name="intersection_tolerance">[in]</param>
            <returns>Value use in intersection calculations.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IntersectionTolerance(System.Double)">
            <summary>Convert input intersection tolerance to value used in calculations.</summary>
            <param name="intersection_tolerance">[in]</param>
            <returns>Value use in intersection calculations.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.CopyEventPart(RMA.OpenNURBS.IOnX_EVENT,System.Int32,RMA.OpenNURBS.OnX_EVENT@,System.Int32)">
            <summary>
Expert user tool to copy portions of the itersection event information
from one event to another. If src.m_type is ON_X_EVENT::csx_*, then the
m_b[] and m_nodeB_t[] values are treated as surface parameters,
otherwise the values are treated as curve parameters.  The m_type field
is not copied.
</summary>
            <param name="src">[in]</param>
            <param name="src_end">[in] 0 or 1 (m_A[] source index)</param>
            <param name="dst">[out]</param>
            <param name="dst_end">[in] 0 or 1 (m_A[] destination index)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.IsValid(RMA.OpenNURBS.OnTextLog,System.Double,System.Double,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Check intersection event values to make sure they are valid.</summary>
            <param name="text_log">
[in] If not null and an error is found, then a description of the error is printed to text_log.
</param>
            <param name="intersection_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="overlap_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="curveA">[in] NULL or curveA passed to intersection calculation.</param>
            <param name="curveA_domain">[in] NULL or curveA domain used in intersection calculation.</param>
            <param name="curveB">[in] NULL or curveB passed to intersection calculation.</param>
            <param name="curveB_domain">[in] NULL or curveB domain used in intersection calculation.</param>
            <param name="surfaceB">[in] NULL or surfaceB passed to intersection calculation.</param>
            <param name="surfaceB_domain0">[in] NULL or surfaceB "u" domain used in intersection calculation.</param>
            <param name="surfaceB_domain1">[in] NULL or surfaceB "v" domain used in intersection calculation.</param>
            <returns>True if event is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.Compare(RMA.OpenNURBS.IOnX_EVENT,RMA.OpenNURBS.IOnX_EVENT)">
            <summary>Compares intersection events and sorts them in the canonical order.</summary>
            <returns>
-1    this  &lt; other
0    this == other
+1    this  &gt; other
</returns>
            <remarks>ON_CX_EVENT::Compare is used to sort intersection events into canonical order.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnX_EVENT.#ctor">
            <summary>
Default construction sets everything to zero.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_x_eventsn">
            <summary>
There are cases when it is valuable to have direction
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_nodeB_t(System.Int32)">
            <summary>
nodeB bezier paramters corresponding to b[] values.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_nodeA_t(System.Int32)">
            <summary>
nodeA bezier paramters corresponding to a[] values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_dirB(System.Int32)">
            <summary>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_dirA(System.Int32)">
            <summary>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_b(System.Int32)">
            <summary>
intersection parameters on second curve or surface
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_a(System.Int32)">
            <summary>
intersection parameters on first curve
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_pointB(System.Int32)">
            <summary>
intersection points on second curve or surface
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnX_EVENT.m_pointA(System.Int32)">
            <summary>
intersection points on first curve
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnX_EVENT">
            <summary>
The ON_X_EVENT class is used to report curve-curve and curve-surface
intersection events.
The m_type field determines how the values in the other
fields are interpreted.  See the detailed comment below
for complete informtion

The m_type field determines how the values in the other
fields are interpreted.

 ccx_point events:
   a[0] = a[1] = first curve parameter
   pointA[0] = pointA[1] = intersection point on first curve
   b[0] = b[1] = second curve parmeter
   pointB[0] = pointB[1] = intersection point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = cnodeA[1] = pointer to first curve's tree node
   cnodeB[0] = cnodeB[1] = pointer to second curve's tree node
   snodeB[0] = snodeB[1] = 0

 ccx_overlap events:
   (a[0],a[1]) = first curve parameter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = second curve parameter range (b[0] != b[1])
   pointB[0] = intersection start point on second curve
   pointB[1] = intersection end point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = pointer to first curve's tree node for start point
   cnodeA[1] = pointer to first curve's tree node for end point
   cnodeB[0] = pointer to second curve's tree node for start point
   cnodeB[1] = pointer to second curve's tree node for end point
   snodeB[0] = snodeB[1] = 0

csx_point events:
   a[0] = a[1] = curve parameter
   pointA[0] = pointA[1] = intersection point on curve
   (b[0],b[1]) = (b[2],b[3]) = surface parameter
   pointB[0] = pointB[1] intersection point on surface
   cnodeA[0] = cnodeA[1] = pointer to curve's tree node
   cnodeB[0] = cnodeB[1] = 0;
   snodeB[0] = snodeB[1] = pointer to surface's tree node

 csx_overlap events:
   (a[0],a[1]) = curve parmamter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = surface parameter for curve(a[0]).
   pointB[0] = intersection start point on surface
   (b[2],b[3]) = surface parameter for curve(a[1]).
   pointB[1] = intersection end point on surface
   cnodeA[0] = pointer to curve's tree node for start point
   cnodeA[1] = pointer to curve's tree node for end point
   snodeB[0] = pointer to surface's tree node for start point
   snodeB[1] = pointer to surface's tree node for end point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsCSXEvent">
            <summary>
Returns: True if m_type is csx_point or csx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsCCXEvent">
            <summary>
Returns: True if m_type is ccx_point or ccx_overlap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsOverlapEvent">
            <summary>
Returns: True if m_type is ccx_overlap or csx_overlap.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsPointEvent">
            <summary>
Returns: True if m_type is ccx_point or csx_point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnX_EVENT.IsValid(RMA.OpenNURBS.OnTextLog,System.Double,System.Double,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnCurve,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnSurface,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Check intersection event values to make sure they are valid.</summary>
            <param name="text_log">
[in] If not null and an error is found, then a description of the error is printed to text_log.
</param>
            <param name="intersection_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="overlap_tolerance">[in] 0.0 or value used in intersection calculation.</param>
            <param name="curveA">[in] NULL or curveA passed to intersection calculation.</param>
            <param name="curveA_domain">[in] NULL or curveA domain used in intersection calculation.</param>
            <param name="curveB">[in] NULL or curveB passed to intersection calculation.</param>
            <param name="curveB_domain">[in] NULL or curveB domain used in intersection calculation.</param>
            <param name="surfaceB">[in] NULL or surfaceB passed to intersection calculation.</param>
            <param name="surfaceB_domain0">[in] NULL or surfaceB "u" domain used in intersection calculation.</param>
            <param name="surfaceB_domain1">[in] NULL or surfaceB "v" domain used in intersection calculation.</param>
            <returns>True if event is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_x_eventsn">
            <summary>
There are cases when it is valuable to have direction
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_nodeB_t(System.Int32)">
            <summary>
nodeB bezier paramters corresponding to b[] values.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_nodeA_t(System.Int32)">
            <summary>
nodeA bezier paramters corresponding to a[] values
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_dirB(System.Int32)">
            <summary>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_dirA(System.Int32)">
            <summary>
There are cases when it is valuable to have direction
flags on intersection events.  The m_dirA[] and m_dirB[]
fields provide a place to store these flags.  Because this
information is rarely used, it is not computed by the
intersection routines.  You can use
 ON_SetCurveCurveIntersectionDir 
or
 ON_SetCurveSurfaceIntersectionDir
to fill in these fields.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_b(System.Int32)">
            <summary>
intersection parameters on second curve or surface
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_a(System.Int32)">
            <summary>
intersection parameters on first curve
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_pointB(System.Int32)">
            <summary>
intersection points on second curve or surface
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnX_EVENT.m_pointA(System.Int32)">
            <summary>
intersection points on first curve
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_EVENT.DIRECTION">
            <summary>
Event directions for use in the m_dirA[] and m_dirB[]
fields. The "x_from_*" values are used to report the 
behavior of the curve as it enters the intersection 
event. The "x_to_*" values are used to report the 
behavior of the curve as it leaves the intersection
event.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnX_EVENT">
            <summary>
The ON_X_EVENT class is used to report curve-curve and curve-surface
intersection events.
The m_type field determines how the values in the other
fields are interpreted.  See the detailed comment below
for complete informtion

The m_type field determines how the values in the other
fields are interpreted.

 ccx_point events:
   a[0] = a[1] = first curve parameter
   pointA[0] = pointA[1] = intersection point on first curve
   b[0] = b[1] = second curve parmeter
   pointB[0] = pointB[1] = intersection point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = cnodeA[1] = pointer to first curve's tree node
   cnodeB[0] = cnodeB[1] = pointer to second curve's tree node
   snodeB[0] = snodeB[1] = 0

 ccx_overlap events:
   (a[0],a[1]) = first curve parameter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = second curve parameter range (b[0] != b[1])
   pointB[0] = intersection start point on second curve
   pointB[1] = intersection end point on second curve
   b[2] = b[3] = not used
   cnodeA[0] = pointer to first curve's tree node for start point
   cnodeA[1] = pointer to first curve's tree node for end point
   cnodeB[0] = pointer to second curve's tree node for start point
   cnodeB[1] = pointer to second curve's tree node for end point
   snodeB[0] = snodeB[1] = 0

csx_point events:
   a[0] = a[1] = curve parameter
   pointA[0] = pointA[1] = intersection point on curve
   (b[0],b[1]) = (b[2],b[3]) = surface parameter
   pointB[0] = pointB[1] intersection point on surface
   cnodeA[0] = cnodeA[1] = pointer to curve's tree node
   cnodeB[0] = cnodeB[1] = 0;
   snodeB[0] = snodeB[1] = pointer to surface's tree node

 csx_overlap events:
   (a[0],a[1]) = curve parmamter range (a[0] &lt; a[1])
   pointA[0] = intersection start point on first curve
   pointA[1] = intersection end point on first curve
   (b[0],b[1]) = surface parameter for curve(a[0]).
   pointB[0] = intersection start point on surface
   (b[2],b[3]) = surface parameter for curve(a[1]).
   pointB[1] = intersection end point on surface
   cnodeA[0] = pointer to curve's tree node for start point
   cnodeA[1] = pointer to curve's tree node for end point
   snodeB[0] = pointer to surface's tree node for start point
   snodeB[1] = pointer to surface's tree node for end point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
parameterization of NURBS curve does not match ellipse's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
rotate ellipse about a point and axis
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>
rotate ellipse about its center
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate ellipse's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.CurvatureAt(System.Double)">
            <summary>
returns curvature vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.TangentAt(System.Double)">
            <summary>
returns unit tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.DerivativeAt(System.Int32,System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
            <param name="derivative">desired derivative ( &gt;= 0 )</param>
            <param name="t">parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.PointAt(System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.FocalDistance">
            <summary>
Returns: Distance between foci, commanly called "2c".
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.GetPlane">
            <summary>
plane containing ellipse
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.GetRadius(System.Int32)">
            <param name="axis">0 = x axis radius, 1 = y axis radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.IsCircle">
            <summary>
returns TRUE is ellipse is a circle
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.#ctor(RMA.OpenNURBS.IOnPlane,System.Double,System.Double)">
            <param name="x">radius for x vector</param>
            <param name="y">radius for y vector</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnEllipse.#ctor">
            <summary>
zeros all fields - plane is invalid
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEllipse.radius(System.Int32)">
            <summary>
radii for x and y axes (both must be &gt; 0)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnEllipse.plane">
            <summary>
The center of the ellipse is at the plane's origin.  The axes of the
ellipse are the plane's x and y axes. The equation of the ellipse
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
parameterization of NURBS curve does not match ellipse's transcendental paramaterization
</summary>
            <returns>0=failure, 2=success</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate ellipse's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on ellipse that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.CurvatureAt(System.Double)">
            <summary>
returns curvature vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.TangentAt(System.Double)">
            <summary>
returns unit tangent
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.DerivativeAt(System.Int32,System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
            <param name="derivative">desired derivative ( &gt;= 0 )</param>
            <param name="t">parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.PointAt(System.Double)">
            <summary>
Evaluation uses the trigonometrix parameterization
t -&gt; plane.origin + cos(t)*radius[0]*plane.xaxis + sin(t)*radius[1]*plane.yaxis
evaluate parameters and return point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.FocalDistance">
            <summary>
Returns: Distance between foci, commanly called "2c".
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.GetPlane">
            <summary>
plane containing ellipse
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.GetRadius(System.Int32)">
            <param name="axis">0 = x axis radius, 1 = y axis radius</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.IsCircle">
            <summary>
returns TRUE is ellipse is a circle
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnEllipse.IsValid">
            <summary>
returns TRUE if all fields contain reasonable information and equation jibes with point and Z.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEllipse.radius(System.Int32)">
            <summary>
radii for x and y axes (both must be &gt; 0)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnEllipse.plane">
            <summary>
The center of the ellipse is at the plane's origin.  The axes of the
ellipse are the plane's x and y axes. The equation of the ellipse
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>
Convert a circle radians parameter to a NURBS curve circle parameter.
</summary>
            <param name="circle_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double circle_t = 1.2345; // some number in interval (0,2.0*ON_PI). 
double nurbs_t;
circle.GetNurbFormParameterFromRadian( circle_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At radian values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and
radian parameter are the same. At all other values the nurbs and radian parameter values are
different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>
Convert a NURBS curve circle parameter to a circle radians parameter.
</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="circle_radians_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double circle_t;
circle.GetRadianFromNurbFormParameter( nurbs_t, &amp;circle_t );
ON_NurbsCurve nurbs_curve; circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
parameter and radian parameter are the same. At all other values the nurbs and radian parameter
values are different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a four span rational degree 2 NURBS circle representation
of the circle.
</summary>
            <returns>2 for success, 0 for failure</returns>
            <remarks>
Note that the parameterization of NURBS curve
does not match  circle's transcendental paramaterization.  
Use ON_Circle::GetRadianFromNurbFormParameter() and
ON_Circle::GetParameterFromRadian() to convert between 
the NURBS curve parameter and the transcendental parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate circle about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>rotate circle about a point and axis</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate circle about its center</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>rotate circle about its center</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate circle's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.TangentAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.DerivativeAt(System.Int32,System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="derivative">&gt;=0</param>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.PointAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed arc is calculated.
The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.IsValid">
            <summary>
A Valid circle has m_radius&gt;0 and m_plane.IsValid().
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a circle from two 3d points and a 
tangent at the first point.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dVector,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create a circle from two 2d points and a 
tangent at the first point.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a circle through three 3d points.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
circle through 3 2d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the plane
with given centr and radius.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the world XY plane
with given center and radius
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.Create(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Creates a circle in the plane with center at
plane.origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Create a circle through three 3d points.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
Create a circle through three 2d points.
The start/end of the circle is at point P.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the plane
with given center and radius.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>
Creates a circle parallel to the world XY plane
with given center and radius
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor(RMA.OpenNURBS.IOnPlane,System.Double)">
            <summary>
Creates a circle in the plane with center at
plane.origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCircle.#ctor">
            <summary>
Creates a radius one circle with center (0,0,0)
in the world XY plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCircle.radius">
            <summary>
radius
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCircle.plane">
            <summary>
circle is in the plane with center at plane.m_origin.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnCircle">
            <summary>
ON_Circle is a circle in 3d.  The cirle is represented by a radius and an 
orthonormal frame	of the plane containing the circle, with origin at the center.

An Is_Valid() circle has positive radius and an Is_ Valid() plane defining the frame.

The circle is parameterized by radians from 0 to 2 Pi given by 
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where center, xaxis and yaxis define the orthonormal frame of the circle's plane.  
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetNurbFormParameterFromRadian(System.Double,System.Double@)">
            <summary>
Convert a circle radians parameter to a NURBS curve circle parameter.
</summary>
            <param name="circle_radians_parameter">[in] 0.0 to 2.0*ON_PI</param>
            <param name="nurbs_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double circle_t = 1.2345; // some number in interval (0,2.0*ON_PI). 
double nurbs_t;
circle.GetNurbFormParameterFromRadian( circle_t, &amp;nurbs_t );
ON_NurbsCurve nurbs_curve;
circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At radian values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs parameter and
radian parameter are the same. At all other values the nurbs and radian parameter values are
different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
            <summary>
Convert a NURBS curve circle parameter to a circle radians parameter.
</summary>
            <param name="nurbs_parameter">[in]</param>
            <param name="circle_radians_parameter">[out]</param>
            <example>
ON_Circle circle = ...;
double nurbs_t = 1.2345; // some number in interval (0,2.0*ON_PI).
double circle_t;
circle.GetRadianFromNurbFormParameter( nurbs_t, &amp;circle_t );
ON_NurbsCurve nurbs_curve; circle.GetNurbsForm( nurbs_curve );
circle_pt = circle.PointAt(circle_t);
nurbs_pt = nurbs_curve.PointAt(nurbs_t); // circle_pt and nurbs_pt will be the same
</example>
            <remarks>
The NURBS curve parameter is with respect to the NURBS curve created by ON_Circle::GetNurbForm.
At nurbs parameter values of 0.0, 0.5*ON_PI, ON_PI, 1.5*ON_PI, and 2.0*ON_PI, the nurbs
parameter and radian parameter are the same. At all other values the nurbs and radian parameter
values are different.
See Also: ON_Circle::GetNurbFormParameterFromRadian
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetNurbForm(RMA.OpenNURBS.OnNurbsCurve@)">
            <summary>
Get a four span rational degree 2 NURBS circle representation
of the circle.
</summary>
            <returns>2 for success, 0 for failure</returns>
            <remarks>
Note that the parameterization of NURBS curve
does not match  circle's transcendental paramaterization.  
Use ON_Circle::GetRadianFromNurbFormParameter() and
ON_Circle::GetParameterFromRadian() to convert between 
the NURBS curve parameter and the transcendental parameter.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.EquationAt(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
evaluate circle's implicit equation in plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
returns point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@)">
            <summary>
returns parameters of point on circle that is closest to given point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.TangentAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.DerivativeAt(System.Int32,System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="derivative">&gt;=0</param>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.PointAt(System.Double)">
            <summary>
Circles use trigonometric parameterization
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis
</summary>
            <param name="t">evaluation parameter</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] (default=false) If true and the input tight_bbox is valid,
then returned tight_bbox is the union of the input tight_bbox and
the arc's tight bounding box.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed arc is calculated.
The arc is not modified.
</param>
            <returns>True if a valid tight_bbox is returned.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCircle.IsValid">
            <summary>
A Valid circle has m_radius&gt;0 and m_plane.IsValid().
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCircle.radius">
            <summary>
radius
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCircle.plane">
            <summary>
circle is in the plane with center at plane.m_origin.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCircle">
            <summary>
ON_Circle is a circle in 3d.  The cirle is represented by a radius and an 
orthonormal frame	of the plane containing the circle, with origin at the center.

An Is_Valid() circle has positive radius and an Is_ Valid() plane defining the frame.

The circle is parameterized by radians from 0 to 2 Pi given by 
t -&gt; center + cos(t)*radius*xaxis + sin(t)*radius*yaxis	
where center, xaxis and yaxis define the orthonormal frame of the circle's plane.  
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnClippingPlane.m_bEnabled">
            <summary>
true if this clipping plane is active
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnClippingPlane.m_bEnabled">
            <summary>
true if this clipping plane is active
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Flip">
            <summary>
Flip plane orientation by swapping x and y axes, reversing the zaxis, and updating the equation.
</summary>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translate a plane.</summary>
            <param name="delta">[in] translation vector</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Rotate a plane about a point.</summary>
            <param name="angle">[in] rotation angle in radians</param>
            <param name="axis">[in] axis of rotation</param>
            <param name="center">[in] center of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Rotate a plane about a point.</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] cosine of rotation angle</param>
            <param name="axis">[in] axis of rotation</param>
            <param name="center">[in] center of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>Rotate a plane about its origin.</summary>
            <param name="angle">[in] rotation angle in radians</param>
            <param name="axis">[in] axis of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector)">
            <summary>Rotate a plane about its origin.</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] cosine of rotation angle</param>
            <param name="axis">[in] axis of rotation</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.SwapCoordinates(System.Int32,System.Int32)">
            <summary>Transform a plane by swapping coordinates.</summary>
            <param name="i">
[in] indices of coordinates to swap.
0 = x coordinate, 1 = y coordinate, 2 = z coordinate.
</param>
            <param name="j">
[in] indices of coordinates to swap.
0 = x coordinate, 1 = y coordinate, 2 = z coordinate.
</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Morph(RMA.OpenNURBS.IOnSpaceMorph)">
            <summary>Morph plane.</summary>
            <param name="morph">[in] morph to apply to plane</param>
            <returns>TRUE if successful</returns>
            <remarks>The resulting plane still has an orthonormal frame</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transform plane.</summary>
            <param name="xform">[in] transformation to apply to plane</param>
            <returns>TRUE if successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="point">[in]</param>
            <returns>A 3d point on the plane that is closest to world_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="world_point">[in] 3d point</param>
            <param name="u">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <param name="v">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.UpdateEquation">
            <summary>Update the plane equation based on the current values of the origin and zaxis.</summary>
            <returns>TRUE if successful. FALSE if zaxis is zero.</returns>
            <remarks>If you modify a plane's origin or zaxis, call UpdateEquation() to set equation[].</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetDistanceToBoundingBox(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <returns>false if plane has zero length normal</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get signed distance from the plane to a point.</summary>
            <param name="point">[in]</param>
            <returns>Signed distance from a point to a plane.</returns>
            <remarks>
If the point is on the plane, the distance is 0.
If the point is above the plane, the distance is &gt; 0.
If the point is below the plane the distance is &lt; 0.
The zaxis determines the plane's orientation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.IsoLine(System.Int32,System.Double)">
            <summary>Get an isoparameteric line on the plane.</summary>
            <param name="dir">
[in] direction of iso-parametric line
0: first parameter varies and second parameter is constant e.g., line(t) = plane(t,c)
1: first parameter is constant and second parameter varies e.g., line(t) = plane(c,t)
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>iso-parametric line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <param name="w">[in] elevation parameter</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.PointAt(System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.SetOrigin(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Set the origin and update the plane equation</summary>
            <param name="origin">[in] the new origin</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.Normal">
            <summary>
Returns: Plane unit normal.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetYaxis">
            <summary>
Returns: Plane unit y-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetXaxis">
            <summary>
Returns: Plane unit x-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.GetOrigin">
            <summary>
Returns: Plane origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.IsValid">
            <summary>Test plane to see if it is valid.</summary>
            <returns>TRUE if all fields contain reasonable information and equation jibes with point and zaxis.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromEquation(System.Double[])">
            <summary>Construct a plane from an equation.</summary>
            <param name="equation">
[in] an array of 4 doubles with one of equation[0], equation[1], or equation[2] being non-zero.
</param>
            <remarks>
points on the plane will satisfy x*equation[0] +y*equation[1] + z*equation[2] + equation[3] = 0
</remarks>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromPoints(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Construct a plane from three non-colinear points.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="point_on_x">[in] second point in the plane. The xaxis will be parallel to x_point-origin.</param>
            <param name="point_on">
[in] third point on the plane that is not colinear with the first two points.
yaxis*(y_point-origin) will be &gt; 0.
</param>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromFrame(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Construct a plane from a point, and two vectors in the plane.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="x_dir">[in] non-zero vector in the plane that determines the xaxis direction.</param>
            <param name="y_dir">
[in] non-zero vector not parallel to x_dir that is used to determine the yaxis direction.
y_dir does not have to be perpindicular to x_dir.
</param>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.CreateFromNormal(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Create a plane from a point and normal vector.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="normal">[in] non-zero normal to the plane</param>
            <remarks>
origin = point, zaxis = unitized normal, xaxis
xaxis set with xaxis.PerpindicularTo(zaxis).
</remarks>
            <returns>TRUE if valid plane is created.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(System.Double[])">
            <summary>Construct a plane from an equation.</summary>
            <param name="equation">
[in] an array of 4 doubles with one of equation[0], equation[1], or equation[2] being non-zero.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>Construct a plane from three non-colinear points.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="x_point">[in] second point in the plane. The xaxis will be parallel to x_point-origin.</param>
            <param name="y_point">
[in] third point on the plane that is not colinear with the first two points.
yaxis*(y_point-origin) will be &gt; 0.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Construct a plane from a point, and two vectors in the plane.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="x_dir">[in] non-zero vector in the plane that determines the xaxis direction.</param>
            <param name="y_dir">
[in] non-zero vector not parallel to x_dir that is used to determine the yaxis direction.
y_dir does not have to be perpindicular to x_dir.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Construct a plane from a point and normal vector.</summary>
            <param name="origin">[in] point on the plane</param>
            <param name="normal">[in] non-zero normal to the plane</param>
            <remarks>
origin = point, zaxis = unitized normal, xaxis
xaxis set with xaxis.PerpindicularTo(zaxis).
See Also:
ON_Plane::CreateFromNormal
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlane.#ctor">
            <summary>
The default constructor creates a plane with orgin=(0,0,0), xaxis=(1,0,0),
yaxis=(0,1,0) zaxis=(0,0,1), and equation=(0,0,1,0).
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.plane_equation">
            <summary>
equation of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.zaxis">
            <summary>
unit Z axis of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.yaxis">
            <summary>
unit Y axis of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.xaxis">
            <summary>
unit X axis of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.origin">
            <summary>
origin of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlane.World_xy">
            <summary>
world plane coordinate system ON_Plane(ON_origin, ON_xaxis, ON_yaxis);
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="point">[in]</param>
            <returns>A 3d point on the plane that is closest to world_point.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint,System.Double@,System.Double@)">
            <summary>Get point on plane that is closest to a given point.</summary>
            <param name="world_point">[in] 3d point</param>
            <param name="u">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <param name="v">[out] The point ON_Plane::PointAt(*u,*v) is the point on the plane that is closest to world_point.</param>
            <returns>TRUE if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetDistanceToBoundingBox(RMA.OpenNURBS.IOnBoundingBox,System.Double@,System.Double@)">
            <returns>false if plane has zero length normal</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.DistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Get signed distance from the plane to a point.</summary>
            <param name="point">[in]</param>
            <returns>Signed distance from a point to a plane.</returns>
            <remarks>
If the point is on the plane, the distance is 0.
If the point is above the plane, the distance is &gt; 0.
If the point is below the plane the distance is &lt; 0.
The zaxis determines the plane's orientation.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.IsoLine(System.Int32,System.Double)">
            <summary>Get an isoparameteric line on the plane.</summary>
            <param name="dir">
[in] direction of iso-parametric line
0: first parameter varies and second parameter is constant e.g., line(t) = plane(t,c)
1: first parameter is constant and second parameter varies e.g., line(t) = plane(c,t)
</param>
            <param name="c">[in] value of constant parameter</param>
            <returns>iso-parametric line</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.PointAt(System.Double,System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <param name="w">[in] elevation parameter</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis + z*plane.zaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.PointAt(System.Double,System.Double)">
            <summary>Evaluate a point on the plane</summary>
            <param name="u">[in] evaulation parameters</param>
            <param name="v">[in] evaulation parameters</param>
            <returns>plane.origin + u*plane.xaxis + v*plane.yaxis</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.Normal">
            <summary>
Returns: Plane unit normal.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetYaxis">
            <summary>
Returns: Plane unit y-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetXaxis">
            <summary>
Returns: Plane unit x-axis.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.GetOrigin">
            <summary>
Returns: Plane origin.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlane.IsValid">
            <summary>Test plane to see if it is valid.</summary>
            <returns>TRUE if all fields contain reasonable information and equation jibes with point and zaxis.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.plane_equation">
            <summary>
equation of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.zaxis">
            <summary>
unit Z axis of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.yaxis">
            <summary>
unit Y axis of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.xaxis">
            <summary>
unit X axis of plane
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlane.origin">
            <summary>
origin of plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.SetPreserveStructure(System.Boolean)">
            <summary>
Set the preserve structure value.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.PreserveStructure">
            <returns>
True if the morph should be done in a way that preserves the structure of the geometry.
In particular, for NURBS objects, true means that only the control points are moved.
</returns>
            <remarks>
The value returned by PreserveStructure() does not affect the way meshes and
points are morphed. The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.SetQuickPreview(System.Boolean)">
            <summary>
Set the quick preview value.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.QuickPreview">
            <summary>
True if the morph should be done as quickly as possible because the result
is being used for some type of dynamic preview. If QuickPreview is true,
the tolerance may be ignored.
</summary>
            <remarks>
The value returned by QuickPreview() does not affect the way meshes and points are morphed.
The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.SetTolerance(System.Double)">
            <summary>Set the 3d fitting tolerance used when morphing surfaces and breps.</summary>
            <param name="tolerance">[in] values &lt; 0.0 are treated as 0.0.</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.Tolerance">
            <summary>
Returns the desired accuracy of the morph. This value is primarily used for deforming surfaces and breps.
</summary>
            <returns>3d fitting tolerance.</returns>
            <remarks>
The default is 0.0 and any value &lt;= 0.0 is ignored by morphing functions.
The value returned by Tolerance() does not affect the way meshes and points are morphed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.MorphVector(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Morphs vector.</summary>
            <param name="tail_point">[in] tail point</param>
            <param name="vector">[in]</param>
            <returns>Morphed vector.</returns>
            <remarks>Default returns difference of morphed tail+vector and tail.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn4dPoint)">
            <summary>Morphs rational point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>Default morphs euclidean location and preserves weight.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.IsIdentity(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Provides a quick way to determine if a morph function is the identity
(doesn't move the points) on a region of space.
</summary>
            <param name="bbox">[in] region of space to test.</param>
            <returns>
The default always returns false. If you override this function,
then return true when every point in the bounding box is fixed by the morph.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.Ev1Der(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Get the first derivative of the morph function.</summary>
            <param name="rst">[in] evalation parameters</param>
            <param name="Dr">[out] (dx/dr, dy/dr, dz/dr)</param>
            <param name="Ds">[out] (dx/ds, dy/ds, dz/ds)</param>
            <param name="Dt">[out] (dx/dt, dy/dt, dz/dt)</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Morphs euclidean point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>
If you are morphing simple objects like points and meshes, then you can simply morph the locations.
If you are morphing more complicated objects like NURBS geometry, then your override should pay
attention to the values of m_bQuickPreview, m_bPreserveStructure, and m_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.PreserveStructure">
            <returns>
True if the morph should be done in a way that preserves the structure of the geometry.
In particular, for NURBS objects, true means that only the control points are moved.
</returns>
            <remarks>
The value returned by PreserveStructure() does not affect the way meshes and
points are morphed. The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.QuickPreview">
            <summary>
True if the morph should be done as quickly as possible because the result
is being used for some type of dynamic preview. If QuickPreview is true,
the tolerance may be ignored.
</summary>
            <remarks>
The value returned by QuickPreview() does not affect the way meshes and points are morphed.
The default is false.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.Tolerance">
            <summary>
Returns the desired accuracy of the morph. This value is primarily used for deforming surfaces and breps.
</summary>
            <returns>3d fitting tolerance.</returns>
            <remarks>
The default is 0.0 and any value &lt;= 0.0 is ignored by morphing functions.
The value returned by Tolerance() does not affect the way meshes and points are morphed.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.MorphVector(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Morphs vector.</summary>
            <param name="tail_point">[in] tail point</param>
            <param name="vector">[in]</param>
            <returns>Morphed vector.</returns>
            <remarks>Default returns difference of morphed tail+vector and tail.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn4dPoint)">
            <summary>Morphs rational point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>Default morphs euclidean location and preserves weight.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.IsIdentity(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Provides a quick way to determine if a morph function is the identity
(doesn't move the points) on a region of space.
</summary>
            <param name="bbox">[in] region of space to test.</param>
            <returns>
The default always returns false. If you override this function,
then return true when every point in the bounding box is fixed by the morph.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.Ev1Der(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@,RMA.OpenNURBS.On3dVector@)">
            <summary>Get the first derivative of the morph function.</summary>
            <param name="rst">[in] evalation parameters</param>
            <param name="Dr">[out] (dx/dr, dy/dr, dz/dr)</param>
            <param name="Ds">[out] (dx/ds, dy/ds, dz/ds)</param>
            <param name="Dt">[out] (dx/dt, dy/dt, dz/dt)</param>
            <returns>True if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnSpaceMorph.MorphPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Morphs euclidean point.</summary>
            <param name="point">[in]</param>
            <returns>Morphed point.</returns>
            <remarks>
If you are morphing simple objects like points and meshes, then you can simply morph the locations.
If you are morphing more complicated objects like NURBS geometry, then your override should pay
attention to the values of m_bQuickPreview, m_bPreserveStructure, and m_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.IsZero(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Returns: True if localizer is identically zero inside bbox.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.Value(System.Double)">
            <summary>Evaluators</summary>
            <param name="distance">[in] Evaluation distance</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.Value(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluators</summary>
            <param name="P">[in] Evaluation point</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.CreateSphereLocalizer(RMA.OpenNURBS.IOn3dPoint,System.Double,System.Double)">
            <summary>
Creates a spherical localizer. If d = distance from the point to the center of the sphere,
then the localizer has the following behavior: 
point distance                    localizer value
d &lt;= r0 &lt; r1 or d &gt;= r0 &gt; r1 0
d &gt;= r1 &gt; r0 or d &lt;= r1 &lt; r0 1 
For values of d between r0 and r1, the localizer smoothly transitions between 0 to 1.
</summary>
            <param name="P">[in] center of sphere</param>
            <param name="r0">[in]see r1</param>
            <param name="r1">
[in] r0 and r1 are radii that control where the localizer is nonzero.
Both r0 and r1 must be postive and the cannot be equal.
If 0 &lt; r0 &lt; r1, then the localizer is zero for points inside the
cylinder of radius r0 and one for points outside the cylinder of radius r1.
If 0 &lt; r1 &lt; r0, then the localizer is one for points inside the
cylinder of radius r1 and zero for points outside the cylinder of radius r0.
</param>
            <returns>True if the input is value and the localizer is initialized.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.CreatePlaneLocalizer(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double)">
            <summary>
Creates a planar localizer. If d = signed distance from the point to the plane,
then the localizer has the following behavior:
point distance                    localizer value
d &lt;= h0 &lt; h1 or d &gt;= h0 &gt; h1 0
d &gt;= h1 &gt; h0 or d &lt;= h1 &lt; h0 1
For values of d between h0 and h1, the localizer smoothly transitions between 0 to 1.
</summary>
            <param name="P">[in] point on plane</param>
            <param name="N">[in] normal to plane</param>
            <param name="h0">[in] h0 and h1 are signed distances that control where the localizer is nonzero.</param>
            <param name="h1">[in] h0 and h1 are signed distances that control where the localizer is nonzero.</param>
            <returns>True if the input is value and the localizer is initialized.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnLocalizer.CreateCylinderLocalizer(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,System.Double,System.Double)">
            <summary>
Creates a cylindrical localizer. If d = distance from the point to the line, then the
localizer has the following behavior:
point distance                    localizer value
d &lt;= r0 &lt; r1 or d &gt;= r0 &gt; r1 0
d &gt;= r1 &gt; r0 or d &lt;= r1 &lt; r0 1
For values of d between r0 and r1, the localizer smoothly transitions between 0 to 1.
</summary>
            <param name="P">[in] cylinder axis point</param>
            <param name="D">[in] cylinder axis direction</param>
            <param name="r0">[in] see r1</param>
            <param name="r1">
[in] r0 and r1 are radii that control where the localizer is nonzero.
Both r0 and r1 must be postive and the cannot be equal. If 0 &lt; r0 &lt; r1,
then the localizer is zero for points inside the cylinder of radius r0
and one for points outside the cylinder of radius r1. If 0 &lt; r1 &lt; r0,
then the localizer is one for points inside the cylinder of radius r1 and
zero for points outside the cylinder of radius r0.
</param>
            <returns>True if the input is value and the localizer is initialized.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLocalizer.IsZero(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Returns: True if localizer is identically zero inside bbox.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLocalizer.Value(System.Double)">
            <summary>Evaluators</summary>
            <param name="distance">[in] Evaluation distance</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnLocalizer.Value(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Evaluators</summary>
            <param name="P">[in] Evaluation point</param>
            <returns>Value of the localizer.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.GetLineClipPlaneParamters(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.IOn4dPoint,System.Double@,System.Double@)">
            <summary>Calculate the interval for the segment of a line that is in the clip plane region.</summary>
            <param name="P0">[in] start point</param>
            <param name="P1">[in] end point</param>
            <param name="t0">[out] start parameter</param>
            <param name="t1">[out] end parameter</param>
            <returns>
True if some portion of the line is visible and
0.0 &lt;= *t0 &lt;= *t1 &lt;= 1.0.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3fPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.On4dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnClippingRegion.m_clip_plane_count">
            <summary>
Up to 25 additional clipping planes in object coordinates.
The convex region that is the intersection of the positive 
side of these planes is the active region.
(0 &lt;= m_clip_plane_count &lt;= max_clip_plane_count)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnClippingRegion.m_xform">
            <summary>
The transformation m_xform transforms the view frustum,
in object coordinates to the (-1,+1)^3 clipping 
coordinate box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.GetLineClipPlaneParamters(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.IOn4dPoint,System.Double@,System.Double@)">
            <summary>Calculate the interval for the segment of a line that is in the clip plane region.</summary>
            <param name="P0">[in] start point</param>
            <param name="P1">[in] end point</param>
            <param name="t0">[out] start parameter</param>
            <param name="t1">[out] end parameter</param>
            <returns>
True if some portion of the line is visible and
0.0 &lt;= *t0 &lt;= *t1 &lt;= 1.0.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3fPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.On3dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.TransformPoint(RMA.OpenNURBS.IOn4dPoint,RMA.OpenNURBS.On4dPoint@)">
            <summary>Transform a pont and return the clipping information.</summary>
            <param name="P">[in] point ot transform</param>
            <param name="Q">[out] transformed point</param>
            <returns>
0 when the point is in the visible region.
Otherwise the bits are set to indicate which planes clip the intput point.
0x01 left of the view frusturm
0x02 right of the view frustum
0x04 below the view frustum
0x08 above the view frustum
0x10 behind the view frustum (too far)
0x20 in front of the view frustum (too near)
0x10 below m_clip_plane[0]
0x20 below m_clip_plane[1]
...
0x40000000 below m_clip_plane[24]
0x80000000 transformation created a non-positive weight
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.IsVisible(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "visible area" is the intersection of the view frustum, defined by m_xform,
and the clipping region, defined by the m_clip_plane[] array. These functions determing
if some portion of the convex hull of the test points is visible.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = no part of the object is in the region.
1 = a portion of the object is in the region
2 = entire object is in clipping region
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InClipPlaneRegion(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "clip plane region" is the convex hull of the planes in the m_clip_plane[] array.
These functions determine if some portion of the convex hull of the test points is inside the
clip plane region.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the clip plane region.
1 = A portion of the convex hull of the tested points may be in the clip plane region.
2 = The entire convex hull of the tested points is in the clip plane region.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn4dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IArrayOn3fPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="bbox">[in] bounding box</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnClippingRegion.InViewFrustum(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The "view frustum" is the frustum the m_xform transformation maps to clipping
coordinate box (-1,+1)^3. These functions determine if some portion of the convex hull
of the test points is inside the view frustum.
</summary>
            <param name="P">[in] point</param>
            <returns>
0 = No part of the of the convex hull of the tested points is in the view frustum.
1 = A portion of the convex hull of the otested points may be in the view frustum.
2 = The entire convex hull of the tested points is in the view frustum.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnClippingRegion.m_clip_plane_count">
            <summary>
Up to 25 additional clipping planes in object coordinates.
The convex region that is the intersection of the positive 
side of these planes is the active region.
(0 &lt;= m_clip_plane_count &lt;= max_clip_plane_count)
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnClippingRegion.m_xform">
            <summary>
The transformation m_xform transforms the view frustum,
in object coordinates to the (-1,+1)^3 clipping 
coordinate box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IntervalChange(System.Int32,RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>Calculates the transformation that linearly maps old_interval to new_interval.</summary>
            <param name="dir">[in] 0 = x, 1 = y, 2= z;</param>
            <param name="old_interval">[in]</param>
            <param name="new_interval">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ScreenToClip(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
Computes transform that maps the screen box
   (left,right) X (bottom,top) X (near,far)

to the clipping box 
   -1&lt;x&lt;1,-1&lt;y&lt;1,-1&lt;z&lt;1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ClipToScreen(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
Computes transform that maps the clipping box 
    -1&lt;x&lt;1,-1&lt;y&lt;1,-1&lt;z&lt;1 
to the screen box
    (left,right) X (bottom,top) X (near,far)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ClipToCamera(System.Boolean,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
maps -1 &lt;= x,y,z &lt;= 1 box to viewport frustum
</summary>
            <param name="perspective">true for perspective, false for orthographic</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.CameraToClip(System.Boolean,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
maps viewport frustum to -1 &lt;= x,y,z &lt;= 1 box
</summary>
            <param name="perspective">true for perspective, false for orthographic</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.CameraToWorld(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>standard viewing transformations</summary>
            <param name="cam_x">unit CameraX vector (right)</param>
            <param name="cam_y">unit CameraY vector (up)</param>
            <param name="cam_z">unit CameraZ vector (from screen to camera)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.WorldToCamera(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>standard viewing transformations</summary>
            <param name="cam_x">unit CameraX vector (right)</param>
            <param name="cam_y">unit CameraY vector (up)</param>
            <param name="cam_z">unit CameraZ vector (from screen to camera)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ChangeBasis(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Get a change of basis transformation.</summary>
            <param name="P0">initial center</param>
            <param name="X0">initial basis X (X0,Y0,Z0 can be any 3d basis)</param>
            <param name="Y0">initial basis Y</param>
            <param name="Z0">initial basis Z</param>
            <param name="P1">final center</param>
            <param name="X1">final basis X (X1,Y1,Z1 can be any 3d basis)</param>
            <param name="Y1">final basis Y</param>
            <param name="Z1">final basis Z</param>
            <remarks>
Change of basis transformations and rotation transformations
are often confused.  This is a change of basis transformation.
If Q = P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ChangeBasis(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Get a change of basis transformation.</summary>
            <param name="X0">initial basis X (X0,Y0,Z0 can be any 3d basis)</param>
            <param name="Y0">initial basis Y</param>
            <param name="Z0">initial basis Z</param>
            <param name="X1">final basis X (X1,Y1,Z1 can be any 3d basis)</param>
            <param name="Y1">final basis Y</param>
            <param name="Z1">final basis Z</param>
            <remarks>
Change of basis transformations and rotation transformations
are often confused.  This is a change of basis transformation.
If Q = a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1
then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ChangeBasis(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnPlane)">
            <summary>compute a change of basis transformation.</summary>
            <param name="plane0">inital plane</param>
            <param name="plane1">final plane</param>
            <returns>
 true    success
 false   vectors for initial frame are not a basis
</returns>
            <remarks>
If you have points defined with respect to planes, the
version of ChangeBasis() that takes two planes computes
the transformation to change coordinates from one plane to 
another.  The predefined world plane ON_world_plane can
be used as an argument.
If P = plane0.Evaluate( a0,b0,c0 ) and 
(a1,b1,c1) = ChangeBasis(plane0,plane1)*ON_3dPoint(a0,b0,c0),
then P = plane1.Evaluate( a1, b1, c1 )
        
The version of ChangeBasis() that takes six vectors
maps (a0,b0,c0) to (a1,b1,c1) where
a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1
The version of ChangeBasis() that takes six vectors
with center points
maps (a0,b0,c0) to (a1,b1,c1) where
P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
The change of basis transformation is not the same as
the rotation transformation that rotates one orthonormal
frame to another.  See ON_Xform::Rotation().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Mirror(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>Create mirror transformation matrix.</summary>
            <param name="point_on_mirror_plane">[in] point on mirror plane</param>
            <param name="normal_to_mirror_plane">[in] normal to mirror plane</param>
            <remarks>
The mirror transform maps a point Q to
Q - (2*(Q-P)oN)*N, where
P = point_on_mirror_plane and N = normal_to_mirror_plane.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOnPlane)">
            <summary>Create rotation transformation that maps plane0 to plane1.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <param name="P0">initial frame center</param>
            <param name="X0">initial frame X</param>
            <param name="Y0">initial frame Y</param>
            <param name="Z0">initial frame Z</param>
            <param name="P1">initial frame center</param>
            <param name="X1">final frame X</param>
            <param name="Y1">final frame Y</param>
            <param name="Z1">final frame Z</param>
            <remarks>
In the overloads that take frames, the frames should 
be right hand orthonormal frames 
(unit vectors with Z = X x Y).  
The resulting rotation fixes
the origin (0,0,0), maps initial X to 
final X, initial Y to final Y, and initial Z to final Z.

In the overload that takes frames with center points, 
if the initial and final center are equal, then that 
center point is the fixed point of the rotation.  If 
the initial and final point differ, then the resulting
transform is the composition of a rotation fixing P0
and translation from P0 to P1.  The resulting 
transformation maps P0 to P1, P0+X0 to P1+X1, ...
The rotation transformations that map frames to frames
are not the same as the change of basis transformations
for those frames.  See ON_Xform::ChangeBasis().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <param name="X0">initial frame X</param>
            <param name="Y0">initial frame Y</param>
            <param name="Z0">initial frame Z</param>
            <param name="X1">final frame X</param>
            <param name="Y1">final frame Y</param>
            <param name="Z1">final frame Z</param>
            <remarks>
In the overloads that take frames, the frames should 
be right hand orthonormal frames 
(unit vectors with Z = X x Y).  
The resulting rotation fixes
the origin (0,0,0), maps initial X to 
final X, initial Y to final Y, and initial Z to final Z.

In the overload that takes frames with center points, 
if the initial and final center are equal, then that 
center point is the fixed point of the rotation.  If 
the initial and final point differ, then the resulting
transform is the composition of a rotation fixing P0
and translation from P0 to P1.  The resulting 
transformation maps P0 to P1, P0+X0 to P1+X1, ...
The rotation transformations that map frames to frames
are not the same as the change of basis transformations
for those frames.  See ON_Xform::ChangeBasis().
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Calculate the minimal transformation that rotates start_dir to end_dir while fixing rotation_center.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The Rotation() function is overloaded and provides several
ways to compute a rotation transformation.  A positive
rotation angle indicates a counter-clockwise (right hand rule)
rotation about the axis of rotation.
</summary>
            <param name="angle_radians">rotation angle in radians</param>
            <param name="rotation_axis">3d unit axis of rotation</param>
            <param name="rotation_center">3d center of rotation</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rotation(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
The Rotation() function is overloaded and provides several
ways to compute a rotation transformation.  A positive
rotation angle indicates a counter-clockwise (right hand rule)
rotation about the axis of rotation.
</summary>
            <param name="sin_angle">sin(rotation angle)</param>
            <param name="cos_angle">cos(rotation angle)</param>
            <param name="rotation_axis">3d unit axis of rotation</param>
            <param name="rotation_center">3d center of rotation</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.PlanarProjection(RMA.OpenNURBS.IOnPlane)">
            <summary>Get transformation that projects to a plane</summary>
            <remarks>
This transformaton maps a 3d point P to the
point plane.ClosestPointTo(Q).
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Translation(System.Double,System.Double,System.Double)">
            <summary>
Right column is (dx, dy, dz, 1).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Translation(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Right column is (d.x, d.y,d.z, 1).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Shear(RMA.OpenNURBS.IOnPlane,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>Create shear transformation.</summary>
            <param name="plane">[in] plane.origin is the fixed point</param>
            <param name="x1">[in] plane.xaxis scale factor</param>
            <param name="y1">[in] plane.yaxis scale factor</param>
            <param name="z1">[in] plane.zaxis scale factor</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(RMA.OpenNURBS.IOnPlane,System.Double,System.Double,System.Double)">
            <summary>Create non-uniform scale transformation with a specified fixed point.</summary>
            <param name="plane">[in] plane.origin is the fixed point</param>
            <param name="x_scale_factor">[in] plane.xaxis scale factor</param>
            <param name="y_scale_factor">[in] plane.yaxis scale factor</param>
            <param name="z_scale_factor">[in] plane.zaxis scale factor</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(RMA.OpenNURBS.IOn3dPoint,System.Double)">
            <summary>Create uniform scale transformation with a specified fixed point.</summary>
            <param name="fixed_point">[in]</param>
            <param name="scale_factor">[in]</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(RMA.OpenNURBS.IOn3dVector)">
            <summary>Create non-uniform scale transformation with the origin as a fixed point.</summary>
            <param name="scale_vector">[in]</param>
            <remarks>The diagonal is (x_scale_factor, y_scale_factor, z_scale_factor, 1)</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Scale(System.Double,System.Double,System.Double)">
            <summary>Create non-uniform scale transformation with the origin as a fixed point.</summary>
            <param name="x_scale_factor">[in]</param>
            <param name="y_scale_factor">[in]</param>
            <param name="z_scale_factor">[in]</param>
            <remarks>The diagonal is (x_scale_factor, y_scale_factor, z_scale_factor, 1)</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Diagonal(System.Double)">
            <summary>
diagonal 3x3 with bottom row = 0,0,0,1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Identity">
            <summary>
diagonal is (1,1,1,1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Zero">
            <summary>All zeros including the bottom row.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ActOnRight(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes [x,y,z,w] * matrix.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.ActOnLeft(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes matrix * transpose([x,y,z,w]).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.GetMappingXforms(RMA.OpenNURBS.OnXform@,RMA.OpenNURBS.OnXform@)">
            <summary>
If a texture mapping is applied to an object, the object is subsequently transformed by T,
and the texture mapping needs to be recalculated, then two transforms are required to
recalcalculate the texture mapping.
</summary>
            <param name="P_xform">[out] Transform to apply to points before applying the texture mapping transformation.</param>
            <param name="N_xform">[out] Transform to apply to surface normals before applying the texture mapping transformation.</param>
            <returns>
The determinant of the "this" transformation. If non-zero, "this" is
invertable and P_xform and N_xform were calculated. False if "this" is not invertable,
in which case the returned P_xform and N_xform are the identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.GetSurfaceNormalXform(RMA.OpenNURBS.OnXform@)">
            <summary>
When transforming 3d point and surface or mesh normals two different transforms must be used.
If P_xform transforms the point, then the inverse transpose of P_xform must be used to tranform
normal vectors.
</summary>
            <param name="N_xform">[out]</param>
            <returns>
The determinant of the transformation. If non-zero, "this" is invertable
and N_xform can be calculated. False if "this" is not invertable,
in which case the returned N_xform = this with the right hand column and bottom row zeroed out.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Inverse">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Inverse(System.Double@)">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Invert">
            <summary>
If matrix is non-singular, returns true, otherwise returns false
and sets matrix to pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Invert(System.Double@)">
            <summary>
If matrix is non-singular, returns true, otherwise returns false
and sets matrix to pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Determinant">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Determinant(System.Double@)">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rank">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Rank(System.Double@)">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.Transpose">
            <summary>
transposes 4x4 matrix
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsSimilarity">
            <summary>
A similarity transformation can be broken into a sequence of dialations,
translations, rotations, and reflections.
</summary>
            <returns>
+1: This transformation is an orientation preserving similarity.
-1: This transformation is an orientation preserving similarity.
0: This transformation is not a similarity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsTranslation(System.Double)">
            <returns>
true if matrix is the zero transformation
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 *
</returns>
            <summary>
true if matrix is a pure translation
 1 0 0 dx
 0 1 0 dy
 0 0 1 dz
 0 0 0 1
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsIdentity">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsIdentity(System.Double)">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.IsValid">
            <summary>Test the entries of the transformation matrix to see if they are valid number.</summary>
            <returns>True if ON_IsValid() is true for every number in the transformation matrix.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.op_Multiply(RMA.OpenNURBS.OnXform,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
All non-commutative operations have "this" as left hand side and
argument as right hand side.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.op_Implicit(RMA.OpenNURBS.IOnMatrix)~RMA.OpenNURBS.OnXform">
            <summary>
from upper left 4x4 of an
arbitrary matrix.  Any missing
rows/columns are set to identity.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
as a frame.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(RMA.OpenNURBS.IOnMatrix)">
            <summary>
from standard double m[4][4]
</summary>
            <summary>
from standard float m[4][4]
</summary>
            <summary>
from upper left 4x4 of an arbitrary matrix.  Any missing rows/columns are set to identity. 
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Single[])">
            <summary>
from standard float m[4][4]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Double[])">
            <summary>
from standard double m[4][4]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Double)">
            <summary>
diagonal matrix (d,d,d,1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor(System.Int32)">
            <summary>
diagonal matrix (d,d,d,1)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnXform.#ctor">
            <summary>
zero matrix
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnXform.m_xform(System.Int32,System.Int32)">
            <summary>
[i][j] = row i, column j.  I.e.,
        [0][0] [0][1] [0][2] [0][3]
        [1][0] [1][1] [1][2] [1][3]
        [2][0] [2][1] [2][2] [2][3]
        [3][0] [3][1] [3][2] [3][3]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.ActOnRight(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes [x,y,z,w] * matrix.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.ActOnLeft(System.Double,System.Double,System.Double,System.Double,RMA.OpenNURBS.On4dPoint@)">
            <summary>
Computes matrix * transpose([x,y,z,w]).
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.GetMappingXforms(RMA.OpenNURBS.OnXform@,RMA.OpenNURBS.OnXform@)">
            <summary>
If a texture mapping is applied to an object, the object is subsequently transformed by T,
and the texture mapping needs to be recalculated, then two transforms are required to
recalcalculate the texture mapping.
</summary>
            <param name="P_xform">[out] Transform to apply to points before applying the texture mapping transformation.</param>
            <param name="N_xform">[out] Transform to apply to surface normals before applying the texture mapping transformation.</param>
            <returns>
The determinant of the "this" transformation. If non-zero, "this" is
invertable and P_xform and N_xform were calculated. False if "this" is not invertable,
in which case the returned P_xform and N_xform are the identity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.GetSurfaceNormalXform(RMA.OpenNURBS.OnXform@)">
            <summary>
When transforming 3d point and surface or mesh normals two different transforms must be used.
If P_xform transforms the point, then the inverse transpose of P_xform must be used to tranform
normal vectors.
</summary>
            <param name="N_xform">[out]</param>
            <returns>
The determinant of the transformation. If non-zero, "this" is invertable
and N_xform can be calculated. False if "this" is not invertable,
in which case the returned N_xform = this with the right hand column and bottom row zeroed out.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Inverse">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Inverse(System.Double@)">
            <summary>
If matrix is non-singular, returns inverse, otherwise returns pseudo inverse.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Determinant">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Determinant(System.Double@)">
            <returns>returns determinant of 4x4 matrix</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Rank">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.Rank(System.Double@)">
            <returns>0 to 4</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsSimilarity">
            <summary>
A similarity transformation can be broken into a sequence of dialations,
translations, rotations, and reflections.
</summary>
            <returns>
+1: This transformation is an orientation preserving similarity.
-1: This transformation is an orientation preserving similarity.
0: This transformation is not a similarity.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsZero">
            <returns>
true if matrix is the zero transformation
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 *
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsTranslation(System.Double)">
            <summary>
true if matrix is a pure translation
 1 0 0 dx
 0 1 0 dy
 0 0 1 dz
 0 0 0 1
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsIdentity">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsIdentity(System.Double)">
            <returns>
true if matrix is the identity transformation
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
</returns>
            <remarks>
The test for zero is fabs(x) &lt;= zero_tolerance.
The test for one is fabs(x-1) &lt;= zero_tolerance.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnXform.IsValid">
            <summary>Test the entries of the transformation matrix to see if they are valid number.</summary>
            <returns>True if ON_IsValid() is true for every number in the transformation matrix.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnXform.m_xform(System.Int32,System.Int32)">
            <summary>
[i][j] = row i, column j.  I.e.,
        [0][0] [0][1] [0][2] [0][3]
        [1][0] [1][1] [1][2] [1][3]
        [2][0] [2][1] [2][2] [2][3]
        [3][0] [3][1] [3][2] [3][3]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.BackSolve(System.Double,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of points
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="pt_dim">[in] dimension of points</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) number of points in B[]. The points correspoinding to indices
m_row_count, ..., (Bsize-1) are tested to make sure they are "zero".
</param>
            <param name="Bpt_stride">[in] stride between B points (&gt;=pt_dim)</param>
            <param name="Bpt">
[in/out] array of m_row_count*Bpt_stride values.
The i-th B point is (Bpt[i*Bpt_stride],...,Bpt[i*Bpt_stride+pt_dim-1]).
</param>
            <param name="Xpt_stride">[in] stride between X points (&gt;=pt_dim)</param>
            <param name="Xpt">
[out] array of m_col_count*Xpt_stride values.
The i-th X point is (Xpt[i*Xpt_stride],...,Xpt[i*Xpt_stride+pt_dim-1]).
</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.BackSolve(System.Double,System.Int32,RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of 3d points.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.BackSolve(System.Double,System.Int32,System.Double[],System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of values.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,System.Int32,System.Int32,System.Double[]@,System.Double@)">
            <summary>
Row reduce a matrix as the first step in solving M*X=B where B is a column arbitrary dimension points.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If a the absolute value of a pivot is &lt;= zero_tolerance, then the pivoit is assumed to be zero.
</param>
            <param name="pt_dim">[in] dimension of points</param>
            <param name="pt_stride">[in] stride between points (&gt;=pt_dim)</param>
            <param name="pt">
[in/out] array of m_row_count*pt_stride values.
The i-th point is (pt[i*pt_stride],...,pt[i*pt_stride+pt_dim-1]).
This array of points is row reduced along with the matrix.
</param>
            <param name="pivot">[out] the value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,RMA.OpenNURBS.ArrayOn3dPoint@,System.Double@)">
            <summary>
Row reduce a matrix as the first step in solving M*X=B where B is a column of 3d points
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If a the absolute value of a pivot is &lt;= zero_tolerance, then the pivot is assumed to be zero.
</param>
            <param name="B">[in/out] an array of m_row_count 3d points that is row reduced with the matrix.</param>
            <param name="pivot">[out] the value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,System.Double[]@,System.Double@)">
            <summary>
Row reduce a matrix as the first step in solving M*X=B where B is a column of values.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If a the absolute value of a pivot is &lt;= zero_tolerance, then the pivoit is assumed to be zero.
</param>
            <param name="B">[in/out] an array of m_row_count values that is row reduced with the matrix.</param>
            <param name="pivot">[out] The value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.RowReduce(System.Double,System.Double@,System.Double@)">
            <summary>Row reduce a matrix to calculate rank and determinant.</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) zero tolerance for pivot test
If the absolute value of a pivot is &lt;= zero_tolerance,
then the pivot is assumed to be zero.
</param>
            <param name="determinant">[out] value of determinant is returned here.</param>
            <param name="pivot">[out] value of the smallest pivot is returned here</param>
            <returns>Rank of the matrix.</returns>
            <remarks>
The matrix itself is row reduced so that the result is
an upper triangular matrix with 1's on the diagonal.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Scale(System.Double)">
            <summary>safe arithmetic</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Add(RMA.OpenNURBS.IOnMatrix,RMA.OpenNURBS.IOnMatrix)">
            <summary>safe arithmetic</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Multiply(RMA.OpenNURBS.IOnMatrix,RMA.OpenNURBS.IOnMatrix)">
            <summary>safe arithmetic</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SwapCols(System.Int32,System.Int32)">
            <summary>
ints are col indices to swap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SwapRows(System.Int32,System.Int32)">
            <summary>
ints are row indices to swap
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(RMA.OpenNURBS.IArraydouble)">
            <summary>
sets size to length X lengthdiagonal values and zeros off diagonal values
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(System.Int32,System.Double[])">
            <summary>sets size to count x count and diagonal values and zeros off diagonal values</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(System.Double[])">
            <summary>sets diagonal value and zeros off diagonal values</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.SetDiagonal(System.Double)">
            <summary>sets diagonal value and zeros off diagonal values</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Create(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
E.g., Create(1,5,1,7) creates a 5x7 sized matrix that with
"top" row = m[1][1],...,m[1][7] and "bottom" row
</summary>
            <param name="row_index0">first valid row index</param>
            <param name="row_index1">last valid row index</param>
            <param name="col_index0">first valid column index</param>
            <param name="col_index1">last valid column index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.Create(System.Int32,System.Int32)">
            <param name="rows">number of rows</param>
            <param name="columns">number of columns</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.MaxCount">
            <summary>
largest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.MinCount">
            <summary>
smallest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.IsSquare">
            <summary>
returns 0 for no and m_row_count (= m_col_count) for yes
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.EmergencyDestroy">
            <summary>
call if memory pool used matrix by becomes invalid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>see ON_Matrix::Create(int,int,int,int) for details</summary>
            <param name="row_index0">first valid row index</param>
            <param name="row_index1">last valid row index</param>
            <param name="col_index0">first valid column index</param>
            <param name="col_index1">last valid column index</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnMatrix.#ctor(System.Int32,System.Int32)">
            <param name="rows">number of rows</param>
            <param name="columns">number of columns</param>
        </member>
        <member name="P:RMA.OpenNURBS.OnMatrix.m(System.Int32,System.Int32)">
            <summary>
OnMatrix[i][j] = value at row i and column j
  0 &lt;= i &lt; RowCount()
  0 &lt;= j &lt; ColCount()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.BackSolve(System.Double,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of points
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="pt_dim">[in] dimension of points</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) number of points in B[]. The points correspoinding to indices
m_row_count, ..., (Bsize-1) are tested to make sure they are "zero".
</param>
            <param name="Bpt_stride">[in] stride between B points (&gt;=pt_dim)</param>
            <param name="Bpt">
[in/out] array of m_row_count*Bpt_stride values.
The i-th B point is (Bpt[i*Bpt_stride],...,Bpt[i*Bpt_stride+pt_dim-1]).
</param>
            <param name="Xpt_stride">[in] stride between X points (&gt;=pt_dim)</param>
            <param name="Xpt">
[out] array of m_col_count*Xpt_stride values.
The i-th X point is (Xpt[i*Xpt_stride],...,Xpt[i*Xpt_stride+pt_dim-1]).
</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.BackSolve(System.Double,System.Int32,RMA.OpenNURBS.ArrayOn3dPoint,RMA.OpenNURBS.ArrayOn3dPoint@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of 3d points.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.BackSolve(System.Double,System.Int32,System.Double[],System.Double[]@)">
            <summary>
Solve M*X=B where M is upper triangular with a unit diagonal and B is a column of values.
</summary>
            <param name="zero_tolerance">
[in] (&gt;=0.0) used to test for "zero" values in B in under determined systems of equations.
</param>
            <param name="Bsize">
[in] (&gt;=m_row_count) length of B.  The values in B[m_row_count],...,B[Bsize-1] are
tested to make sure they are "zero".
</param>
            <param name="B">[in] array of length Bsize.</param>
            <param name="X">[out] array of length m_col_count.  Solutions returned here.</param>
            <remarks>
Actual values M[i][j] with i &lt;= j are ignored. 
M[i][i] is assumed to be one and M[i][j] i&lt;j is assumed to be zero.
For square M, B and X can point to the same memory.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.MaxCount">
            <summary>
largest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.MinCount">
            <summary>
smallest of row and column count
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnMatrix.IsSquare">
            <summary>
returns 0 for no and m_row_count (= m_col_count) for yes
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnMatrix.m(System.Int32,System.Int32)">
            <summary>
OnMatrix[i][j] = value at row i and column j
  0 &lt;= i &lt; RowCount()
  0 &lt;= j &lt; ColCount()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsDisjoint(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test to see if "this" and other_bbox are disjoint (do not intersect).
</summary>
            <param name="other_bbox">[in]</param>
            <returns>True if "this" and other_bbox are disjoint.</returns>
            <remarks>If "this" or other_bbox is invalid, then true is returned.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Union(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Union() returns TRUE if union is not empty.
Invalid boxes are treated as the empty set.
this = union of two args
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Union(RMA.OpenNURBS.ValueTypes.BoundingBox)">
            <summary>
Union() returns TRUE if union is not empty.
Invalid boxes are treated as the empty set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Union(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Union() returns TRUE if union is not empty.
Invalid boxes are treated as the empty set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox,System.Boolean)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <param name="bProperSubSet">
[in] if true, then the test is for a proper inclusion.
</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
            <param name="t1">parameter of last intersection point (t0&lt;=t1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Set "this" to the intersection of bbox_A and bbox_B.
</summary>
            <param name="bbox_A">[in]</param>
            <param name="bbox_B">[in]</param>
            <returns>
True if the "this" is a non-empty valid bounding box.
False if the intersection is empty, in which case "this"
is set to an invalid bounding box.
</returns>
            <remarks>If bbox_A or bbox_B is invalid, they are treated as the empty set, and false is returned.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Intersection(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Intersect this with other_bbox and save intersection in this.
</summary>
            <param name="other_bbox">[in]</param>
            <returns>
True if this-intesect-other_bbox is a non-empty valid bounding box and this is set.
False if the intersection is empty, in which case "this" is set to an invalid bounding box.
</returns>
            <remarks>
If "this" or other_bbox is invalid, they are treated as the empty set, and false is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetFarPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are farthest from each other.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is farthest from other box</param>
            <param name="arg3">point on other box that is farthest from this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.FarPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Point on the box that is farthest from the test_point.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are closest to each other.
If the boxes intersect, then the point at the centroid of the
intersection is returned for both points.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is closest to other box</param>
            <param name="arg3">point on other box that is closest to this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.On3dPoint@,System.Double@,System.Double@)">
            <summary>
Get point in a bounding box that is closest to a line segment.
</summary>
            <param name="line">[in] line segment</param>
            <param name="box_point">[out] point in box that is closest to line segment point at t0.</param>
            <param name="t0">[out] parameter of point on line that is closest to the box.</param>
            <param name="t1">[out] parameter of point on line that is closest to the box.</param>
            <returns>
3 success - line segments intersects box in a segment
           from line(t0) to line(t1) (t0 &lt; t1)
2 success - line segments intersects box in a single point
           at line(t0) (t0==t1)
1 success - line segment does not intersect box.  Closest
           point on the line is at line(t0) (t0==t1)
0 failure - box is invalid.
</returns>
            <remarks>
The box is treated as a solid box.  If the intersection
of the line segment, then 3 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly determine if the shortest distance this bounding box to another bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="other">[in] other bounding box</param>
            <returns>
True if if the shortest distance from this bounding box to the other bounding box is greater than d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlaneEquation)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane_equation">
[in] (the first three coefficients are assumed to be a unit vector. If not, adjust your d accordingly.)
</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane">[in]</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from the line to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="line">[in]</param>
            <returns>
True if the shortest distance from the line to the bounding box is greater than d.
It is not the case that false means that the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from the point P to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="P">[in]</param>
            <returns>True if if the shortest distance from the point P to the bounding box is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight upper bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
A distance that is equal to the longest distance from the plane to this bounding box.
Put another way, if Q is any point on the plane and P is any point in this
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox) and there is
at least one point on the bounding box where the distance is equal to the returned value.
See Also: ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find an upper bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the line to this bounding box.
Put another way, if Q is any point on the line and P is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight lower bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
The minimum distance between a point on the plane and a point on the bounding box.
See Also: ON_PlaneEquation::MimimumValueAt ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find a lower bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to this bounding box.
Put another way, if Q is any point on line and P is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find an upper bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find a lower bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find an upper bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the point P
to this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find a lower bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to
this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.ClosestPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Point on or in the box that is closest to test_point.
If test_point is in or on the box, the test_point is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <param name="bStrictlyIn">
TRUE to test for strict ( min &lt; point &lt; max )
FALSE to test for (min &lt;= point &lt;= max)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IArrayOn2dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IArrayOn3dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IArrayOn4dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Set(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <param name="bGrowBox">
If bGrowBox is TRUE, the existing box is expanded, otherwise it is only set to the current point list
</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Tolerance">
            <summary>
rough guess at a tolerance to use for comparing objects in this bounding box
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
ON_BoundingBox::Transform() updates the bounding box
to be the smallest axis aligned bounding box that contains
the transform of the eight corner points of the input
bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsDegenerate">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsDegenerate(System.Double)">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <param name="tolerance">
[in] Distances &lt;= tolerance will be considered to be zero.
If tolerance is negative (default), then a scale invarient tolerance is used.
</param>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsValid">
            <summary>
empty boxes are not valid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.GetCorners(RMA.OpenNURBS.On3dPointArray@)">
            <summary>returns list of 8 corner points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Corner(System.Int32,System.Int32,System.Int32)">
            <summary>8 corners of box</summary>
            <param name="x_index">0 = Min().x, 1 = Max().x</param>
            <param name="y_index">0 = Min().y, 1 = Max().y</param>
            <param name="z_index">0 = Min().z, 1 = Max().z</param>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Diagonal">
            <summary>
max corner - min corner
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.Destroy">
            <summary>
invalidates bounding box
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.IsVisible(RMA.OpenNURBS.IOnXform)">
            <summary>
temporary - use ON_ClippingRegion - this function will be removed soon.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnBoundingBox.#ctor(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <param name="min">min corner of axis aligned bounding box</param>
            <param name="max">max corner of axis aligned bounding box</param>
        </member>
        <member name="T:RMA.OpenNURBS.OnBoundingBox">
            <summary>axis aligned bounding box</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsDisjoint(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Test to see if "this" and other_bbox are disjoint (do not intersect).
</summary>
            <param name="other_bbox">[in]</param>
            <returns>True if "this" and other_bbox are disjoint.</returns>
            <remarks>If "this" or other_bbox is invalid, then true is returned.</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Includes(RMA.OpenNURBS.IOnBoundingBox,System.Boolean)">
            <summary>Test a box to see if it is contained in this box</summary>
            <param name="other">[in] box to test</param>
            <param name="bProperSubSet">
[in] if true, then the test is for a proper inclusion.
</param>
            <returns>
If bProperSubSet is false, then the result is true when
this-&gt;m_min[i] &lt;= other.m_min[i] and other.m_max[i] &lt;= this-&gt;m_max[i]. for i=0,1 and 2.
If bProperSubSet is true, then the result is true when
the above condition is true and at least one of the inequalities is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Intersection(RMA.OpenNURBS.IOnLine,System.Double@,System.Double@)">
            <summary>Returns TRUE when intersect is non-empty.</summary>
            <param name="line">Infinite Line segment to intersect with </param>
            <param name="t0">parameter of first intersection point</param>
            <param name="t1">parameter of last intersection point (t0&lt;=t1)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetFarPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are farthest from each other.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is farthest from other box</param>
            <param name="arg3">point on other box that is farthest from this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.FarPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Point on the box that is farthest from the test_point.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnBoundingBox,RMA.OpenNURBS.On3dPoint@,RMA.OpenNURBS.On3dPoint@)">
            <summary>
Get points on bounding boxes that are closest to each other.
If the boxes intersect, then the point at the centroid of the
intersection is returned for both points.
</summary>
            <param name="arg1">other bounding box</param>
            <param name="arg2">point on this box that is closest to other box</param>
            <param name="arg3">point on other box that is closest to this box</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetClosestPoint(RMA.OpenNURBS.IOnLine,RMA.OpenNURBS.On3dPoint@,System.Double@,System.Double@)">
            <summary>
Get point in a bounding box that is closest to a line segment.
</summary>
            <param name="line">[in] line segment</param>
            <param name="box_point">[out] point in box that is closest to line segment point at t0.</param>
            <param name="t0">[out] parameter of point on line that is closest to the box.</param>
            <param name="t1">[out] parameter of point on line that is closest to the box.</param>
            <returns>
3 success - line segments intersects box in a segment
           from line(t0) to line(t1) (t0 &lt; t1)
2 success - line segments intersects box in a single point
           at line(t0) (t0==t1)
1 success - line segment does not intersect box.  Closest
           point on the line is at line(t0) (t0==t1)
0 failure - box is invalid.
</returns>
            <remarks>
The box is treated as a solid box.  If the intersection
of the line segment, then 3 is returned.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly determine if the shortest distance this bounding box to another bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="other">[in] other bounding box</param>
            <returns>
True if if the shortest distance from this bounding box to the other bounding box is greater than d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlaneEquation)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane_equation">
[in] (the first three coefficients are assumed to be a unit vector. If not, adjust your d accordingly.)
</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly determine if the shortest distance from the plane to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="plane">[in]</param>
            <returns>
True if the shortest distance from the plane to the bounding box is greater than d,
and false if the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly determine if the shortest distance from the line to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="line">[in]</param>
            <returns>
True if the shortest distance from the line to the bounding box is greater than d.
It is not the case that false means that the shortest distance is less than or equal to d.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsFartherThan(System.Double,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly determine if the shortest distance from the point P to the bounding box is greater than d.
</summary>
            <param name="d">[in] distance (&gt; 0.0)</param>
            <param name="P">[in]</param>
            <returns>True if if the shortest distance from the point P to the bounding box is greater than d.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight upper bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
A distance that is equal to the longest distance from the plane to this bounding box.
Put another way, if Q is any point on the plane and P is any point in this
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox) and there is
at least one point on the bounding box where the distance is equal to the returned value.
See Also: ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find an upper bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the line to this bounding box.
Put another way, if Q is any point on the line and P is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnPlane)">
            <summary>
Quickly find a tight lower bound on the distance between the plane and this bounding box.
</summary>
            <param name="plane">[in]</param>
            <returns>
The minimum distance between a point on the plane and a point on the bounding box.
See Also: ON_PlaneEquation::MimimumValueAt ON_PlaneEquation::MaximumValueAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnLine)">
            <summary>
Quickly find a lower bound on the distance between the line segment and this bounding box.
</summary>
            <param name="line">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to this bounding box.
Put another way, if Q is any point on line and P is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find an upper bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Quickly find a lower bound on the distance between this and the other bounding box.
</summary>
            <param name="other">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance between the bounding boxes.
Put another way, if Q is any point in this bounding box and P is any point in the other
bounding box, then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MaximumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find an upper bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is greater than or equal to the longest distance from the point P
to this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &lt;= MaximumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.MinimumDistanceTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Quickly find a lower bound on the distance between the point and this bounding box.
</summary>
            <param name="P">[in]</param>
            <returns>
A distance that is less than or equal to the shortest distance from the line to
this bounding box. Put another way, if Q is any point in this bounding box,
then P.DistanceTo(Q) &gt;= MinimumDistanceTo(bbox).
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.ClosestPoint(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Point on or in the box that is closest to test_point.
If test_point is in or on the box, the test_point is returned.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsPointIn(RMA.OpenNURBS.IOn3dPoint,System.Boolean)">
            <param name="bStrictlyIn">
TRUE to test for strict ( min &lt; point &lt; max )
FALSE to test for (min &lt;= point &lt;= max)
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Tolerance">
            <summary>
rough guess at a tolerance to use for comparing objects in this bounding box
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsDegenerate">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsDegenerate(System.Double)">
            <summary>
Test a bounding box to see if it is degenerate (flat) in one or more directions.
</summary>
            <param name="tolerance">
[in] Distances &lt;= tolerance will be considered to be zero.
If tolerance is negative (default), then a scale invarient tolerance is used.
</param>
            <returns>
0 box is not degenerate
1 box is a rectangle (degenerate in one direction)
2 box is a line (degenerate in two directions)
3 box is a point (degenerate in three directions)
4 box is not valid
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsValid">
            <summary>
empty boxes are not valid
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.GetCorners(RMA.OpenNURBS.On3dPointArray@)">
            <summary>returns list of 8 corner points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Corner(System.Int32,System.Int32,System.Int32)">
            <summary>8 corners of box</summary>
            <param name="x_index">0 = Min().x, 1 = Max().x</param>
            <param name="y_index">0 = Min().y, 1 = Max().y</param>
            <param name="z_index">0 = Min().z, 1 = Max().z</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.Diagonal">
            <summary>
max corner - min corner
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnBoundingBox.IsVisible(RMA.OpenNURBS.IOnXform)">
            <summary>
temporary - use ON_ClippingRegion - this function will be removed soon.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnBoundingBox">
            <summary>axis aligned bounding box</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_developer_organization">
            <summary>
developer contact information
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_filename">
            <summary>
name of executable file
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_platform">
            <summary>0 = unknown, 1 = C++, 2 = .NET</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_type">
            <summary>CRhinoPlugIn::plugin_type enum value</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlugInRef.m_plugin_id">
            <summary>
executable informtion
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnPlugInRef">
            <summary>
The ON_PluginRef class is used to store a list of
application plug-ins that may have saved user data
in a 3dm file so they can be loaded as needed for
reading their user data.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_developer_organization">
            <summary>
developer contact information
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_filename">
            <summary>
name of executable file
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_platform">
            <summary>0 = unknown, 1 = C++, 2 = .NET</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_type">
            <summary>CRhinoPlugIn::plugin_type enum value</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlugInRef.m_plugin_id">
            <summary>
executable informtion
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnPlugInRef">
            <summary>
The ON_PluginRef class is used to store a list of
application plug-ins that may have saved user data
in a 3dm file so they can be loaded as needed for
reading their user data.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.FindUuidIndex(System.Guid,System.Int32)">
            <summary>Determine if a uuid-index pair is in the list.</summary>
            <returns>True if the uuid-index pair is in the list. False if the uuid-index pair is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.FindUuid(System.Guid,System.Int32@)">
            <summary>Determine if an element with a uuid is in the list.</summary>
            <param name="index">[out] if a matching uuid is found, then index is set to the value of the index.</param>
            <returns>True if an element was found. Returns false if the uuid is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.RemoveUuid(System.Guid)">
            <summary>Removes an element with a matching uuid from the list.</summary>
            <param name="uuid">[in] id to remove</param>
            <returns>True if an element was removed. False if the uuid was not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.AddUuidIndex(System.Guid,System.Int32,System.Boolean)">
            <summary>Adds a uuid-index pair to the list.</summary>
            <param name="uuid">[in] id to add.</param>
            <param name="bCheckForDuplicates">
[in] if true, then the uuid is not added if it is already in the list.
If you are certain that the uuid is not in the list and you have a have
a large collection of uuids, then setting bCheckForDuplicates=false will
speed up the addition of uuids.
</param>
            <returns>True if uuid was added. False if uuid was not added because it is already in the collection.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.Empty">
            <summary>Provides an efficient way to empty a list so that it can be used again.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndexList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidIndexList.FindUuidIndex(System.Guid,System.Int32)">
            <summary>Determine if a uuid-index pair is in the list.</summary>
            <returns>True if the uuid-index pair is in the list. False if the uuid-index pair is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidIndexList.FindUuid(System.Guid,System.Int32@)">
            <summary>Determine if an element with a uuid is in the list.</summary>
            <param name="index">[out] if a matching uuid is found, then index is set to the value of the index.</param>
            <returns>True if an element was found. Returns false if the uuid is not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidIndexList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnUuidIndexList">
            <summary>
The ON_UuidIndexList class provides a tool to efficiently maintain a list of uuid-index
pairs and determine if a uuid is in the list. This class is based on the premise
that there are no duplicate uuids in the list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Read(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Read the uuid list from an archive.</summary>
            <param name="archive">[in] archive to read from.</param>
            <returns>true if the read was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Saves the uuid list in an archive.</summary>
            <param name="archive">[in] archive to write to.</param>
            <returns>true if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.FindUuid(System.Guid)">
            <summary>Determine if a uuid is in the list.</summary>
            <returns>True if uuid is in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.RemoveUuid(System.Guid)">
            <summary>Removes a uuid from the list.</summary>
            <param name="uuid">[in] id to remove</param>
            <returns>True if uuid was in the list and was removed. False if uuid was not in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.AddUuid(System.Guid,System.Boolean)">
            <summary>Adds a uuid to the list.</summary>
            <param name="uuid">[in] id to add.</param>
            <param name="bCheckForDuplicates">
[in] if true, then the uuid is not added if it is already in the list.
have a large list of uuids, then setting bCheckForDupicates=false will
speed up the addition of uuids.
</param>
            <returns>True if uuid was added. False if uuid was not added because it is already in the collection.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Compact">
            <summary>
Makes the uuid list as efficent as possible in both search speed and memory usage.
Use Compact() when a uuid list will be in use but is not likely to be modifed.
A list that has been compacted can still be modified.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Destroy">
            <summary>Destroy list. If list will be reused, Empty() is more efficient.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Empty">
            <summary>Provides an efficient way to empty a list so that it can be used again.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Array">
            <returns>Array of uuids in the list. Sorted with respect to ON_UuidList::CompareUuid().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.OnUuidList">
            <summary>
The ON_UuidList class provides a tool to efficiently maintain a list of
uuids and determine if a uuid is in the list. This class is based on the
premise that there are no duplicate uuids in the list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.Write(RMA.OpenNURBS.OnBinaryArchive@)">
            <summary>Saves the uuid list in an archive.</summary>
            <param name="archive">[in] archive to write to.</param>
            <returns>true if write was successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.FindUuid(System.Guid)">
            <summary>Determine if a uuid is in the list.</summary>
            <returns>True if uuid is in the list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.Array">
            <returns>Array of uuids in the list. Sorted with respect to ON_UuidList::CompareUuid().</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnUuidList.Count">
            <returns>Number of active uuids in the list.</returns>
        </member>
        <member name="T:RMA.OpenNURBS.IOnUuidList">
            <summary>
The ON_UuidList class provides a tool to efficiently maintain a list of
uuids and determine if a uuid is in the list. This class is based on the
premise that there are no duplicate uuids in the list.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidPair.Compare(RMA.OpenNURBS.IOnUuidPair,RMA.OpenNURBS.IOnUuidPair)">
            <summary>Compares m_uuid[0] first and then m_uuid[1].</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidPair.CompareSecondUuid(RMA.OpenNURBS.IOnUuidPair,RMA.OpenNURBS.IOnUuidPair)">
            <summary>Compares m_uuid[1] and ignores m_uuid[0]</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidPair.CompareFirstUuid(RMA.OpenNURBS.IOnUuidPair,RMA.OpenNURBS.IOnUuidPair)">
            <summary>Compares m_uuid[0] and ignores m_uuid[1]</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVectorArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVectorArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVectorArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVectorArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVectorArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVectorArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVectorArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVectorArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVectorArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVectorArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only points Q with
|P-Q| &lt;= maximum_distance are returned.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Translate(RMA.OpenNURBS.IOn3dVector)">
            <summary>Translate a polyline</summary>
            <param name="delta">[in] translation vectorsine of rotation angle</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Rotate(System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotate points about a center and axis.  A positive angle results in a counter-clockwise rotation about the axis of rotation.
</summary>
            <param name="angle_in_radians">[in] angle in radians.  Polsine of rotation angle</param>
            <param name="axis_of_rotation">[in] axis of rotation</param>
            <param name="center_of_rotation">[in] center (fixed point) of rotation</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Rotate points about a center and axis.  A positive angle results in a counter-clockwise rotation about the axis of rotation.
</summary>
            <param name="sin_angle">[in] sine of rotation angle</param>
            <param name="cos_angle">[in] cosine of rotation angle</param>
            <param name="axis_of_rotation">[in] axis of rotation</param>
            <param name="center_of_rotation">[in] center (fixed point) of rotation</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.SwapCoordinates(System.Int32,System.Int32)">
            <summary>Swaps point coordinate values with indices i and j.</summary>
            <param name="i">[in] coordinate index</param>
            <param name="j">[in] coordinate index</param>
            <returns>true if successful.</returns>
            <remarks>
The call SwapCoordinates(0,2) would swap the x and z coordinates of each point in the array.
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>Transform points by applying xform to each point.</summary>
            <param name="xform">[in] transformation matrix</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed point list is calculated.
The point list is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <returns>
the object's bounding box is returned in boxmin,boxmax
true if object has bounding box and calculation was successful
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bounding box and the object's bounding box is returned.
If 0 (false), the object's bounding box is returned.
</param>
            <returns>true if object has bounding box and calculation was successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">
[in/out] 3d axis aligned bounding box
the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bbox and the point list's bounding box is returned in bbox.  
If 0 (false), the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.BoundingBox">
            <summary>Get 3d axis aligned bounding box.</summary>
            <returns>3d bounding box of point list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Create(System.Int32,System.Boolean,System.Int32,System.Single[])">
            <summary>Create 3d point list by copying an array of floats</summary>
            <param name="point_dimension">
[in] dimension of input points
must be 2 or 3
</param>
            <param name="bRational">[in] true if points are in homogenous rational form</param>
            <param name="point_stride">[in] number of doubles to skip between points</param>
            <param name="points">[in] array of point coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPointArray.Create(System.Int32,System.Boolean,System.Int32,System.Double[])">
            <summary>Create 3d point list by copying an array of doubles</summary>
            <param name="point_dimension">
[in] dimension of input points
must be 2 or 3
</param>
            <param name="bRational">[in] true if points are in homogenous rational form</param>
            <param name="point_stride">[in] number of doubles to skip between points</param>
            <param name="points">[in] array of point coordinates</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetClosestPoint(RMA.OpenNURBS.IOn3dPoint,System.Int32@,System.Double)">
            <summary>Get the index of the point in the array that is closest to P.</summary>
            <param name="P">[in]</param>
            <param name="closest_point_index">[out]</param>
            <param name="maximum_distance">
[in] optional distance constraint. If maximum_distance &gt; 0, then only points Q with
|P-Q| &lt;= maximum_distance are returned.
</param>
            <returns>
True if a point is found; in which case *closest_point_index is the index of the point.
False if no point is found or the input is not valid.
See Also: ON_GetClosestPointInPointList ON_PointCloud::GetClosestPoint
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetTightBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32,RMA.OpenNURBS.IOnXform)">
            <summary>Get tight bounding box of the point list.</summary>
            <param name="tight_bbox">[in/out] tight bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false)
If 1 (true) and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the point list.
</param>
            <param name="xform">
[in] (default=NULL) If not NULL, the tight bounding box of the transformed point list is calculated.
The point list is not modified.
</param>
            <returns>True if the returned tight_bbox is set to a valid bounding box.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <returns>
the object's bounding box is returned in boxmin,boxmax
true if object has bounding box and calculation was successful
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>Get axis aligned bounding box.</summary>
            <param name="boxmin">[in/out] array of 3 doubles</param>
            <param name="boxmax">[in/out] array of 3 doubles</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bounding box and the object's bounding box is returned.
If 0 (false), the object's bounding box is returned.
</param>
            <returns>true if object has bounding box and calculation was successful</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">
[in/out] 3d axis aligned bounding box
the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.GetBoundingBox(RMA.OpenNURBS.OnBoundingBox@,System.Int32)">
            <summary>
Get 3d axis aligned bounding box or the union of the input box with the point list's bounding box.
</summary>
            <param name="bbox">[in/out] 3d axis aligned bounding box</param>
            <param name="bGrowBox">
[in] default=0 (false) 
If 1 (true), then the union of the input bbox and the point list's bounding box is returned in bbox.  
If 0 (false), the point list's bounding box is returned in bbox.
</param>
            <returns>true if successful.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPointArray.BoundingBox">
            <summary>Get 3d axis aligned bounding box.</summary>
            <returns>3d bounding box of point list.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fPointArray.GetBBox(System.Single[],System.Single[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fPointArray.GetBBox(System.Single[],System.Single[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPointArray.#ctor">
            <summary>
see ON_SimpleArray class definition comments for constructor documentation
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPointArray.GetBBox(System.Double[],System.Double[])">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPointArray.GetBBox(System.Double[],System.Double[],System.Int32)">
            <summary>
returns true if successful
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the vector in place. The transformation matrix acts on
the left of the vector; i.e., result = transformation*vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.PerpendicularTo(RMA.OpenNURBS.IOn3fVector)">
            <summary>
set this vector to be perpendicular to another vector
Result is not unitized.
</summary>
            <returns>false if input vector is zero</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsZero">
            <summary>
Returns: true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Zero">
            <summary>
set all coordinates to zero
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">optional angle tolerance (radians)</param>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_LessThanOrEqual(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Multiply(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Multiply(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3fPoint)">
            <summary>
inner (dot) product (point acting as a vector)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Multiply(RMA.OpenNURBS.On3fVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.op_Implicit(RMA.OpenNURBS.IOn2fVector)~RMA.OpenNURBS.On3fVector">
            <summary>
use implicit operator=(const ON_3fVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>note that this vector is losing precision</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor(RMA.OpenNURBS.IOn3fPoint)">
            <summary>from 3d point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor(RMA.OpenNURBS.IOn2fVector)">
            <summary>from 2d vector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fVector.UnitVector(System.Int32)">
            <summary>A index driven function to get unit axis vectors.</summary>
            <param name="index">
[in] 0 returns (1,0,0), 1 returns (0,1,0), 2 returns (0,0,1)
</param>
            <returns>Unit 3d vector with vector[i] = (i==index)?1:0;</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn3fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">optional angle tolerance (radians)</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.PerpendicularTo(RMA.OpenNURBS.IOn2fPoint,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
set this vector to be perpendicular to a line defined by 2 points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.PerpendicularTo(RMA.OpenNURBS.IOn2fVector)">
            <summary>
set this vector to be perpendicular to another vector
Result is not unitized.
</summary>
            <returns>returns false if input vector is zero</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsZero">
            <summary>
Returns: true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.Decompose(RMA.OpenNURBS.IOn2fVector,RMA.OpenNURBS.IOn2fVector,System.Double@,System.Double@)">
            <summary>Computes a, b such that this vector = a*X + b*Y</summary>
            <returns>
false if unable to solve for a,b.  This happens
when X,Y is not really a basis.

If X,Y is known to be an orthonormal frame,
then a = V*X, b = V*Y will compute
the same result more quickly.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_LessThanOrEqual(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2fVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Multiply(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Multiply(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
inner (dot) product point acting as a vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Multiply(RMA.OpenNURBS.On2fVector,RMA.OpenNURBS.IOn2fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.op_Implicit(RMA.OpenNURBS.IOn3fVector)~RMA.OpenNURBS.On2fVector">
            <summary>
use implicit operator=(const ON_2fVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.#ctor(RMA.OpenNURBS.IOn2fPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.#ctor(RMA.OpenNURBS.IOn3fVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fVector.UnitVector(System.Int32)">
            <summary>A index driven function to get unit axis vectors.</summary>
            <param name="index">[in] 0 returns (1,0), 1 returns (0,1)</param>
            <returns>Unit 3d vector with vector[i] = (i==index)?1:0;</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsZero">
            <summary>
Returns: true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsPerpendicularTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.IsParallelTo(RMA.OpenNURBS.IOn2fVector,System.Double)">
            <returns>
1: this and other vectors are parallel
-1: this and other vectors are anti-parallel
0: this and other vectors are not parallel or at least one of the vectors is zero
</returns>
            <param name="angle_tolerance">radians</param>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.Decompose(RMA.OpenNURBS.IOn2fVector,RMA.OpenNURBS.IOn2fVector,System.Double@,System.Double@)">
            <summary>Computes a, b such that this vector = a*X + b*Y</summary>
            <returns>
false if unable to solve for a,b.  This happens
when X,Y is not really a basis.

If X,Y is known to be an orthonormal frame,
then a = V*X, b = V*Y will compute
the same result more quickly.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.Normalize">
            <summary>
set so x^2 + y^2 + z^2 + w^2 = 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.Zero">
            <summary>
set all 4 coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Equality(RMA.OpenNURBS.On4fPoint,RMA.OpenNURBS.IOn4fPoint)">
            <summary>
projective comparison
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Subtraction(RMA.OpenNURBS.On4fPoint,RMA.OpenNURBS.IOn4fPoint)">
            <summary>
difference w = sqrt(w1*w2)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Addition(RMA.OpenNURBS.On4fPoint,RMA.OpenNURBS.IOn4fPoint)">
            <summary>
sum w = sqrt(w1*w2)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.op_Implicit(RMA.OpenNURBS.IOn2fPoint)~RMA.OpenNURBS.On4fPoint">
            <summary>
use implicit operator=(const ON_4fPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn3fVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn2fVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn3fPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor(RMA.OpenNURBS.IOn2fPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4fPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.Set(System.Double,System.Double,System.Double)">
            <summary>note that you will lose precision</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_LessThanOrEqual(RMA.OpenNURBS.On3fPoint,RMA.OpenNURBS.IOn3fPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_Multiply(RMA.OpenNURBS.On3fPoint,RMA.OpenNURBS.IOn3fVector)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_Multiply(RMA.OpenNURBS.On3fPoint,RMA.OpenNURBS.IOn3fPoint)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.op_Implicit(RMA.OpenNURBS.IOn2fPoint)~RMA.OpenNURBS.On3fPoint">
            <summary>
use implicit operator=(const ON_3fPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.ValueTypes.Point3f)">
            <summary>
from Point3f
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>Note that precision will be lost</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn3fVector)">
            <summary>from 3d vector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn4fPoint)">
            <summary>from homogeneous 4d point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor(RMA.OpenNURBS.IOn2fPoint)">
            <summary>from 2d point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3fPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
rotatation in XY plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Rotate(System.Double,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
rotatation in XY plane
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_LessThanOrEqual(RMA.OpenNURBS.On2fPoint,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_Multiply(RMA.OpenNURBS.On2fPoint,RMA.OpenNURBS.IOn2fVector)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_Multiply(RMA.OpenNURBS.On2fPoint,RMA.OpenNURBS.IOn2fPoint)">
            <summary>
for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.op_Implicit(RMA.OpenNURBS.IOn3fPoint)~RMA.OpenNURBS.On2fPoint">
            <summary>
use implicit operator=(const ON_2fPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.ValueTypes.Point2f)">
            <summary>
from Point2f
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.IOn2fVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.IOn4fPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor(RMA.OpenNURBS.IOn3fPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2fPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2fPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceCurvature.k2">
            <summary>
principal curvatures
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnSurfaceCurvature.k1">
            <summary>
principal curvatures
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceCurvature.k2">
            <summary>
principal curvatures
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnSurfaceCurvature.k1">
            <summary>
principal curvatures
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Maximum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Minimum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Get point on plane that is closest to a given point. Parameters: point - [in] Returns: A 3d point on the plane that is closest to the input point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
Description: Transform the plane equation so that, if e0 is the initial equation, e1 is transformed equation and P is a point, then e0.ValueAt(P) = e1.ValueAt(xform*P). Parameters: xform - [in] Invertable transformation. Returns: True if the plane equation was successfully transformed. False if xform is not invertable or the equation is not valid. Remarks: This function has to invert xform. If you have apply the same transformation to a bunch of planes, then it will be more efficient to calculate xform's inverse transpose and apply the resultingt transformation to the equation's coefficients as if they were 4d point coordinates.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.ValueAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluate the plane at a point. Parameters: P - [in] Returns: x*P.x + y*P.y + z*P.z + d;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.Create(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>
Description: Sets (x,y,z) to a unitized N and then sets d = -(x*P.x + y*P.y + z*P.z). Parameters: P - [in] point on the plane N - [in] vector perpindicular to the plane Returns: true if input is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnPlaneEquation.IsValid">
            <summary>
C++ defaults for construction, destruction, copys, and operator=
work fine.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnPlaneEquation.d">
            <summary>
4th coefficient of the plane equation.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MaximumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the maximum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Maximum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.MinimumValueAt(RMA.OpenNURBS.IOnBoundingBox)">
            <summary>
Description: Get the minimum value of the plane equation on a bounding box. Parameters: bbox - [in] Returns: Minimum value of the plane equation on the bounding box.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.ClosestPointTo(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Get point on plane that is closest to a given point. Parameters: point - [in] Returns: A 3d point on the plane that is closest to the input point.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.ValueAt(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
Description: Evaluate the plane at a point. Parameters: P - [in] Returns: x*P.x + y*P.y + z*P.z + d;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnPlaneEquation.IsValid">
            <summary>
C++ defaults for construction, destruction, copys, and operator=
work fine.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnPlaneEquation.d">
            <summary>
4th coefficient of the plane equation.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the vector in place. The transformation matrix acts on
the left of the vector; i.e., result = transformation*vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.PerpendicularTo(RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
set this vector to be perpendicular to a plane defined by 3 points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.PerpendicularTo(RMA.OpenNURBS.IOn3dVector)">
            <summary>
Result is not unitized.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsZero">
            <summary>
Returns:
 true if vector is the zero vector.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsTiny">
            <summary>Test a vector to see if it is very short with tiny_tol = ON_ZERO_TOLERANCE</summary>
            <returns>( fabs(x) &lt;= tiny_tol AND fabs(y) &lt;= tiny_tol AND fabs(z) &lt;= tiny_tol )</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
            <param name="tiny_tol">
[in] (default = ON_ZERO_TOLERANCE) a nonzero value used as the coordinate zero tolerance.
</param>
            <returns>( fabs(x) &lt;= tiny_tol AND fabs(y) &lt;= tiny_tol AND fabs(z) &lt;= tiny_tol )</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.LengthAndUnitize">
            <summary>unitizes and returns initial length</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Unitize">
            <summary>
returns false if vector has zero length
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Reverse">
            <summary>
negate all coordinates
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.Set(System.Double,System.Double,System.Double)">
            <summary>
set 3d vector value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_LessThanOrEqual(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Multiply(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Multiply(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Multiply(RMA.OpenNURBS.On3dVector,RMA.OpenNURBS.IOn3dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.op_Implicit(RMA.OpenNURBS.IOn2dVector)~RMA.OpenNURBS.On3dVector">
            <summary>
use implicit operator=(const ON_3dVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor(RMA.OpenNURBS.ValueTypes.Vector3d)">
            <summary>
from Vector3d
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor(RMA.OpenNURBS.IOn2dVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dVector.UnitVector(System.Int32)">
            <summary>
Description:
 A index driven function to get unit axis vectors.
Parameters:
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsZero">
            <returns>true if vector is the zero vector.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.Fuzz">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the vector in place. The transformation matrix acts on
the left of the vector; i.e., result = transformation*vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.PerpendicularTo(RMA.OpenNURBS.IOn2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>set this vector to be perpendicular to a line defined by 2 points</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.PerpendicularTo(RMA.OpenNURBS.IOn2dVector)">
            <summary>Result is not unitized.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsZero">
            <returns>true if vector is the zero vector.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Unitize">
            <returns>false if vector has zero length</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Reverse">
            <summary>negate all coordinates</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Zero">
            <summary>set all coordinates to zero</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.WedgeProduct(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Signed area of the parallelagram.  The volume element.
returns x*B.y - y*B.x
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.Set(System.Double,System.Double)">
            <summary>
set 2d vector value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_LessThanOrEqual(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2dVector)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Multiply(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2fVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Multiply(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
inner (dot) product (point acting as vector)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Multiply(RMA.OpenNURBS.On2dVector,RMA.OpenNURBS.IOn2dVector)">
            <summary>
inner (dot) product
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.op_Implicit(RMA.OpenNURBS.IOn3dVector)~RMA.OpenNURBS.On2dVector">
            <summary>
use implicit operator=(const ON_2dVector&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor(RMA.OpenNURBS.ValueTypes.Vector2d)">
            <summary>
from Vector2d
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dVector.UnitVector(System.Int32)">
            <summary>A index driven function to get unit axis vectors.</summary>
            <param name="index">[in] 0 returns (1,0), 1 returns (0,1)</param>
            <returns>Unit 2d vector with vector[i] = (i==index)?1:0;</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsZero">
            <returns>true if vector is the zero vector.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsTiny">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsTiny(System.Double)">
            <summary>Test a vector to see if it is very short</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.WedgeProduct(RMA.OpenNURBS.IOn2dVector)">
            <summary>
Signed area of the parallelagram.  The volume element.
returns x*B.y - y*B.x
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dVector.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Normalize">
            <summary>
set so x^2 + y^2 + z^2 + w^2 = 1
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Zero">
            <summary>
set all 4 coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.Set(System.Double,System.Double,System.Double,System.Double)">
            <summary>set 4d point value</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Equality(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
projective comparison
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Subtraction(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
difference w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Addition(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
sum w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_SubtractionAssignment(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
difference w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_AdditionAssignment(RMA.OpenNURBS.On4dPoint,RMA.OpenNURBS.IOn4dPoint)">
            <summary>
sum w = sqrt(|w1*w2|)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.op_Implicit(RMA.OpenNURBS.IOn2fPoint)~RMA.OpenNURBS.On4dPoint">
            <summary>
use implicit operator=(const ON_4dPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.ValueTypes.Point4d)">
            <summary>
from Point3d
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn2dVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On4dPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn4dPoint.IsValid">
            <summary>
Description If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid. Returns: true if the point is valid.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(RMA.OpenNURBS.IOn3dVector)">
            <summary>set value from existing vector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(RMA.OpenNURBS.IOn3fPoint)">
            <summary>set value from existing point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(RMA.OpenNURBS.IOn3dPoint)">
            <summary>set value from existing point</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.Set(System.Double,System.Double,System.Double)">
            <summary>set 3d point value</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_LessThanOrEqual(RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_Multiply(RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOn3dVector)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_Multiply(RMA.OpenNURBS.On3dPoint,RMA.OpenNURBS.IOn3dPoint)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.op_Implicit(RMA.OpenNURBS.IOn2dPoint)~RMA.OpenNURBS.On3dPoint">
            <summary>
use implicit operator=(const ON_3dPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.ValueTypes.Point3d)">
            <summary>
from Point3d
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.IOn3dVector)">
            <summary>
from 3d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.IOn4dPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(RMA.OpenNURBS.IOn2dPoint)">
            <summary>
from 2d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor(System.Double,System.Double,System.Double)">
            <summary>
:x(xx),y(yy),z(zz)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On3dPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.Fuzz">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.Fuzz(System.Double)">
            <summary>
tolerance to use when comparing 3d points
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn3dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Rotate(System.Double,System.Double,RMA.OpenNURBS.IOn2dPoint)">
            <summary>rotatation in XY plane</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Rotate(System.Double,RMA.OpenNURBS.IOn2dPoint)">
            <summary>rotatation in XY plane</summary>
            <param name="angle">angle in radians</param>
            <param name="center">center of rotation</param>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Transform(RMA.OpenNURBS.IOnXform)">
            <summary>
These transform the point in place. The transformation matrix acts on
the left of the point; i.e., result = transformation*point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Zero">
            <summary>
set all coordinates to zero;
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.Set(System.Double,System.Double)">
            <summary>
set 2d point value
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_LessThanOrEqual(RMA.OpenNURBS.On2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
dictionary order comparisons
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_Multiply(RMA.OpenNURBS.On2dPoint,RMA.OpenNURBS.IOn2dVector)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_Multiply(RMA.OpenNURBS.On2dPoint,RMA.OpenNURBS.IOn2dPoint)">
            <summary>
dot product for points acting as vectors
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.op_Implicit(RMA.OpenNURBS.IOn3dPoint)~RMA.OpenNURBS.On2dPoint">
            <summary>
use implicit operator=(const ON_2dPoint&amp;)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.ValueTypes.Point2d)">
            <summary>
from Point2d
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.IOn2dVector)">
            <summary>
from 2d vector
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.IOn4dPoint)">
            <summary>
from homogeneous 4d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor(RMA.OpenNURBS.IOn3dPoint)">
            <summary>
from 3d point
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.On2dPoint.#ctor">
            <summary>
not initialized
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPoint.MinimumCoordinate">
            <summary>
absolute value of minimum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPoint.MaximumCoordinate">
            <summary>
absolute value of maximum coordinate
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOn2dPoint.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
            <returns>true if the point is valid.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Union(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
The union of an empty set and an increasing interval is the increasing
interval.  The union of two empty sets is empty. The union of an empty
set an a non-empty interval is the non-empty interval.
The union of two non-empty intervals is
union = [min(argA.Min(),argB.Min()), max(argA.Max(),argB.Max()),]
Union() returns true if the union is not empty.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Union(RMA.OpenNURBS.IOnInterval)">
            <summary>
The union of an empty set and an increasing interval is the increasing
interval.  The union of two empty sets is empty. The union of an empty
set an a non-empty interval is the non-empty interval.
The union of two non-empty intervals is
union = [min(this.Min(),arg.Min()), max(this.Max(),arg.Max()),]
Union() returns true if the union is not empty.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Intersection(RMA.OpenNURBS.IOnInterval,RMA.OpenNURBS.IOnInterval)">
            <summary>
If the intersection is not empty, then 
intersection = [max(argA.Min(),argB.Min()), min(argA.Max(),argB.Max())]
Intersection() returns true if the intersection is not empty.
The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
the empty set interval.  The result of any intersection involving an
empty set interval or disjoint intervals is the empty set interval.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Intersection(RMA.OpenNURBS.IOnInterval)">
            <summary>
If the intersection is not empty, then 
intersection = [max(this.Min(),arg.Min()), min(this.Max(),arg.Max())]
Intersection() returns true if the intersection is not empty.
The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
the empty set interval.  The result of any intersection involving an
empty set interval or disjoint intervals is the empty set interval.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Swap">
            <summary>
Swaps m_t[0] and m_t[1].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Reverse">
            <summary>
Changes interval to [-m_t[1],-m_t[0]].
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(RMA.OpenNURBS.IOnInterval)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <param name="bProperSubSet">[in] if true, then the test is for a proper subinterval.</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(System.Double)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Includes(System.Double,System.Boolean)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <param name="bTestOpenInterval">
[in] If false, t is tested to see if it satisfies min &lt;= t &lt;= max.
If true, t is tested to see if it satisfies min &lt; t &lt; max.
</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Compare(RMA.OpenNURBS.IOnInterval)">
            <returns>
0 this is idential to other
-1 this[0] &lt; other[0]
+1 this[0] &gt; other[0]
-1 this[0] == other[0] and this[1] &lt; other[1]
+1 this[0] == other[0] and this[1] &gt; other[1]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.MakeIncreasing">
            <summary>
returns true if resulting interval IsIncreasing()
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsValid">
            <summary>
returns ON_IsValid(m_t[0]) &amp;&amp; ON_IsValid(m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsEmptySet">
            <summary>
returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsSingleton">
            <summary>
returns true if m_t[0] == m_t[1] != ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsInterval">
            <summary>
returns true if m_t[0] != m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsDecreasing">
            <summary>
returns true if m_t[0] &gt; m_t[0];
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.IsIncreasing">
            <summary>
returns true if m_t[0] &lt; m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Mid">
            <summary>
returns 0.5*(m_t[0] + m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Max">
            <summary>
returns larger of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Min">
            <summary>
returns smaller of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.NormalizedParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.NormalizedParameterAt(System.Double)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.ParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.ParameterAt(System.Double)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Set(System.Double,System.Double)">
            <summary>Sets interval to [t0,t1]</summary>
            <param name="t0">[in]</param>
            <param name="t1">[in]</param>
            <remarks>
See Also: ON_Interval::ON_Interval( double, double )
</remarks>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.Destroy">
            <summary>Sets interval to (ON_UNSET_VALUE,ON_UNSET_VALUE)</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnInterval.#ctor(RMA.OpenNURBS.ValueTypes.Interval)">
            <summary>
from Interval
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnInterval.m_t(System.Int32)">
            <summary>
Interval = [m_t[0], m_t[1]]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(RMA.OpenNURBS.IOnInterval)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(RMA.OpenNURBS.IOnInterval,System.Boolean)">
            <summary>Test an interval to see if it is contained in this interval.</summary>
            <param name="other">[in] interval to test</param>
            <param name="bProperSubSet">[in] if true, then the test is for a proper subinterval.</param>
            <returns>
If bProperSubSet is false, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max().
If bProperSubSet is true, then the result is true when this-&gt;Min() &lt;= other.Min() and other.Max() &lt;= this-&gt;Max() and at least one of the inequalites is strict.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(System.Double)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Includes(System.Double,System.Boolean)">
            <summary>Test a value t to see if it is inside the interval.</summary>
            <param name="t">[in] value to test</param>
            <param name="bTestOpenInterval">
[in] If false, t is tested to see if it satisfies min &lt;= t &lt;= max.
If true, t is tested to see if it satisfies min &lt; t &lt; max.
</param>
            <returns>true if t is in the interval and false if t is not in the interval.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Compare(RMA.OpenNURBS.IOnInterval)">
            <returns>
0 this is idential to other
-1 this[0] &lt; other[0]
+1 this[0] &gt; other[0]
-1 this[0] == other[0] and this[1] &lt; other[1]
+1 this[0] == other[0] and this[1] &gt; other[1]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsValid">
            <summary>
returns ON_IsValid(m_t[0]) &amp;&amp; ON_IsValid(m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsEmptySet">
            <summary>
returns true if m_t[0] == m_t[1] == ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsSingleton">
            <summary>
returns true if m_t[0] == m_t[1] != ON_UNSET_VALUE
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsInterval">
            <summary>
returns truc if m_t[0] != m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsDecreasing">
            <summary>
returns true if m_t[0] &gt; m_t[0];
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.IsIncreasing">
            <summary>
returns true if m_t[0] &lt; m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Mid">
            <summary>
returns 0.5*(m_t[0] + m_t[1])
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Max">
            <summary>
returns larger of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.Min">
            <summary>
returns smaller of m_t[0] and m_t[1]
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.NormalizedParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.NormalizedParameterAt(System.Double)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>
Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.
See Also: ON_Interval::ParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.ParameterAt(RMA.OpenNURBS.IOnInterval)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnInterval.ParameterAt(System.Double)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>
Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter
See Also: ON_Interval::NormalizedParameterAt
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IOnInterval.m_t(System.Int32)">
            <summary>
Interval = [m_t[0], m_t[1]]
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnLinetypeSegment.m_length">
            <summary>
length in millimeters on printed output
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnLinetypeSegment.m_length">
            <summary>
length in millimeters on printed output
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnLinetypeSegment.eSegType">
            <summary>
For a curve to be drawn starting at the start point
and ending at the endpoint, the first segment
in the pattern must be a stLine type
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnDisplayMaterialRef.#ctor">
            <summary>
Description: Default constructor sets both ids to nil.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDisplayMaterialRef.m_invisible_in_detail_id">
            <summary>
For Rhino V4 the per detail visibility attribute is implemented through a
display material reference on an object. This is ONLY for for detail viewports
and only for V4. Keep this uuid around so the per detail attributes in future
versions of Rhino can be implemented a different way
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDisplayMaterialRef.m_display_material_id">
            <summary>
identifies the ON_DisplayMaterial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnDisplayMaterialRef.m_viewport_id">
            <summary>
identifies the ON_Viewport
If nil, then the display material will be used in all viewports
that are not explictly referenced in other ON_DisplayMaterialRefs.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnDisplayMaterialRef">
            <summary>
Objects can have per viewport display properties that override a viewport's default display
properties.  These overrides are stored on ON_3dmObjectAttributes as a list of ON_DisplayMaterialRefs.
 
For example, by default a viewport might display objects using a wireframe, but
one special object may need to be shaded. In this case the special object would have
a display material ref with the "wireframe" viewport's id and the id of a display material
that specified shading.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDisplayMaterialRef.m_display_material_id">
            <summary>
identifies the ON_DisplayMaterial
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnDisplayMaterialRef.m_viewport_id">
            <summary>
identifies the ON_Viewport
If nil, then the display material will be used in all viewports
that are not explictly referenced in other ON_DisplayMaterialRefs.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnDisplayMaterialRef">
            <summary>
Objects can have per viewport display properties that override a viewport's default display
properties.  These overrides are stored on ON_3dmObjectAttributes as a list of ON_DisplayMaterialRefs.
 
For example, by default a viewport might display objects using a wireframe, but
one special object may need to be shaded. In this case the special object would have
a display material ref with the "wireframe" viewport's id and the id of a display material
that specified shading.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Value">
            <summary>
Returns 0.0 (black) to 1.0 (white)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Saturation">
            <summary>
Returns 0.0 (gray) to 1.0 (saturated)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Hue">
            <summary>
returns an angle in the range 0 to 2*pi 
0 = red, pi/3 = yellow, 2*pi/3 = green, 
pi = cyan, 4*pi/3 = blue,5*pi/3 = magenta,
2*pi = red
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.SetFractionalRGBA(System.Double,System.Double,System.Double,System.Double)">
            <summary>
input args
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.SetRGB(System.Int32,System.Int32,System.Int32)">
            <summary>
0 to 255
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionAlpha">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionBlue">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionGreen">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.FractionRed">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Alpha">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Blue">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Green">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Red">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.Compare(RMA.OpenNURBS.IOnColor)">
            <summary>
&lt; 0 if this &lt; arg, 0 ir this==arg, &gt; 0 if this &gt; arg
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.op_Implicit(RMA.OpenNURBS.OnColor)~System.UInt32">
            <summary>
Conversion to COLORREF
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor(System.UInt32)">
            <summary>
Construct from COLORREF
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnColor.#ctor">
            <summary>
Default is black
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Value">
            <summary>
Returns 0.0 (black) to 1.0 (white)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Saturation">
            <summary>
Returns 0.0 (gray) to 1.0 (saturated)
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Hue">
            <summary>
returns an angle in the range 0 to 2*pi 
0 = red, pi/3 = yellow, 2*pi/3 = green, 
pi = cyan, 4*pi/3 = blue,5*pi/3 = magenta,
2*pi = red
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionAlpha">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionBlue">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionGreen">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.FractionRed">
            <summary>
( 0.0 to 1.0 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Alpha">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Blue">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Green">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Red">
            <summary>
( 0 to 255 )
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnColor.Compare(RMA.OpenNURBS.IOnColor)">
            <summary>
&lt; 0 if this &lt; arg, 0 ir this==arg, &gt; 0 if this &gt; arg
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUnitSystem.Default">
            <summary>
millimeters = default unit system
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUnitSystem.#ctor">
            <summary>
default constructor units are millimeters.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUnitSystem.m_custom_unit_name">
            <summary>
name of custom units
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUnitSystem.m_custom_unit_scale">
            <summary>
The m_custom_unit_... settings apply when m_unit_system = ON::custom_unit_system
1 meter = m_custom_unit_scale custom units
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUnitSystem.m_custom_unit_name">
            <summary>
name of custom units
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUnitSystem.m_custom_unit_scale">
            <summary>
The m_custom_unit_... settings apply when m_unit_system = ON::custom_unit_system
1 meter = m_custom_unit_scale custom units
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(System.String)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(System.String,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.SetFileCheckSum(System.String)">
            <summary>Set check sum values for a file.</summary>
            <param name="filename">[in] name of file.</param>
            <returns>True if checksum is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.SetFileCheckSum(RMA.OpenNURBS.OnFileHandle)">
            <summary>Set check sum values for a file.</summary>
            <param name="fp">[in] pointer to a file opened with ON:FileOpen(...,L"rb")</param>
            <returns>True if checksum is set.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.IsSet">
            <summary>
Returns: True if checksum is set.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCheckSum.Zero">
            <summary>
zeros all fields.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCheckSum.m_crc(System.Int32)">
            <summary>
crc's
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnCheckSum.m_time">
            <summary>
UCT seconds since Jan 1, 1970
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnCheckSum">
            <summary>
This class is intended to be used to determine if a file's
contents have changed.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(System.String)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(System.String,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="filename">[in]</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.CheckFile(RMA.OpenNURBS.OnFileHandle,System.Boolean)">
            <summary>Test buffer to see if it has a matching checksum.</summary>
            <param name="fp">[in] pointer to file opened with ON::OpenFile(...,L"rb")</param>
            <param name="bSkipTimeCheck">[in] if true, the time of last modification is not checked.</param>
            <returns>True if the file has a matching checksum.</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCheckSum.IsSet">
            <summary>
Returns: True if checksum is set.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCheckSum.m_crc(System.Int32)">
            <summary>
crc's
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCheckSum.m_time">
            <summary>
UCT seconds since Jan 1, 1970
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCheckSum">
            <summary>
This class is intended to be used to determine if a file's
contents have changed.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnFileHandle">
            <summary>Wraps a FILE* for opening and closing OpenNURBS model files</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareIndex(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Compare m_i and ignore m_id.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareId(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Compare m_id and ignore m_i.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareIndexAndId(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Dictionary compare m_id and then m_i.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnUuidIndex.CompareIdAndIndex(RMA.OpenNURBS.IOnUuidIndex,RMA.OpenNURBS.IOnUuidIndex)">
            <summary>Dictionary compare m_id and then m_i.</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUuidIndex.m_i">
            <summary>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.OnUuidIndex.m_id">
            <summary>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnUuidIndex">
            <summary>
This class is used by ON_UuidIndexList.  It is used when
uuids are used to search for items that can be found by
an integer index.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUuidIndex.m_i">
            <summary>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnUuidIndex.m_id">
            <summary>
In cases when there is a discrepancy between the m_id and
m_i, m_id is assumed to be valid unless comments where this
class is used indicate otherwise.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnUuidIndex">
            <summary>
This class is used by ON_UuidIndexList.  It is used when
uuids are used to search for items that can be found by
an integer index.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsAnnotationComponentIndex">
            <summary>
Returns: True if m_type = dim_... and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsPointCloudComponentIndex">
            <summary>
Returns: True if m_type = pointcloud_point and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsGroupMemberComponentIndex">
            <summary>
Returns: True if m_type = group_member and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsPolyCurveComponentIndex">
            <summary>
Returns: True if m_type = polycurve_segment and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsIDefComponentIndex">
            <summary>
Returns: True if m_type = idef_part and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsBrepComponentIndex">
            <summary>
Returns: True if m_type is set to one of the brep TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsMeshComponentIndex">
            <summary>
Returns: True if m_type is set to one of the mesh or meshtop TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.IsSet">
            <summary>
Returns: True if m_type is set to a TYPE enum value between brep_vertex and polycurve_segment.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.UnSet">
            <summary>
Sets m_type = invalid_type and m_index = -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.#ctor(RMA.OpenNURBS.IOnCOMPONENT_INDEX.TYPE,System.Int32)">
            <summary>
Sets m_type = type and m_index = index.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.#ctor">
            <summary>
Sets m_type = invalid_type and m_index = -1.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.Compare(RMA.OpenNURBS.IOnCOMPONENT_INDEX,RMA.OpenNURBS.IOnCOMPONENT_INDEX)">
            <summary>Dictionary compare on m_type, m_index as ints.</summary>
            <returns>
&lt; 0: a &lt; b
= 0: a = b
&gt; 0: a &gt; b
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.OnCOMPONENT_INDEX.Type(System.Int32)">
            <summary>Safe conversion of integer value to TYPE enum.</summary>
            <param name="i">[in] integer with value equal to one of the TYPE enums.</param>
            <returns>
The TYPE enum with the same numeric value or
ON_COMPONENT_INDEX::invalid_type if no corresponding enum exists.
</returns>
        </member>
        <member name="P:RMA.OpenNURBS.OnCOMPONENT_INDEX.m_index">
            <summary>
The interpretation of m_index depends on the m_type value. m_type m_index interpretation (0 based indices) no_type used when context makes it clear what array is being index brep_vertex ON_Brep.m_V[] array index brep_edge ON_Brep.m_E[] array index brep_face ON_Brep.m_F[] array index brep_trim ON_Brep.m_T[] array index brep_loop ON_Brep.m_L[] array index mesh_vertex ON_Mesh.m_V[] array index meshtop_vertex ON_MeshTopology.m_topv[] array index meshtop_edge ON_MeshTopology.m_tope[] array index mesh_face ON_Mesh.m_F[] array index idef_part ON_InstanceDefinition.m_object_uuid[] array index polycurve_segment ON_PolyCurve::m_segment[] array index dim_linear_point ON_LinearDimension2::POINT_INDEX dim_radial_point ON_RadialDimension2::POINT_INDEX dim_angular_point ON_AngularDimension2::POINT_INDEX dim_ordinate_point ON_OrdinateDimension2::POINT_INDEX dim_text_point ON_TextEntity2 origin point
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.OnCOMPONENT_INDEX">
            <summary>
Component indices are used to provide a persistent way
to identify portions of complex objects.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsAnnotationComponentIndex">
            <summary>
Returns: True if m_type = dim_... and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsPointCloudComponentIndex">
            <summary>
Returns: True if m_type = pointcloud_point and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsGroupMemberComponentIndex">
            <summary>
Returns: True if m_type = group_member and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsPolyCurveComponentIndex">
            <summary>
Returns: True if m_type = polycurve_segment and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsIDefComponentIndex">
            <summary>
Returns: True if m_type = idef_part and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsBrepComponentIndex">
            <summary>
Returns: True if m_type is set to one of the brep TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsMeshComponentIndex">
            <summary>
Returns: True if m_type is set to one of the mesh or meshtop TYPE enum values and m_index &gt;= 0.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IOnCOMPONENT_INDEX.IsSet">
            <summary>
Returns: True if m_type is set to a TYPE enum value between brep_vertex and polycurve_segment.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IOnCOMPONENT_INDEX.m_index">
            <summary>
The interpretation of m_index depends on the m_type value. m_type m_index interpretation (0 based indices) no_type used when context makes it clear what array is being index brep_vertex ON_Brep.m_V[] array index brep_edge ON_Brep.m_E[] array index brep_face ON_Brep.m_F[] array index brep_trim ON_Brep.m_T[] array index brep_loop ON_Brep.m_L[] array index mesh_vertex ON_Mesh.m_V[] array index meshtop_vertex ON_MeshTopology.m_topv[] array index meshtop_edge ON_MeshTopology.m_tope[] array index mesh_face ON_Mesh.m_F[] array index idef_part ON_InstanceDefinition.m_object_uuid[] array index polycurve_segment ON_PolyCurve::m_segment[] array index dim_linear_point ON_LinearDimension2::POINT_INDEX dim_radial_point ON_RadialDimension2::POINT_INDEX dim_angular_point ON_AngularDimension2::POINT_INDEX dim_ordinate_point ON_OrdinateDimension2::POINT_INDEX dim_text_point ON_TextEntity2 origin point
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.IOnCOMPONENT_INDEX">
            <summary>
Component indices are used to provide a persistent way
to identify portions of complex objects.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.TypeCodes.TC_USER_RECORD">
            <summary>Information saved by the plug-in is in a TC_USER_RECORD chunk</summary>
        </member>
        <member name="P:RMA.OpenNURBS.TypeCodes.TC_USER_TABLE_UUID">
            <summary>
Each user table entry has two top level chunks, a TC_USER_TABLE_UUID chunk
and a TC_USER_RECORD chunk.
The TC_USER_TABLE_UUID chunk contains the plug-in id and, if the archive is V5 or later
and was written by an opennurbs with version &gt;= 200910190, a TC_USER_TABLE_RECORD_HEADER chunk.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.TypeCodes.TC_COMMENTBLOCK">
            <summary>
The TCODE_COMMENTBLOCK is the first chunk in the file, starts 32 bytes into
the file, and contains text information terminated with a ^Z.  This ^Z and
contents of this chunk were expanded in February 2000.  Files written with
code released earlier than this will not have the ^Z.

The TCODE_ENDOFFILE is the last chunk in the file and the first 4 bytes
of information in this chunk is an integer that contains the file length.
This chunk was added in February 2000 and files written with code released
earlier than this will not have this termination block.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.TypeCodes">
            <summary>
Typecode format 4 bytes long
x xxxxxxxxxxxxxxx,x xxx xxxx xxxx x x xx
| |               | |               | |  |
|        |        |                 |
|        |        |         |       +---  "stuff" bit
|        |        |         |
|        |        |         +-- specific codes
|        |        |
|        |        +-- RESERVED - DO NOT USE (should be 0) (will be used to control CRC on/off)
|        |
|        +-- category:_000 0000 0000 0001  Legacy geometry    TCODE_LEGACY_GEOMETRY
|                     _000 0000 0000 0010  openNURBS object   TCODE_OPENNURBS_OBJECT
|                     _000 0000 0000 0100  -- RESERVED - DO NOT USE (should be 0 in any typecode) -- 
|                     _000 0000 0000 1000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --                     
|                     _000 0000 0001 0000  Geometry           TCODE_GEOMETRY
|                     _000 0000 0010 0000  Annotation
|                     _000 0000 0100 0000  Display Attributes TCODE_DISPLAY
|                     _000 0000 1000 0000  Rendering          TCODE_RENDER     
|                     _000 0001 0000 0000                         
|                     _000 0010 0000 0000  Interface          TCODE_INTERFACE 
|                     _000 0100 0000 0000  -- RESERVED - DO NOT USE (should be 0 in any typecode) --
|                     _000 1000 0000 0000  Tolerances         TCODE_TOLERANCE
|                     _001 0000 0000 0000  Tables             TCODE_TABLE    
|                     _010 0000 0000 0000  Table record       TCODE_TABLEREC
|                     _100 0000 0000 0000  User information   TCODE_USER
| 
+-- format: 0 - data size in header  - data block follows    TCODE_SHORT
           1 - data in header - no data block follows
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.MeshTopologyFace.IsValid">
            <summary>
A topological mesh face is valid if TopEdgeIndex[0], TopEdgeIndex[1],
and TopEdgeIndex[2] are mutually distinct, and TopEdgeIndex[3] is either
equal to TopEdgeIndex[2] or mutually distinct from the first three
indices.
</summary>
            <returns>True if face is valid.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.MeshTopologyFace.IsQuad">
            <summary>
A topological mesh face is a valid quad if TopEdgeIndex[0], TopEdgeIndex[1],
TopEdgeIndex[2], and TopEdgeIndex[3] are distinct edges.
</summary>
            <returns>True if face is a quad.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.MeshTopologyFace.IsTriangle">
            <summary>
A topological mesh face is a valid triangle if TopEdgeIndex[0],
TopEdgeIndex[1], TopEdgeIndex[2] are distinct edges and TopEdgeIndex[3]=TopEdgeIndex[2].
</summary>
            <returns>True if face is a triangle.</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.MeshTopologyFace.ReverseEdge(System.Int32)">
            <summary>
If ReverseEdge[i] is 0, then the orientation of the edge matches the
orientation of the face. If ReverseEdge[i] is 1, then the orientation
of the edge is opposite that of the face.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.MeshTopologyFace.TopEdgeIndex(System.Int32)">
            <summary>
TopEdgeIndex[] = indices of the topological edges that bound the face.
If TopEdgeIndex[2] = TopEdgeIndex[3], then the face is a triangle, otherwise the face is a quad.
NOTE WELL:
The topological edge with index TopEdgeIndex[k] ENDS at the vertex corresponding to ON_MeshFace.vi[k].
So, ...
If the face is a quad, (ON_MeshFace.vi[2]!=ON_MeshFace.vi[3]),
the topological edge with index TopEdgeIndex[0] STARTS at
ON_MeshFace.vi[3] and ENDS at ON_MeshFace.vi[0],
the topological edge with index TopEdgeIndex[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index TopEdgeIndex[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2],
and the topological edge with index TopEdgeIndex[3] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],

If the face is a triangle, (ON_MeshFace.vi[2]==ON_MeshFace.vi[3]),
the topological edge with index TopEdgeIndex[0] STARTS at
ON_MeshFace.vi[2] and ENDS at ON_MeshFace.vi[0],
the topological edge with index TopEdgeIndex[1] STARTS at
ON_MeshFace.vi[0] and ENDS at ON_MeshFace.vi[1],
the topological edge with index TopEdgeIndex[2] STARTS at
ON_MeshFace.vi[1] and ENDS at ON_MeshFace.vi[2].
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.MeshTopologyFace">
            <summary>.NET MeshFace is parallel to C++ ON_MeshFace</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.MeshFace.IsValid(System.Int32)">
            <param name="vertex_count">number of vertices in mesh</param>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.MeshFace.VertexIndex(System.Int32)">
            <summary>VertexIndex[2] == VertexIndex[3] for triangles</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.MeshFace">
            <summary>.NET MeshFace is parallel to C++ ON_MeshFace</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Line">
            <summary>.NET Line is parallel to C++ ON_Line</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Xform">
            <summary>.NET Xform is parallel to C++ ON_Xform</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.BoundingBox.IsValid">
            <summary>empty boxes are not valid</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.BoundingBox.Diagonal">
            <summary>max corner - min corner</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.BoundingBox">
            <summary>.NET BoundingBox is parallel to C++ ON_BoundingBox</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Plane.#ctor(RMA.OpenNURBS.ValueTypes.PlaneEquation)">
            <summary>Construct a plane from an equation.</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Plane.#ctor(RMA.OpenNURBS.ValueTypes.Point3d,RMA.OpenNURBS.ValueTypes.Point3d,RMA.OpenNURBS.ValueTypes.Point3d)">
            <summary>Construct a plane from three non-colinear points.</summary>
            <param name="origin">point on the plane</param>
            <param name="xPoint">
second point in the plane. The xaxis will be parallel to x_point-origin.
</param>
            <param name="yPoint">
third point on the plane that is not colinear with the first two points.
yaxis*(y_point-origin) will be &gt; 0.
</param>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Plane.#ctor(RMA.OpenNURBS.ValueTypes.Point3d,RMA.OpenNURBS.ValueTypes.Vector3d,RMA.OpenNURBS.ValueTypes.Vector3d)">
            <summary>Construct a plane from a point, and two vectors in the plane</summary>
            <param name="origin">point on the plane</param>
            <param name="xDirection">
non-zero vector in the plane that determines the xaxis direction.
</param>
            <param name="yDirection">
non-zero vector not parallel to x_dir that is used to determine the
yaxis direction. y_dir does not have to be perpindicular to x_dir
</param>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Plane.#ctor(RMA.OpenNURBS.ValueTypes.Point3d,RMA.OpenNURBS.ValueTypes.Vector3d)">
            <summary>Construct a plane from a point and normal vector.</summary>
            <param name="origin">point on the plane</param>
            <param name="normal">non-zero normal to the plane</param>
            <seealso>CreateFromNormal</seealso>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Plane">
            <summary>.NET Plane is parallel to C++ ON_Plane</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.PlaneEquation">
            <summary>.NET PlaneEquation is parallel to C++ ON_PlaneEquation</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Ray3d">
            <summary>.NET Ray3d is parallel to C++ ON_3dRay</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Vector3f">
            <summary>.NET Vector3d is parallel to C++ ON_3dVector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Vector3d.Perpendicular">
            <summary>
Creates a vector that is perpendicular to the current vector. 
</summary>
            <returns>
Returns a vector perpendicular to the current vector. If a
valid perpendicular vector cannot be created, it returns a
zero vector. Check IsZero property on the returned vector
to determine success.
</returns>
            <summary>
Creates a vector that is perpendicular to the current vector. 
</summary>
            <returns>
Returns a vector perpendicular to the current vector. If a
valid perpendicular vector cannot be created, it returns a
zero vector. Call IsZero on the returned vector to determine
success.
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Vector3d.IsPerpendicularTo(RMA.OpenNURBS.ValueTypes.Vector3d)">
            <summary>
Checks if this and other vector are perpendicular. Uses 
RMA.OpenNURBS.OnUtil.On_DEFAULT_ANGLE_TOLERANCE as angle tolerance.
</summary>
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular
       or at least one of the vectors is zero
</returns>
            <summary>
Checks if this and other vector are perpendicular. Uses 
RMA.OpenNURBS.OnUtil.On_DEFAULT_ANGLE_TOLERANCE as angle tolerance.
</summary>
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular
       or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Vector3d.IsPerpendicularTo(RMA.OpenNURBS.ValueTypes.Vector3d,System.Double)">
            <summary>
Checks if this and other vector are perpendicular.
</summary>
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular
       or at least one of the vectors is zero
</returns>
            <summary>
Checks if this and other vector are perpendicular.
</summary>
            <returns>
true:  this and other vectors are perpendicular
false: this and other vectors are not perpendicular
       or at least one of the vectors is zero
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Vector3d.Reverse">
            <summary>reverses the vector</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Vector3d.IsZero">
            <summary>
Checks if X, Y, and Z values are all equal to 0.0 
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Vector3d">
            <summary>.NET Vector3d is parallel to C++ ON_3dVector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Vector2d.Reverse">
            <summary>reverses the vector</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Vector2d.Unitize(RMA.OpenNURBS.ValueTypes.Vector2d@)">
            <returns>false if vector has zero length</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Vector2d.IsValid">
            <summary>If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Vector2d">
            <summary>.NET Vector2d is parallel to C++ ON_2dVector</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Point4d.IsValid">
            <summary>If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Point4d">
            <summary>.NET Point4d is parallel to C++ ON_4dPoint</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Point3f">
            <summary>.NET Point3d is parallel to C++ ON_3fPoint</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Point2f">
            <summary>.NET Point2f is parallel to C++ ON_2fPoint</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Point3d.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Point3d">
            <summary>.NET Point3d is parallel to C++ ON_3dPoint</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Point2d.IsValid">
            <summary>
If any coordinate of a point is ON_UNSET_VALUE, then the point is not valid.
</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Point2d">
            <summary>.NET Point2d is parallel to C++ ON_2dPoint</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.Compare(RMA.OpenNURBS.ValueTypes.Interval)">
            <returns>
0  this is identical to other
-1  this[0] &lt; other[0]
+1  this[0] &gt; other[0]
-1  this[0] == other[0] and this[1] &lt; other[1]
+1  this[0] == other[0] and this[1] &gt; other[1]
</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.StrictlyIncludesInterval(RMA.OpenNURBS.ValueTypes.Interval)">
            <returns>(T0 &lt; t &lt; T1)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.StrictlyIncludesParameter(System.Double)">
            <returns>(T0 &lt; t &lt; T1)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.IncludesInterval(RMA.OpenNURBS.ValueTypes.Interval)">
            <returns>(T0 &lt;= t &lt;= T1)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.IncludesParameter(System.Double)">
            <returns>(T0 &lt;= t &lt;= T1)</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.NormalizedIntervalAt(RMA.OpenNURBS.ValueTypes.Interval)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.</returns>
            <seealso>ParameterAt</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.NormalizedParameterAt(System.Double)">
            <summary>Convert interval value, or pair of values, to normalized parameter.</summary>
            <returns>Normalized parameter x so that min*(1.0-x) + max*x = interval_parameter.</returns>
            <seealso>ParameterAt</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.ParameterIntervalAt(RMA.OpenNURBS.ValueTypes.Interval)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>Interval parameter min*(1.0-normalized_parameter) + max*normalized_paramete</returns>
            <seealso>NormalizedParameterAt</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.ParameterAt(System.Double)">
            <summary>Convert normalized parameter to interval value, or pair of values.</summary>
            <returns>Interval parameter min*(1.0-normalized_parameter) + max*normalized_parameter</returns>
            <seealso>NormalizedParameterAt</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.Swap">
            <summary>Swaps m_t[0] and m_t[1].</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.Reverse">
            <summary>Changes interval to [-t[1],-t[0]]</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.Set(RMA.OpenNURBS.ValueTypes.Interval@,RMA.OpenNURBS.IOnInterval)">
            <summary>Sets interval to same as input interval</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.Set(RMA.OpenNURBS.ValueTypes.Interval@,System.Double,System.Double)">
            <summary>Sets interval to [t0,t1]</summary>
            <seealso>Interval( double, double )</seealso>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.FromUnion(RMA.OpenNURBS.ValueTypes.Interval,RMA.OpenNURBS.ValueTypes.Interval)">
            <summary>
The union of an empty set and an increasing interval is the increasing
interval.  The union of two empty sets is empty. The union of an empty
set an a non-empty interval is the non-empty interval.
The union of two non-empty intervals is
union = [min(a.Min(),b.Min()), max(a.Max(),b.Max()),]
Union() returns true if the union is not empty.
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ValueTypes.Interval.FromIntersection(RMA.OpenNURBS.ValueTypes.Interval,RMA.OpenNURBS.ValueTypes.Interval)">
            <summary>
If the intersection is not empty, then 
intersection = [max(a.Min(),b.Min()), min(a.Max(),b.Max())]

The interval [ON_UNSET_VALUE,ON_UNSET_VALUE] is considered to be
the empty set interval.  The result of any intersection involving an
empty set interval or disjoint intervals is the empty set interval.
</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.Empty">
            <summary>Sets interval to (ON_UNSET_VALUE,ON_UNSET_VALUE)</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.Mid">
            <summary>returns 0.5*(T[0] + T[1])</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.Max">
            <summary>returns larger of T[0] and T[1]</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.Min">
            <summary>returns smaller of T[0] and T[1]</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.IsDecreasing">
            <summary>returns true if T[0] &gt; T[0]</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.IsIncreasing">
            <summary>returns true if T[0] &lt; T[1]</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.IsSingleton">
            <summary>returns true if T[0] == T[1] != ON_UNSET_VALUE</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.IsEmpty">
            <summary>returns true if T[0] == T[1] == ON_UNSET_VALUE</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ValueTypes.Interval.IsValid">
            <summary>returns ON_IsValid(T[0]) &amp;&amp; ON_IsValid(T[1])</summary>
        </member>
        <member name="T:RMA.OpenNURBS.ValueTypes.Interval">
            <summary>.NET Interval is parallel to C++ ON_Interval</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOnMeshFace.TryFastGet(System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOnMeshFace.TryFastGet(System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4fPoint.CopyToArray">
            <summary>
Create an array of floats[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.W(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4fPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4fPoint.CopyToArray">
            <summary>
Create an array of floats[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.W(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4fPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn4dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.W(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn4dPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*4] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(0).w
array[4] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn4dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.W(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn4dPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fVector.Append(RMA.OpenNURBS.IOn3dVector)">
            <summary>note that precision is lost</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fVector.Append(System.Double,System.Double,System.Double)">
            <summary>note that precision is lost</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fVector.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fVector.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fVector.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fVector.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fVector.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fVector.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fPoint.Append(RMA.OpenNURBS.IOn3dPoint)">
            <summary>note that precision is lost</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fPoint.Append(System.Double,System.Double,System.Double)">
            <summary>note that precision is lost</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fPoint.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3fPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fPoint.CopyToArray">
            <summary>
Create an array of floats[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3fPoint.TryFastGet(System.Int32,System.Single@,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3fPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dVector.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dVector.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dVector.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dVector.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dVector.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dVector.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn3dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn3dPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*3] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(0).z
array[3] = At(1).x
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn3dPoint.TryFastGet(System.Int32,System.Double@,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dPoint.Z(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn3dPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fVector.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fVector.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fVector.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fVector.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fPoint.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2fPoint.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2fPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fPoint.CopyToArray">
            <summary>
Create an array of floats[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2fPoint.TryFastGet(System.Int32,System.Single@,System.Single@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2fPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dVector.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dVector.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dVector.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dVector.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dVector.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dVector.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.ArrayOn2dPoint.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.ArrayOn2dPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dPoint.CopyToArray">
            <summary>
Create an array of doubles[count*2] with the values in this array
Values are tightly packed so
array[0] = At(0).x
array[1] = At(0).y
array[2] = At(1).x
array[3] = At(1).y
...
</summary>
        </member>
        <member name="M:RMA.OpenNURBS.IArrayOn2dPoint.TryFastGet(System.Int32,System.Double@,System.Double@)">
            <summary>Fast access to internal values</summary>
            <returns>true if successful (index is in range of array</returns>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dPoint.Y(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="P:RMA.OpenNURBS.IArrayOn2dPoint.X(System.Int32)">
            <summary>Fast access to internal value in array</summary>
        </member>
        <member name="T:RMA.SubClasser">
            <summary>
Empty value class used for internal purposes when subclassing managed class.
The only time that this may be useful from a plug-in is for C++ extension DLLs.
Expert Level Tool: DO NOT use this class unless you absolutely know what you are doing with it.
</summary>
        </member>
        <member name="T:RMA.ConstException">
            <summary>
Rhino.NET wraps unmanaged C++ classes. const versions of classes are exposed as interfaces
to .NET. If a developer attempts to cast a const interface up to its non-const class implementation,
the .NET framework will allow this. When the user later tries to call a non-const function on this
const wrapped class, a ConstException will be thrown.
</summary>
        </member>
        <member name="M:ON_NurbsCurve.GetSpanVector(System.Double*)">
     (m_knot[m_order-2],...,m_knot[m_cv_count-1)
</member>
    </members>
</doc>